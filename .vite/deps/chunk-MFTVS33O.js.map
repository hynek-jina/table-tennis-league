{
  "version": 3,
  "sources": ["../../node_modules/@evolu/common/dist/src/Array.js", "../../node_modules/@evolu/common/dist/src/Assert.js", "../../node_modules/@evolu/common/dist/src/BigInt.js", "../../node_modules/@noble/ciphers/src/utils.ts", "../../node_modules/@noble/hashes/src/utils.ts", "../../node_modules/@noble/hashes/src/_md.ts", "../../node_modules/@noble/hashes/src/_u64.ts", "../../node_modules/@noble/hashes/src/sha2.ts", "../../node_modules/@noble/hashes/src/hmac.ts", "../../node_modules/@noble/hashes/src/webcrypto.ts", "../../node_modules/@scure/base/index.ts", "../../node_modules/@scure/bip39/index.js", "../../node_modules/@scure/bip39/wordlists/english.js", "../../node_modules/msgpackr/unpack.js", "../../node_modules/msgpackr/pack.js", "../../node_modules/@evolu/common/dist/src/Object.js", "../../node_modules/@evolu/common/dist/src/Platform.js", "../../node_modules/@evolu/common/dist/src/Result.js", "../../node_modules/@evolu/common/dist/src/String.js", "../../node_modules/@evolu/common/dist/src/Type.js", "../../node_modules/@evolu/common/dist/src/Buffer.js", "../../node_modules/@evolu/common/dist/src/Cache.js", "../../node_modules/@evolu/common/dist/src/Callbacks.js", "../../node_modules/@evolu/common/dist/src/Console.js", "../../node_modules/@noble/ciphers/src/_arx.ts", "../../node_modules/@noble/ciphers/src/_poly1305.ts", "../../node_modules/@noble/ciphers/src/chacha.ts", "../../node_modules/@evolu/common/dist/src/Crypto.js", "../../node_modules/@evolu/common/dist/src/Eq.js", "../../node_modules/@evolu/common/dist/src/Error.js", "../../node_modules/@evolu/common/dist/src/Function.js", "../../node_modules/@noble/hashes/src/legacy.ts", "../../node_modules/@evolu/common/dist/src/Identicon.js", "../../node_modules/@evolu/common/dist/src/Instances.js", "../../node_modules/@evolu/common/dist/src/Sqlite.js", "../../node_modules/@evolu/common/dist/src/Store.js", "../../node_modules/@evolu/common/dist/src/Worker.js", "../../node_modules/@evolu/common/dist/src/local-first/Owner.js", "../../node_modules/@evolu/common/dist/src/Number.js", "../../node_modules/@evolu/common/dist/src/local-first/Schema.js", "../../node_modules/@evolu/common/dist/src/Order.js", "../../node_modules/@evolu/common/dist/src/local-first/Timestamp.js", "../../node_modules/@evolu/common/dist/src/local-first/Storage.js", "../../node_modules/@evolu/common/dist/src/local-first/Protocol.js", "../../node_modules/@evolu/common/dist/src/local-first/Query.js", "../../node_modules/@evolu/common/dist/src/Resources.js", "../../node_modules/@evolu/common/dist/src/Time.js", "../../node_modules/@evolu/common/dist/src/Task.js", "../../node_modules/@evolu/common/dist/src/local-first/Sync.js", "../../node_modules/@evolu/common/dist/src/local-first/Db.js", "../../node_modules/@evolu/common/dist/src/local-first/Evolu.js", "../../node_modules/@evolu/common/dist/src/local-first/LocalAuth.js", "../../node_modules/@evolu/common/dist/src/local-first/PublicKysely.js", "../../node_modules/random/src/rng.ts", "../../node_modules/random/src/generators/function.ts", "../../node_modules/random/src/utils.ts", "../../node_modules/random/src/generators/arc4.ts", "../../node_modules/random/src/generators/math-random.ts", "../../node_modules/random/src/generators/xor128.ts", "../../node_modules/random/src/validation.ts", "../../node_modules/random/src/distributions/bates.ts", "../../node_modules/random/src/distributions/bernoulli.ts", "../../node_modules/random/src/distributions/binomial.ts", "../../node_modules/random/src/distributions/exponential.ts", "../../node_modules/random/src/distributions/geometric.ts", "../../node_modules/random/src/distributions/irwin-hall.ts", "../../node_modules/random/src/distributions/log-normal.ts", "../../node_modules/random/src/distributions/normal.ts", "../../node_modules/random/src/distributions/pareto.ts", "../../node_modules/random/src/distributions/poisson.ts", "../../node_modules/random/src/distributions/uniform.ts", "../../node_modules/random/src/distributions/uniform-boolean.ts", "../../node_modules/random/src/distributions/uniform-int.ts", "../../node_modules/random/src/distributions/weibull.ts", "../../node_modules/random/src/random.ts", "../../node_modules/@evolu/common/dist/src/Random.js", "../../node_modules/@evolu/common/dist/src/Redacted.js", "../../node_modules/@evolu/common/dist/src/Ref.js", "../../node_modules/@evolu/common/dist/src/Relation.js", "../../node_modules/@evolu/common/dist/src/WebSocket.js"],
  "sourcesContent": ["/**\n * Array types, type guards, operations, transformations, accessors, and (rare)\n * mutations\n *\n * ### Example\n *\n * ```ts\n * // Types - compile-time guarantee of at least one element\n * const _valid: NonEmptyReadonlyArray<number> = [1, 2, 3];\n * // ts-expect-error - empty array is not a valid NonEmptyReadonlyArray\n * const _invalid: NonEmptyReadonlyArray<number> = [];\n *\n * // Type guards\n * const arr: ReadonlyArray<number> = [1, 2, 3];\n * if (isNonEmptyReadonlyArray(arr)) {\n *   firstInArray(arr);\n * }\n *\n * // Operations\n * const appended = appendToArray([1, 2, 3], 4); // [1, 2, 3, 4]\n * const prepended = prependToArray([2, 3], 1); // [1, 2, 3]\n *\n * // Transformations\n * const readonly: ReadonlyArray<number> = [1, 2, 3];\n * const mapped = mapArray(readonly, (x) => x * 2); // [2, 4, 6]\n * const filtered = filterArray(readonly, (x) => x > 1); // [2, 3]\n * const deduped = dedupeArray([1, 2, 1, 3, 2]); // [1, 2, 3]\n * const [evens, odds] = partitionArray(\n *   [1, 2, 3, 4, 5],\n *   (x) => x % 2 === 0,\n * ); // [[2, 4], [1, 3, 5]]\n *\n * // Accessors\n * const first = firstInArray([\"a\", \"b\", \"c\"]); // \"a\"\n * const last = lastInArray([\"a\", \"b\", \"c\"]); // \"c\"\n *\n * // Mutations\n * const mutable: NonEmptyArray<number> = [1, 2, 3];\n * shiftArray(mutable); // 1 (guaranteed to exist)\n * mutable; // [2, 3]\n * ```\n *\n * Functions are intentionally data-first to be prepared for the upcoming\n * JavaScript pipe operator.\n *\n * ```ts\n * // Data-first is natural for single operations.\n * const timestamps = mapArray(messages, (m) => m.timestamp);\n *\n * // But data-first can be hard to read for nested calls.\n * const result = firstInArray(\n *   mapArray(dedupeArray(appendToArray(value, 2)), (x) => x * 2),\n * );\n *\n * // With the upcoming pipe operator, it's clear.\n * // const result = value\n * //   |> appendToArray(%, 2)\n * //   |> dedupeArray(%)\n * //   |> mapArray(%, (x) => x * 2)\n * //   |> firstInArray(%);\n *\n * // Until the pipe operator lands, use nested calls or name each step:\n * const appended = appendToArray(value, 2);\n * const deduped = dedupeArray(appended);\n * const mapped = mapArray(deduped, (x) => x * 2);\n * const result = firstInArray(mapped);\n * ```\n *\n * ### Why data-first?\n *\n * Evolu optimizes for consistent code style. We can't have both data-first\n * single operations and curried data-last helpers without sacrificing\n * consistency. We chose data-first because:\n *\n * - It's natural for single operations (for example `mapArray(messages, (m) =>\n *   m.timestamp)`).\n * - It aligns with the upcoming JavaScript pipe operator.\n *\n * **Note**: Feel free to use Array instance methods (mutation) if you think\n * it's better (performance, local scope, etc.).\n *\n * @module\n */\n/**\n * Checks if an array is non-empty and narrows its type to {@link NonEmptyArray}.\n *\n * Use `if (!isNonEmptyArray(arr))` for empty checks.\n *\n * ### Example\n *\n * ```ts\n * const arr: Array<number> = [1, 2, 3];\n * if (isNonEmptyArray(arr)) {\n *   firstInArray(arr); // arr is NonEmptyArray<number>\n * }\n * ```\n *\n * @category Type Guards\n */\nexport const isNonEmptyArray = (array) => array.length > 0;\n/**\n * Checks if a readonly array is non-empty and narrows its type to\n * {@link NonEmptyReadonlyArray}.\n *\n * Use `if (!isNonEmptyReadonlyArray(arr))` for empty checks.\n *\n * ### Example\n *\n * ```ts\n * const arr: ReadonlyArray<number> = [1, 2, 3];\n * if (isNonEmptyReadonlyArray(arr)) {\n *   firstInArray(arr); // arr is NonEmptyReadonlyArray<number>\n * }\n * ```\n *\n * @category Type Guards\n */\nexport const isNonEmptyReadonlyArray = (array) => array.length > 0;\n/**\n * Appends an item to an array, returning a new non-empty readonly array.\n *\n * Accepts both mutable and readonly arrays. Does not mutate the original array.\n *\n * ### Example\n *\n * ```ts\n * appendToArray([1, 2, 3], 4); // [1, 2, 3, 4]\n * ```\n *\n * @category Operations\n */\nexport const appendToArray = (array, item) => [...array, item];\n/**\n * Prepends an item to an array, returning a new non-empty readonly array.\n *\n * Accepts both mutable and readonly arrays. Does not mutate the original array.\n *\n * ### Example\n *\n * ```ts\n * prependToArray([2, 3], 1); // [1, 2, 3]\n * ```\n *\n * @category Operations\n */\nexport const prependToArray = (array, item) => [item, ...array];\nexport function mapArray(array, mapper) {\n    return array.map(mapper);\n}\nexport function filterArray(array, predicate) {\n    return array.filter(predicate);\n}\nexport function dedupeArray(array, by) {\n    if (by == null) {\n        return Array.from(new Set(array));\n    }\n    const seen = new Set();\n    return array.filter((item) => {\n        const key = by(item);\n        if (seen.has(key))\n            return false;\n        seen.add(key);\n        return true;\n    });\n}\nexport function partitionArray(array, predicate) {\n    const trueArray = [];\n    const falseArray = [];\n    for (let i = 0; i < array.length; i++) {\n        if (predicate(array[i], i)) {\n            trueArray.push(array[i]);\n        }\n        else {\n            falseArray.push(array[i]);\n        }\n    }\n    return [trueArray, falseArray];\n}\n/**\n * Returns the first element of a non-empty array.\n *\n * Accepts both mutable and readonly arrays. Does not mutate the original array.\n *\n * ### Example\n *\n * ```ts\n * firstInArray([\"a\", \"b\", \"c\"]); // \"a\"\n * ```\n *\n * @category Accessors\n */\nexport const firstInArray = (array) => array[0];\n/**\n * Returns the last element of a non-empty array.\n *\n * Accepts both mutable and readonly arrays. Does not mutate the original array.\n *\n * ### Example\n *\n * ```ts\n * lastInArray([\"a\", \"b\", \"c\"]); // \"c\"\n * ```\n *\n * @category Accessors\n */\nexport const lastInArray = (array) => array[array.length - 1];\n/**\n * Shifts an item from a non-empty mutable array, guaranteed to return T.\n *\n * **Mutates** the original array.\n *\n * ### Example\n *\n * ```ts\n * const arr: NonEmptyArray<number> = [1, 2, 3];\n * shiftArray(arr); // 1\n * arr; // [2, 3]\n * ```\n *\n * @category Mutations\n */\nexport const shiftArray = (array) => array.shift();\n/**\n * Pops an item from a non-empty mutable array, guaranteed to return T.\n *\n * **Mutates** the original array.\n *\n * ### Example\n *\n * ```ts\n * const arr: NonEmptyArray<number> = [1, 2, 3];\n * popArray(arr); // 3\n * arr; // [1, 2]\n * ```\n *\n * @category Mutations\n */\nexport const popArray = (array) => array.pop();\n", "/**\n * Ensures a condition is true, throwing an error with the provided message if\n * not.\n *\n * Prevents invalid states from propagating through the system by halting\n * execution when a condition fails, improving reliability and debuggability.\n *\n * **Warning**: Do not use this instead of {@link Type}. Assertions are intended\n * for conditions that are logically guaranteed but not statically known by\n * TypeScript, or for catching and signaling developer mistakes eagerly (e.g.,\n * invalid configuration).\n *\n * ### Example\n *\n * ```ts\n * assert(true, \"true is not true\"); // no-op\n * assert(false, \"true is not true\"); // throws Error\n *\n * const length = buffer.getLength();\n * // We know length is logically non-negative, but TypeScript doesn't\n * assert(\n *   NonNegativeInt.is(length),\n *   \"buffer length should be non-negative\",\n * );\n * ```\n */\nexport const assert = (condition, message) => {\n    if (!condition) {\n        throw new Error(message);\n    }\n};\n/**\n * Asserts that an array is non-empty.\n *\n * Ensures the provided array has at least one element, helping TypeScript infer\n * the array as non-empty when this is logically guaranteed but not statically\n * known.\n *\n * ### Example\n *\n * ```ts\n * assertNonEmptyArray([1, 2, 3]); // no-op\n * assertNonEmptyArray([]); // throws Error\n * ```\n */\nexport const assertNonEmptyArray = (arr, message = \"Expected a non-empty array.\") => {\n    assert(arr.length > 0, message);\n};\n/**\n * Asserts that a readonly array is non-empty.\n *\n * Ensures the provided readonly array has at least one element, helping\n * TypeScript infer non-emptiness when this is logically guaranteed but not\n * statically known.\n *\n * ### Example\n *\n * ```ts\n * assertNonEmptyReadonlyArray([1, 2, 3]); // no-op\n * assertNonEmptyReadonlyArray([]); // throws Error\n * ```\n */\nexport const assertNonEmptyReadonlyArray = (arr, message = \"Expected a non-empty readonly array.\") => {\n    assert(arr.length > 0, message);\n};\n", "/** Increments a bigint by 1. */\nexport const incrementBigInt = (n) => n + 1n;\n/** Decrements a bigint by 1. */\nexport const decrementBigInt = (n) => n - 1n;\n/** Clamps a bigint within a given range. */\nexport const clampBigInt = (min, max) => (n) => n < min ? min : n > max ? max : n;\n/**\n * Creates a predicate that checks if a BigInt is within a range, inclusive.\n *\n * ### Example\n *\n * ```ts\n * const isBetween10And20 = isBetweenBigInt(10n, 20n);\n * console.log(isBetween10And20(15n)); // true\n * console.log(isBetween10And20(25n)); // false\n * ```\n */\nexport const isBetweenBigInt = (min, max) => (value) => value >= min && value <= max;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is boolean. */\nexport function abool(b: boolean): void {\n  if (typeof b !== 'boolean') throw new Error(`boolean expected, not ${b}`);\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport type IHash = {\n  (data: string | Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// Used in micro\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return BigInt(hex === '' ? '0' : '0x' + hex); // Big Endian\n}\n\n// Used in ff1\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\n\n// Used in micro, ff1\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(new Uint8Array([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/**\n * Checks if two U8A use same underlying buffer and overlaps.\n * This is invalid and can corrupt data.\n */\nexport function overlapBytes(a: Uint8Array, b: Uint8Array): boolean {\n  return (\n    a.buffer === b.buffer && // best we can do, may fail with an obscure Proxy\n    a.byteOffset < b.byteOffset + b.byteLength && // a starts before b end\n    b.byteOffset < a.byteOffset + a.byteLength // b starts before a end\n  );\n}\n\n/**\n * If input and output overlap and input starts before output, we will overwrite end of input before\n * we start processing it, so this is not supported for most ciphers (except chacha/salse, which designed with this)\n */\nexport function complexOverlapBytes(input: Uint8Array, output: Uint8Array): void {\n  // This is very cursed. It works somehow, but I'm completely unsure,\n  // reasoning about overlapping aligned windows is very hard.\n  if (overlapBytes(input, output) && input.byteOffset < output.byteOffset)\n    throw new Error('complex overlap of input and output is not supported');\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Used in ARX only\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts: T2\n): T1 & T2 {\n  if (opts == null || typeof opts !== 'object') throw new Error('options must be defined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Compares 2 uint8array-s in kinda constant time. */\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// TODO: remove\nexport interface IHash2 {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: string | Uint8Array): this;\n  // Writes digest into buf\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  destroy(): void;\n}\n\n// This will allow to re-use with composable things like packed & base encoders\n// Also, we probably can make tags composable\n\n/** Sync cipher: takes byte array and returns byte array. */\nexport type Cipher = {\n  encrypt(plaintext: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array): Uint8Array;\n};\n\n/** Async cipher e.g. from built-in WebCrypto. */\nexport type AsyncCipher = {\n  encrypt(plaintext: Uint8Array): Promise<Uint8Array>;\n  decrypt(ciphertext: Uint8Array): Promise<Uint8Array>;\n};\n\n/** Cipher with `output` argument which can optimize by doing 1 less allocation. */\nexport type CipherWithOutput = Cipher & {\n  encrypt(plaintext: Uint8Array, output?: Uint8Array): Uint8Array;\n  decrypt(ciphertext: Uint8Array, output?: Uint8Array): Uint8Array;\n};\n\n/**\n * Params are outside of return type, so it is accessible before calling constructor.\n * If function support multiple nonceLength's, we return the best one.\n */\nexport type CipherParams = {\n  blockSize: number;\n  nonceLength?: number;\n  tagLength?: number;\n  varSizeNonce?: boolean;\n};\n/** ARX cipher, like salsa or chacha. */\nexport type ARXCipher = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  AAD?: Uint8Array\n) => CipherWithOutput) & {\n  blockSize: number;\n  nonceLength: number;\n  tagLength: number;\n};\nexport type CipherCons<T extends any[]> = (key: Uint8Array, ...args: T) => Cipher;\n/**\n * Wraps a cipher: validates args, ensures encrypt() can only be called once.\n * @__NO_SIDE_EFFECTS__\n */\nexport const wrapCipher = <C extends CipherCons<any>, P extends CipherParams>(\n  params: P,\n  constructor: C\n): C & P => {\n  function wrappedCipher(key: Uint8Array, ...args: any[]): CipherWithOutput {\n    // Validate key\n    abytes(key, undefined, 'key');\n\n    // Big-Endian hardware is rare. Just in case someone still decides to run ciphers:\n    if (!isLE) throw new Error('Non little-endian hardware is not yet supported');\n\n    // Validate nonce if nonceLength is present\n    if (params.nonceLength !== undefined) {\n      const nonce = args[0];\n      abytes(nonce, params.varSizeNonce ? undefined : params.nonceLength, 'nonce');\n    }\n\n    // Validate AAD if tagLength present\n    const tagl = params.tagLength;\n    if (tagl && args[1] !== undefined) abytes(args[1], undefined, 'AAD');\n\n    const cipher = constructor(key, ...args);\n    const checkOutput = (fnLength: number, output?: Uint8Array) => {\n      if (output !== undefined) {\n        if (fnLength !== 2) throw new Error('cipher output not supported');\n        abytes(output, undefined, 'output');\n      }\n    };\n    // Create wrapped cipher with validation and single-use encryption\n    let called = false;\n    const wrCipher = {\n      encrypt(data: Uint8Array, output?: Uint8Array) {\n        if (called) throw new Error('cannot encrypt() twice with same key + nonce');\n        called = true;\n        abytes(data);\n        checkOutput(cipher.encrypt.length, output);\n        return (cipher as CipherWithOutput).encrypt(data, output);\n      },\n      decrypt(data: Uint8Array, output?: Uint8Array) {\n        abytes(data);\n        if (tagl && data.length < tagl)\n          throw new Error('\"ciphertext\" expected length bigger than tagLength=' + tagl);\n        checkOutput(cipher.decrypt.length, output);\n        return (cipher as CipherWithOutput).decrypt(data, output);\n      },\n    };\n\n    return wrCipher;\n  }\n\n  Object.assign(wrappedCipher, params);\n  return wrappedCipher as C & P;\n};\n\n/** Represents salsa / chacha stream. */\nexport type XorStream = (\n  key: Uint8Array,\n  nonce: Uint8Array,\n  data: Uint8Array,\n  output?: Uint8Array,\n  counter?: number\n) => Uint8Array;\n\n/**\n * By default, returns u8a of length.\n * When out is available, it checks it for validity and uses it.\n */\nexport function getOutput(\n  expectedLength: number,\n  out?: Uint8Array,\n  onlyAligned = true\n): Uint8Array {\n  if (out === undefined) return new Uint8Array(expectedLength);\n  if (out.length !== expectedLength)\n    throw new Error(\n      '\"output\" expected Uint8Array of length ' + expectedLength + ', got: ' + out.length\n    );\n  if (onlyAligned && !isAligned32(out)) throw new Error('invalid output, must be aligned');\n  return out;\n}\n\nexport function u64Lengths(dataLength: number, aadLength: number, isLE: boolean): Uint8Array {\n  abool(isLE);\n  const num = new Uint8Array(16);\n  const view = createView(num);\n  view.setBigUint64(0, BigInt(aadLength), isLE);\n  view.setBigUint64(8, BigInt(dataLength), isLE);\n  return num;\n}\n\n// Is byte array aligned to 4 byte offset (u32)?\nexport function isAligned32(bytes: Uint8Array): boolean {\n  return bytes.byteOffset % 4 === 0;\n}\n\n// copy bytes to new u8a (aligned). Because Buffer.slice is broken.\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/**\n * The pseudorandom number generator doesn't wipe current state:\n * instead, it generates new one based on previous state + entropy.\n * Not reseed/rekey, since AES CTR DRBG does rekey on each randomBytes,\n * which is in fact `reseed`, since it changes counter too.\n */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\ntype RemoveNonceInner<T extends any[], Ret> = ((...args: T) => Ret) extends (\n  arg0: any,\n  arg1: any,\n  ...rest: infer R\n) => any\n  ? (key: Uint8Array, ...args: R) => Ret\n  : never;\n\nexport type RemoveNonce<T extends (...args: any) => any> = RemoveNonceInner<\n  Parameters<T>,\n  ReturnType<T>\n>;\nexport type CipherWithNonce = ((\n  key: Uint8Array,\n  nonce: Uint8Array,\n  ...args: any[]\n) => Cipher | AsyncCipher) & {\n  nonceLength: number;\n};\n\n/**\n * Uses CSPRG for nonce, nonce injected in ciphertext.\n * For `encrypt`, a `nonceBytes`-length buffer is fetched from CSPRNG and\n * prepended to encrypted ciphertext. For `decrypt`, first `nonceBytes` of ciphertext\n * are treated as nonce.\n *\n * NOTE: Under the same key, using random nonces (e.g. `managedNonce`) with AES-GCM and ChaCha\n * should be limited to `2**23` (8M) messages to get a collision chance of `2**-50`. Stretching to  * `2**32` (4B) messages, chance would become `2**-33` - still negligible, but creeping up.\n * @example\n * const gcm = managedNonce(aes.gcm);\n * const ciphr = gcm(key).encrypt(data);\n * const plain = gcm(key).decrypt(ciph);\n */\nexport function managedNonce<T extends CipherWithNonce>(\n  fn: T,\n  randomBytes_: typeof randomBytes = randomBytes\n): RemoveNonce<T> {\n  const { nonceLength } = fn;\n  anumber(nonceLength);\n  const addNonce = (nonce: Uint8Array, ciphertext: Uint8Array) => {\n    const out = concatBytes(nonce, ciphertext);\n    ciphertext.fill(0);\n    return out;\n  };\n  // NOTE: we cannot support DST here, it would be mistake:\n  // - we don't know how much dst length cipher requires\n  // - nonce may unalign dst and break everything\n  // - we create new u8a anyway (concatBytes)\n  // - previously we passed all args to cipher, but that was mistake!\n  return ((key: Uint8Array, ...args: any[]): any => ({\n    encrypt(plaintext: Uint8Array) {\n      abytes(plaintext);\n      const nonce = randomBytes_(nonceLength);\n      const encrypted = fn(key, nonce, ...args).encrypt(plaintext);\n      // @ts-ignore\n      if (encrypted instanceof Promise) return encrypted.then((ct) => addNonce(nonce, ct));\n      return addNonce(nonce, encrypted);\n    },\n    decrypt(ciphertext: Uint8Array) {\n      abytes(ciphertext);\n      const nonce = ciphertext.subarray(0, nonceLength);\n      const decrypted = ciphertext.subarray(nonceLength);\n      return fn(key, nonce, ...args).decrypt(decrypted);\n    },\n  })) as RemoveNonce<T>;\n}\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number, title: string = ''): void {\n  if (!Number.isSafeInteger(n) || n < 0) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n  }\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts something is hash */\nexport function ahash(h: CHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash must wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'digestInto() output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput, errorTitle = ''): Uint8Array {\n  if (typeof data === 'string') return utf8ToBytes(data);\n  return abytes(data, undefined, errorTitle);\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\n/** Merges default options and passed options. */\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Common interface for all hashes. */\nexport interface Hash<T> {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: Uint8Array): this;\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  destroy(): void;\n  _cloneInto(to?: T): T;\n  clone(): T;\n}\n\n/** PseudoRandom (number) Generator */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash constructor */\nexport type HasherCons<T, Opts = undefined> = Opts extends undefined ? () => T : (opts?: Opts) => T;\n/** Optional hash params. */\nexport type HashInfo = {\n  oid?: Uint8Array; // DER encoded OID in bytes\n};\n/** Hash function */\nexport type CHash<T extends Hash<T> = Hash<any>, Opts = undefined> = {\n  outputLen: number;\n  blockLen: number;\n} & HashInfo &\n  (Opts extends undefined\n    ? {\n        (msg: Uint8Array): Uint8Array;\n        create(): T;\n      }\n    : {\n        (msg: Uint8Array, opts?: Opts): Uint8Array;\n        create(opts?: Opts): T;\n      });\n/** XOF with output */\nexport type CHashXOF<T extends HashXOF<T> = HashXOF<any>, Opts = undefined> = CHash<T, Opts>;\n\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher<T extends Hash<T>, Opts = undefined>(\n  hashCons: HasherCons<T, Opts>,\n  info: HashInfo = {}\n): CHash<T, Opts> {\n  const hashC: any = (msg: Uint8Array, opts?: Opts) => hashCons(opts).update(msg).digest();\n  const tmp = hashCons(undefined);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: Opts) => hashCons(opts);\n  Object.assign(hashC, info);\n  return Object.freeze(hashC);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix: number): Required<HashInfo> => ({\n  oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView, type Hash } from './utils.ts';\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> implements Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen must be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to as unknown as any;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, oidNist, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\n/** Internal 32-byte base SHA2 hash class. */\nabstract class SHA2_32B<T extends SHA2_32B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected abstract A: number;\n  protected abstract B: number;\n  protected abstract C: number;\n  protected abstract D: number;\n  protected abstract E: number;\n  protected abstract F: number;\n  protected abstract G: number;\n  protected abstract H: number;\n\n  constructor(outputLen: number) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B<_SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n  constructor() {\n    super(32);\n  }\n}\n\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B<_SHA224> {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal 64-byte base SHA2 hash class. */\nabstract class SHA2_64B<T extends SHA2_64B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected abstract Ah: number;\n  protected abstract Al: number;\n  protected abstract Bh: number;\n  protected abstract Bl: number;\n  protected abstract Ch: number;\n  protected abstract Cl: number;\n  protected abstract Dh: number;\n  protected abstract Dl: number;\n  protected abstract Eh: number;\n  protected abstract El: number;\n  protected abstract Fh: number;\n  protected abstract Fl: number;\n  protected abstract Gh: number;\n  protected abstract Gl: number;\n  protected abstract Hh: number;\n  protected abstract Hl: number;\n\n  constructor(outputLen: number) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B<_SHA512> {\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor() {\n    super(64);\n  }\n}\n\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B<_SHA384> {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B<_SHA512_224> {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B<_SHA512_256> {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256: CHash<_SHA256> = /* @__PURE__ */ createHasher(\n  () => new _SHA256(),\n  /* @__PURE__ */ oidNist(0x01)\n);\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash<_SHA224> = /* @__PURE__ */ createHasher(\n  () => new _SHA224(),\n  /* @__PURE__ */ oidNist(0x04)\n);\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash<_SHA512> = /* @__PURE__ */ createHasher(\n  () => new _SHA512(),\n  /* @__PURE__ */ oidNist(0x03)\n);\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash<_SHA384> = /* @__PURE__ */ createHasher(\n  () => new _SHA384(),\n  /* @__PURE__ */ oidNist(0x02)\n);\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash<_SHA512_256> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_256(),\n  /* @__PURE__ */ oidNist(0x06)\n);\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash<_SHA512_224> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_224(),\n  /* @__PURE__ */ oidNist(0x05)\n);\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, type CHash, type Hash } from './utils.ts';\n\n/** Internal class for HMAC. */\nexport class _HMAC<T extends Hash<T>> implements Hash<_HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, key: Uint8Array) {\n    ahash(hash);\n    abytes(key, undefined, 'key');\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Uint8Array): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen, 'output');\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: _HMAC<T>): _HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): _HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array;\n  create(hash: CHash, key: Uint8Array): _HMAC<any>;\n} = (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array =>\n  new _HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Uint8Array) => new _HMAC<any>(hash, key);\n", "import { type Pbkdf2Opt } from './pbkdf2.ts';\nimport {\n  abytes,\n  ahash,\n  anumber,\n  checkOpts,\n  kdfInputToBytes,\n  type CHash,\n  type KDFInput,\n} from './utils.ts';\n\nfunction _subtle(): typeof crypto.subtle {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  const sb = cr?.subtle;\n  if (typeof sb === 'object' && sb != null) return sb;\n  throw new Error('crypto.subtle must be defined');\n}\n\nexport type WebHash = {\n  (msg: Uint8Array): Promise<Uint8Array>;\n  webCryptoName: string;\n  outputLen: number;\n  blockLen: number;\n};\n\nfunction createWebHash(name: string, blockLen: number, outputLen: number): WebHash {\n  const hashC: any = async (msg: Uint8Array) => {\n    abytes(msg);\n    const crypto = _subtle();\n    return new Uint8Array(await crypto.digest(name, msg as BufferSource));\n  };\n  hashC.webCryptoName = name; // make sure it won't interfere with function name\n  hashC.outputLen = outputLen;\n  hashC.blockLen = blockLen;\n  hashC.create = () => {\n    throw new Error('not implemented');\n  };\n  return hashC;\n}\n\nfunction ahashWeb(hash: WebHash) {\n  ahash(hash as any as CHash);\n  if (typeof hash.webCryptoName !== 'string') throw new Error('non-web hash');\n}\n\n/** WebCrypto SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\n// export const sha1: WebHash = createHash('SHA-1', 64, 20);\n\n/** WebCrypto SHA2-256 hash function from RFC 4634. */\nexport const sha256: WebHash = /* @__PURE__ */ createWebHash('SHA-256', 64, 32);\n/** WebCrypto SHA2-384 hash function from RFC 4634. */\nexport const sha384: WebHash = /* @__PURE__ */ createWebHash('SHA-384', 128, 48);\n/** WebCrypto SHA2-512 hash function from RFC 4634. */\nexport const sha512: WebHash = /* @__PURE__ */ createWebHash('SHA-512', 128, 64);\n\n/**\n * WebCrypto HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256. Webcrypto version.\n * @param key - key which would be used to authenticate message\n * @param message - message\n * @example\n * ```js\n * import { hmac, sha256 } from '@noble/hashes/webcrypto.js';\n * const mac1 = await hmac(sha256, 'key', 'message');\n * ```\n */\nexport const hmac: {\n  (hash: WebHash, key: Uint8Array, message: Uint8Array): Promise<Uint8Array>;\n  create(hash: WebHash, key: Uint8Array): any;\n} = /* @__PURE__ */ (() => {\n  const hmac_ = async (\n    hash: WebHash,\n    key: Uint8Array,\n    message: Uint8Array\n  ): Promise<Uint8Array> => {\n    const crypto = _subtle();\n    abytes(key, undefined, 'key');\n    abytes(message, undefined, 'message');\n    ahashWeb(hash);\n    // WebCrypto keys can't be zeroized\n    // prettier-ignore\n    const wkey = await crypto.importKey(\n      'raw',\n      key as BufferSource,\n      { name: 'HMAC', hash: hash.webCryptoName },\n      false,\n      ['sign']\n    );\n    return new Uint8Array(await crypto.sign('HMAC', wkey, message as BufferSource));\n  };\n  hmac_.create = (_hash: WebHash, _key: Uint8Array) => {\n    throw new Error('not implemented');\n  };\n  return hmac_;\n})();\n\n/**\n * WebCrypto HKDF (RFC 5869): derive keys from an initial input.\n * Combines hkdf_extract + hkdf_expand in one step\n * @param hash - hash function that would be used (e.g. sha256). Webcrypto version.\n * @param ikm - input keying material, the initial key\n * @param salt - optional salt value (a non-secret random value)\n * @param info - optional context and application specific information (can be a zero-length string)\n * @param length - length of output keying material in bytes\n * @example\n * ```js\n * import { hkdf, sha256 } from '@noble/hashes/webcrypto.js';\n * import { randomBytes } from '@noble/hashes/utils.js';\n * const inputKey = randomBytes(32);\n * const salt = randomBytes(32);\n * const info = 'application-key';\n * const hk1w = await hkdf(sha256, inputKey, salt, info, 32);\n * ```\n */\nexport async function hkdf(\n  hash: WebHash,\n  ikm: Uint8Array,\n  salt: Uint8Array | undefined,\n  info: Uint8Array | undefined,\n  length: number\n): Promise<Uint8Array> {\n  const crypto = _subtle();\n  ahashWeb(hash);\n  abytes(ikm, undefined, 'ikm');\n  anumber(length, 'length');\n  if (salt !== undefined) abytes(salt, undefined, 'salt');\n  if (info !== undefined) abytes(info, undefined, 'info');\n  const wkey = await crypto.importKey('raw', ikm as BufferSource, 'HKDF', false, ['deriveBits']);\n  const opts = {\n    name: 'HKDF',\n    hash: hash.webCryptoName,\n    salt: salt === undefined ? new Uint8Array(0) : salt,\n    info: info === undefined ? new Uint8Array(0) : info,\n  };\n  return new Uint8Array(await crypto.deriveBits(opts, wkey, 8 * length));\n}\n\n/**\n * WebCrypto PBKDF2-HMAC: RFC 2898 key derivation function\n * @param hash - hash function that would be used e.g. sha256. Webcrypto version.\n * @param password - password from which a derived key is generated\n * @param salt - cryptographic salt\n * @param opts - {c, dkLen} where c is work factor and dkLen is output message size\n * @example\n * ```js\n * const key = await pbkdf2(sha256, 'password', 'salt', { dkLen: 32, c: Math.pow(2, 18) });\n * ```\n */\nexport async function pbkdf2(\n  hash: WebHash,\n  password: KDFInput,\n  salt: KDFInput,\n  opts: Pbkdf2Opt\n): Promise<Uint8Array> {\n  const crypto = _subtle();\n  ahashWeb(hash);\n  const _opts = checkOpts({ dkLen: 32 }, opts);\n  const { c, dkLen } = _opts;\n  anumber(c, 'c');\n  anumber(dkLen, 'dkLen');\n  const _password = kdfInputToBytes(password, 'password');\n  const _salt = kdfInputToBytes(salt, 'salt');\n  const key = await crypto.importKey('raw', _password as BufferSource, 'PBKDF2', false, [\n    'deriveBits',\n  ]);\n  const deriveOpts = { name: 'PBKDF2', salt: _salt, iterations: c, hash: hash.webCryptoName };\n  return new Uint8Array(await crypto.deriveBits(deriveOpts, key, 8 * dkLen));\n}\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2.js';\nimport { sha256, sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, anumber, randomBytes } from '@noble/hashes/utils.js';\nimport { pbkdf2 as pbkdf2web, sha512 as sha512web } from '@noble/hashes/webcrypto.js';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError('invalid mnemonic type: ' + typeof str);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction aentropy(ent) {\n    abytes(ent);\n    if (![16, 20, 24, 28, 32].includes(ent.length))\n        throw new Error('invalid entropy length');\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    anumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error('wordlist: non-string element: ' + i);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase) => nfkd('mnemonic' + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Uses native, built-in functionality, provided by globalThis.crypto.\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedWebcrypto(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedWebcrypto(mnemonic, passphrase = '') {\n    return pbkdf2web(sha512web, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n", "export const wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n", "var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n\t\treturn property.flat().toString();\n\t}\n\tthrow new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = data => {\n\tlet headLength = (data.byteLength % 8) || 8\n\tlet head = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0])\n\tfor (let i = 1; i < headLength; i++) {\n\t\thead <<= BigInt(8)\n\t\thead += BigInt(data[i])\n\t}\n\tif (data.byteLength !== headLength) {\n\t\tlet view = new DataView(data.buffer, data.byteOffset, data.byteLength)\n\t\tlet decode = (start, end) => {\n\t\t\tlet length = end - start\n\t\t\tif (length <= 40) {\n\t\t\t\tlet out = view.getBigUint64(start)\n\t\t\t\tfor (let i = start + 8; i < end; i += 8) {\n\t\t\t\t\tout <<= BigInt(64n)\n\t\t\t\t\tout |= view.getBigUint64(i)\n\t\t\t\t}\n\t\t\t\treturn out\n\t\t\t}\n\t\t\t// if (length === 8) return view.getBigUint64(start)\n\t\t\tlet middle = start + (length >> 4 << 3)\n\t\t\tlet left = decode(start, middle)\n\t\t\tlet right = decode(middle, end)\n\t\t\treturn (left << BigInt((end - middle) * 8)) | right\n\t\t}\n\t\thead = (head << BigInt((view.byteLength - headLength) * 8)) | decode(headLength, view.byteLength)\n\t}\n\treturn head\n}\n\nlet errors = {\n\tError, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError, AggregateError: typeof AggregateError === 'function' ? AggregateError : null,\n}\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\tif (!errors[data[0]]) {\n\t\tlet error = Error(data[1], { cause: data[2] })\n\t\terror.name = data[0]\n\t\treturn error\n\t}\n\treturn errors[data[0]](data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf)\n\t\ttarget = new Map()\n\telse if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position + 1] === 0x73)\n\t\ttarget = new Set()\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (!refEntry.used) {\n\t\t// no cycle, can just use the returned read object\n\t\treturn refEntry.target = targetProperties // replace the placeholder with the real one\n\t} else {\n\t\t// there is a cycle, so we have to assign properties to original target\n\t\tObject.assign(target, targetProperties)\n\t}\n\n\t// copy over map/set entries if we're able to\n\tif (target instanceof Map)\n\t\tfor (let [k, v] of targetProperties.entries()) target.set(k, v)\n\tif (target instanceof Set)\n\t\tfor (let i of Array.from(targetProperties)) target.add(i)\n\treturn target\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\t// we always have to slice to get a new ArrayBuffer that is aligned\n\tlet buffer = Uint8Array.prototype.slice.call(data, 1).buffer\n\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) return buffer\n\t\tif (typeCode === 17) return new DataView(buffer)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\treturn new glbl[typedArrayName](buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n", "import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < 0x10000000000000000 && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if (this.useBigIntExtension || this.moreTypes) {\n\t\t\t\t\t\tlet empty = value < 0 ? BigInt(-1) : BigInt(0)\n\n\t\t\t\t\t\tlet array\n\t\t\t\t\t\tif (value >> BigInt(0x10000) === empty) {\n\t\t\t\t\t\t\tlet mask = BigInt(0x10000000000000000) - BigInt(1) // literal would overflow\n\t\t\t\t\t\t\tlet chunks = []\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tchunks.push(value & mask)\n\t\t\t\t\t\t\t\tif ((value >> BigInt(63)) === empty) break\n\t\t\t\t\t\t\t\tvalue >>= BigInt(64)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tarray = new Uint8Array(new BigUint64Array(chunks).buffer)\n\t\t\t\t\t\t\tarray.reverse()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet invert = value < 0\n\t\t\t\t\t\t\tlet string = (invert ? ~value : value).toString(16)\n\t\t\t\t\t\t\tif (string.length % 2) {\n\t\t\t\t\t\t\t\tstring = '0' + string\n\t\t\t\t\t\t\t} else if (parseInt(string.charAt(0), 16) >= 8) {\n\t\t\t\t\t\t\t\tstring = '00' + string\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (hasNodeBuffer) {\n\t\t\t\t\t\t\t\tarray = Buffer.from(string, 'hex')\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tarray = new Uint8Array(string.length / 2)\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\t\t\t\t\tarray[i] = parseInt(string.slice(i * 2, i * 2 + 2), 16)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (invert) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < array.length; i++) array[i] = ~array[i]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (array.length + position > safeEnd)\n\t\t\t\t\t\t\tmakeRoom(array.length + position)\n\t\t\t\t\t\tposition = writeExtensionData(array, target, position, 0x42)\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\ttargetView = target.dataView;\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, DataView, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x11, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048\n", "/**\n * Checks if a value is a plain object (e.g., created with `{}` or `Object`).\n *\n * ### Example\n *\n * ```ts\n * isPlainObject({}); // true\n * isPlainObject(new Date()); // false\n * isPlainObject([]); // false\n * isPlainObject(null); // false\n * ```\n */\nexport const isPlainObject = (value) => Object.prototype.toString.call(value) === \"[object Object]\";\n/**\n * Like `Object.entries` but preserves branded keys.\n *\n * ### Example\n *\n * ```ts\n * type UserId = string & { readonly __brand: \"UserId\" };\n * const users = createRecord<UserId, string>();\n * const entries = objectToEntries(users); // [UserId, string][]\n * ```\n */\nexport const objectToEntries = (record) => Object.entries(record);\n/**\n * Maps a `ReadonlyRecord<K, V>` to a new `ReadonlyRecord<K, U>`, preserving\n * branded key types (e.g., `type Id = 'id' & string`) lost by `Object.entries`.\n * Uses `K extends string` for precision.\n */\nexport const mapObject = (record, fn) => Object.fromEntries(Object.entries(record).map(([key, value]) => [\n    key,\n    fn(value, key),\n]));\n/** Conditionally excludes a property from an object. */\nexport const excludeProp = (obj, prop, condition) => {\n    if (condition) {\n        return { ...obj };\n    }\n    const { [prop]: _, ...rest } = obj;\n    return rest;\n};\n/**\n * Creates a prototype-less object typed as `Record<K, V>`.\n *\n * Use this function when you need a plain record without a prototype chain\n * (e.g. when keys are controlled by external sources) to avoid prototype\n * pollution and accidental collisions with properties like `__proto__`.\n *\n * Example:\n *\n * ```ts\n * const values = createRecord<string, SqliteValue>();\n * values[\"__proto__\"] = someValue; // safe, no prototype pollution\n * ```\n */\nexport const createRecord = () => Object.create(null);\n/**\n * Safely gets a property from a record, returning `undefined` if the key\n * doesn't exist.\n *\n * TypeScript's `Record<K, V>` type assumes all keys exist, but at runtime\n * accessing a non-existent key returns `undefined`. This helper provides proper\n * typing for that case without needing a type assertion.\n *\n * ### Example\n *\n * ```ts\n * const users: Record<string, User> = { alice: { name: \"Alice\" } };\n * const user = getProperty(users, \"bob\"); // User | undefined\n * ```\n */\nexport const getProperty = (record, key) => (key in record ? record[key] : undefined);\n", "/** Detects if the code is running in React Native environment. */\nexport const isReactNative = typeof navigator !== \"undefined\" &&\n    \"product\" in navigator &&\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    navigator.product === \"ReactNative\";\n/**\n * Detects if Node.js Buffer is available and should be used.\n *\n * React Native apps often polyfill Node.js APIs like Buffer, but we want to use\n * native methods when available for better performance.\n *\n * Returns false in React Native even if Buffer is polyfilled, as we prefer\n * native methods in that environment.\n *\n * @see https://github.com/craftzdog/react-native-quick-base64#installation\n */\nexport const hasNodeBuffer = !isReactNative && typeof globalThis.Buffer !== \"undefined\";\n", "export function ok(value = undefined) {\n    return { ok: true, value: value };\n}\n/**\n * Creates an {@link Err} result.\n *\n * ### Example\n *\n * ```ts\n * const failure = err(\"Something went wrong\");\n * console.log(failure); // { ok: false, error: \"Something went wrong\" }\n * ```\n */\nexport const err = (error) => ({ ok: false, error });\n/**\n * Extracts the value from a {@link Result} if it is an `Ok`, or throws an error\n * if it is an `Err`.\n *\n * **Intended usage:**\n *\n * - For critical code paths (e.g., app startup, config values) where failure\n *   should crash the app.\n * - Not recommended for general error handling in application logicprefer\n *   explicit checks.\n *\n * ### Example\n *\n * ```ts\n * // At app startup, crash if config is invalid:\n * const config = getOrThrow(loadConfig());\n * // Safe to use config here\n * ```\n *\n * Throws: `Error` with the original error attached as `cause`.\n */\nexport const getOrThrow = (result) => {\n    if (result.ok) {\n        return result.value;\n    }\n    else {\n        throw new Error(\"getOrThrow\", { cause: result.error });\n    }\n};\n/**\n * Extracts the value from a {@link Result} if it is an `Ok`, or returns `null`\n * if it is an `Err`.\n *\n * **Intended usage:**\n *\n * - When you need to convert a `Result` to a nullable value for APIs that expect\n *   `T | null`.\n * - When the error is not important and you just want the value or nothing.\n *\n * ### Example\n *\n * ```ts\n * const parseResult = parseJson('{\"key\": \"value\"}');\n * const value = getOrNull(parseResult);\n * // value is unknown | null\n *\n * if (value != null) {\n *   console.log(\"Parsed value:\", value);\n * }\n * ```\n */\nexport const getOrNull = (result) => result.ok ? result.value : null;\n/**\n * Wraps synchronous functions that may throw exceptions, returning a\n * {@link Result}.\n *\n * The `trySync` function is designed to handle synchronous code safely by\n * wrapping the execution in a try-catch block. If the function succeeds, it\n * returns an `Ok` result. If an exception is thrown, it maps the error to a\n * custom type and returns an `Err` result.\n *\n * ### Example\n *\n * ```ts\n * interface ParseJsonError {\n *   readonly type: \"ParseJsonError\";\n *   readonly message: string;\n * }\n *\n * const parseJson = (value: string): Result<unknown, ParseJsonError> =>\n *   trySync(\n *     () => JSON.parse(value) as unknown,\n *     (error): ParseJsonError => ({\n *       type: \"ParseJsonError\",\n *       message: String(error),\n *     }),\n *   );\n * ```\n */\nexport const trySync = (fn, mapError) => {\n    try {\n        return ok(fn());\n    }\n    catch (error) {\n        return err(mapError(error));\n    }\n};\n/**\n * Wraps async functions or any operation returning a promise, returning a\n * {@link Result}.\n *\n * The `tryAsync` function provides a way to handle asynchronous code safely by\n * catching any rejected promises and mapping errors to a custom type. If the\n * promise resolves, it returns an `Ok` result. If the promise rejects, it maps\n * the error and returns an `Err` result.\n *\n * ### Example\n *\n * ```ts\n * interface FetchError {\n *   readonly type: \"FetchError\";\n *   readonly message: string;\n * }\n *\n * const tryFetch = async (\n *   url: string,\n * ): Promise<Result<unknown, FetchError>> =>\n *   tryAsync(\n *     async () => {\n *       const response = await fetch(url);\n *       if (!response.ok) {\n *         throw new Error(`Request failed with status ${response.status}`);\n *       }\n *       return response.json();\n *     },\n *     (error) => ({\n *       type: \"FetchError\",\n *       message: String(error),\n *     }),\n *   );\n *\n * const result = await tryFetch(\n *   \"https://jsonplaceholder.typicode.com/posts/1\",\n * );\n * if (result.ok) {\n *   console.log(\"Data:\", result.value);\n * } else {\n *   console.error(\"Error:\", result.error);\n * }\n * ```\n */\nexport const tryAsync = async (promiseFn, mapError) => promiseFn().then((value) => ok(value), (error) => err(mapError(error)));\n", "export const safelyStringifyUnknownValue = (value) => {\n    if (value === null)\n        return \"null\";\n    if (value === undefined)\n        return \"undefined\";\n    if (typeof value === \"string\")\n        return `\"${value}\"`;\n    try {\n        return JSON.stringify(value);\n    }\n    catch {\n        return globalThis.String(value);\n    }\n};\n", "import { utf8ToBytes } from \"@noble/ciphers/utils.js\";\nimport { sha256 } from \"@noble/hashes/sha2.js\";\nimport * as bip39 from \"@scure/bip39\";\nimport { wordlist } from \"@scure/bip39/wordlists/english.js\";\nimport { pack } from \"msgpackr\";\nimport { isPlainObject } from \"./Object.js\";\nimport { hasNodeBuffer } from \"./Platform.js\";\nimport { err, getOrNull, getOrThrow, ok, trySync } from \"./Result.js\";\nimport { safelyStringifyUnknownValue } from \"./String.js\";\nconst EvoluTypeSymbol = Symbol(\"evolu.Type\");\n/**\n * Checks if the given value is an {@link Type}.\n *\n * @category Utilities\n */\nexport const isType = (value) => typeof value === \"object\" && value !== null && EvoluTypeSymbol in value;\nconst createType = (name, definition) => ({\n    ...definition,\n    name,\n    is: (value) => definition.fromUnknown(value).ok,\n    from: definition.fromUnknown,\n    orThrow: (value) => getOrThrow(definition.fromUnknown(value)),\n    orNull: (value) => getOrNull(definition.fromUnknown(value)),\n    [EvoluTypeSymbol]: true,\n    Type: undefined,\n    Input: undefined,\n    Error: undefined,\n    Parent: undefined,\n    ParentError: undefined,\n    Errors: undefined,\n    \"~standard\": {\n        version: 1,\n        vendor: \"evolu\",\n        validate: (value) => {\n            const result = definition.fromUnknown(value);\n            if (result.ok) {\n                return { value: result.value };\n            }\n            cachedStandardSchemaFormatTypeError ??= createFormatTypeError();\n            return {\n                issues: typeErrorToStandardSchemaIssues(result.error, cachedStandardSchemaFormatTypeError),\n            };\n        },\n        types: {\n            input: undefined,\n            output: undefined,\n        },\n    },\n});\n/**\n * Creates a formatter function for {@link TypeError}.\n *\n * The formatter generates human-readable error messages using a custom\n * formatting function and a safely stringified error value.\n *\n * ### Example\n *\n * ```ts\n * const formatStringError = createTypeErrorFormatter<StringError>(\n *   (value) => `A value ${value} is not a string.`,\n * );\n * ```\n *\n * @category Utilities\n */\nexport const createTypeErrorFormatter = (format) => (error) => format({ ...error, value: safelyStringifyUnknownValue(error.value) });\n/**\n * Base {@link Type}.\n *\n * A Base Type validates that a value conforms to a specific TypeScript type.\n *\n * ### Example\n *\n * ```ts\n * const String = base(\"String\", (value) =>\n *   typeof value === \"string\"\n *     ? ok(value)\n *     : err<StringError>({ type: \"String\", value }),\n * );\n *\n * interface StringError extends TypeError<\"String\"> {}\n *\n * const formatStringError = createTypeErrorFormatter<StringError>(\n *   (error) => `A value ${error.value} is not a string`,\n * );\n * ```\n *\n * @category Base Factories\n */\nexport const base = (name, fromUnknown) => createType(name, {\n    fromUnknown,\n    fromParent: (ok), // `fromParent` relies on types, so it can't fail for the Base Type\n});\n/**\n * Creates a formatter function for a base {@link TypeError}.\n *\n * This formatter is specifically for Base Types that only need a simple error\n * message indicating that the value is not of the expected type.\n *\n * ### Example\n *\n * ```ts\n * export const formatStringError =\n *   createBaseTypeErrorFormatter<StringError>();\n * ```\n *\n * @category Utilities\n */\nexport const createBaseTypeErrorFormatter = () => createTypeErrorFormatter((error) => `A value ${error.value} is not a ${error.type.toLowerCase()}.`);\n/** @category Base Types */\nexport const Unknown = base(\"Unknown\", ok);\n/**\n * @category Base Types\n * @category String\n */\nexport const String = base(\"String\", (value) => typeof value === \"string\"\n    ? ok(value)\n    : err({ type: \"String\", value }));\nexport const formatStringError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const Number = base(\"Number\", (value) => typeof value === \"number\"\n    ? ok(value)\n    : err({ type: \"Number\", value }));\nexport const formatNumberError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const BigInt = base(\"BigInt\", (value) => typeof value === \"bigint\"\n    ? ok(value)\n    : err({ type: \"BigInt\", value }));\nexport const formatBigIntError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const Boolean = base(\"Boolean\", (value) => typeof value === \"boolean\"\n    ? ok(value)\n    : err({ type: \"Boolean\", value }));\nexport const formatBooleanError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const Undefined = base(\"Undefined\", (value) => value === undefined\n    ? ok(value)\n    : err({ type: \"Undefined\", value }));\nexport const formatUndefinedError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const Null = base(\"Null\", (value) => value === null ? ok(value) : err({ type: \"Null\", value }));\nexport const formatNullError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const Function = base(\"Function\", (value) => typeof value === \"function\"\n    ? ok(value)\n    : err({ type: \"Function\", value }));\nexport const formatFunctionError = createBaseTypeErrorFormatter();\n/** @category Base Types */\nexport const Uint8Array = base(\"Uint8Array\", (value) => value instanceof globalThis.Uint8Array\n    ? ok(value)\n    : err({ type: \"Uint8Array\", value }));\nexport const formatUint8ArrayError = createBaseTypeErrorFormatter();\n/**\n * `instanceof` {@link Type}.\n *\n * Ensures that a value is an instance of the given class constructor.\n *\n * ### Example\n *\n * ```ts\n * class User {\n *   constructor(public name: string) {}\n * }\n *\n * const UserInstance = instanceOf(User);\n *\n * const result = UserInstance.from(new User(\"Alice\")); // ok\n * const error = UserInstance.from({}); // err\n * ```\n *\n * @category Base Factories\n */\nexport const instanceOf = (ctor) => ({\n    ...base(\"InstanceOf\", (value) => value instanceof ctor\n        ? ok(value)\n        : err({ type: \"InstanceOf\", value, ctor: ctor.name })),\n    ctor,\n});\nexport const formatInstanceOfError = createTypeErrorFormatter((error) => `The value ${error.value} is not an instance of ${error.ctor}.`);\n/**\n * JavaScript Date.\n *\n * @category Base Types\n */\nexport const Date = instanceOf(globalThis.Date);\n/**\n * Validates that an unknown value is an Evolu {@link Type} (i.e., satisfies\n * `AnyType`).\n *\n * ### Example\n *\n * ```ts\n * const result = EvoluType.from(String); // ok(String)\n * const error = EvoluType.from(\"not a Type\"); // err\n * ```\n */\n// TODO: Rename to TypeInstance or something like that.\nexport const EvoluType = base(\"EvoluType\", (value) => isType(value)\n    ? ok(value)\n    : err({\n        type: \"EvoluType\",\n        value,\n    }));\nexport const formatIsTypeError = createTypeErrorFormatter((error) => `Value ${error.value} is not a valid Evolu Type.`);\nexport function brand(name, parent, refine) {\n    const fromUnknown = refine\n        ? (value) => {\n            const parentResult = parent.fromUnknown(value);\n            if (!parentResult.ok)\n                return parentResult;\n            return refine(parentResult.value);\n        }\n        : (value) => {\n            const parentResult = parent.fromUnknown(value);\n            if (!parentResult.ok)\n                return err({\n                    type: name,\n                    value,\n                    parentError: parentResult.error,\n                });\n            return ok(parentResult.value);\n        };\n    return {\n        ...createType(\"Brand\", {\n            fromUnknown,\n            fromParent: (refine ?? ok),\n        }),\n        brand: name,\n        parentType: parent,\n    };\n}\n/**\n * A three-letter ISO 4217 currency code (e.g., USD, EUR).\n *\n * @category String\n */\nexport const CurrencyCode = brand(\"CurrencyCode\", String, (value) => /^[A-Z]{3}$/.test(value)\n    ? ok(value)\n    : err({ type: \"CurrencyCode\", value }));\nexport const formatCurrencyCodeError = createTypeErrorFormatter((error) => `Invalid currency code: ${error.value}.`);\n/**\n * ISO 8601 date-time string.\n *\n * This {@link Type} represents a date-time string that follows the ISO 8601\n * format and is compatible with SQLite, which lacks a native date type and\n * relies on ISO 8601 strings for sorting. Enforcing a 24-character format\n * ensures correct lexicographic ordering.\n *\n * It must be a valid JavaScript Date string that can be parsed.\n *\n * Valid range: `\"0000-01-01T00:00:00.000Z\"` to `\"9999-12-31T23:59:59.999Z\"`.\n *\n * ### Example\n *\n * ```ts\n * const result = DateIso.from(\"2023-01-01T12:00:00.000Z\"); // ok\n * const error = DateIso.from(\"10000-01-01T00:00:00.000Z\"); // err\n * ```\n *\n * @category String\n */\nexport const DateIso = brand(\"DateIso\", String, (value) => {\n    if (value.length !== 24) {\n        return err({ type: \"DateIso\", value });\n    }\n    const parsed = globalThis.Date.parse(value);\n    if (isNaN(parsed)) {\n        return err({ type: \"DateIso\", value });\n    }\n    // Round-trip test: ensure the string is actually a proper ISO format\n    const roundTrip = new globalThis.Date(parsed).toISOString();\n    if (roundTrip !== value) {\n        return err({ type: \"DateIso\", value });\n    }\n    return ok(value);\n});\nexport const formatDateIsoError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid ISO 8601 date string.`);\nexport const dateToDateIso = (value) => DateIso.fromParent(value.toISOString());\nexport const dateIsoToDate = (value) => new globalThis.Date(value);\n/**\n * Trimmed string.\n *\n * This Type Factory validates whether a string has no leading or trailing\n * whitespaces.\n *\n * ### Example\n *\n * ```ts\n * const TrimmedNonEmptyString = trimmed(minLength(1)(String));\n * // string & Brand<\"MinLength1\"> & Brand<\"Trimmed\">\n * type TrimmedNonEmptyString = typeof TrimmedNonEmptyString.Type;\n * ```\n *\n * @category String\n */\nexport const trimmed = (parent) => brand(\"Trimmed\", parent, (value) => value.trim().length === value.length\n    ? ok(value)\n    : err({ type: \"Trimmed\", value }));\nexport const formatTrimmedError = createTypeErrorFormatter((error) => `The value ${error.value} must be trimmed.`);\n/**\n * Trimmed string\n *\n * - Use `TrimmedString.is` to check if an unknown value is trimmed.\n * - Use `TrimmedString.from` to check if a string is trimmed.\n *\n * @category String\n */\nexport const TrimmedString = trimmed(String);\nexport const trim = (value) => value.trim();\n/**\n * Minimum length.\n *\n * ### Example\n *\n * ```ts\n * // string & Brand<\"MinLength1\">\n * const NonEmptyString = minLength(1)(String);\n * ```\n *\n * @category String\n * @category Array\n */\nexport const minLength = (min) => (parent) => brand(`MinLength${min}`, parent, (value) => value.length >= min ? ok(value) : err({ type: \"MinLength\", value, min }));\nexport const formatMinLengthError = createTypeErrorFormatter((error) => `The value ${error.value} does not meet the minimum length of ${error.min}.`);\n/**\n * Maximum length.\n *\n * ### Example\n *\n * ```ts\n * // string & Brand<\"MaxLength100\">\n * const String100 = maxLength(100)(String);\n * ```\n *\n * @category String\n * @category Array\n */\nexport const maxLength = (max) => (parent) => brand(`MaxLength${max}`, parent, (value) => value.length <= max ? ok(value) : err({ type: \"MaxLength\", value, max }));\nexport const formatMaxLengthError = createTypeErrorFormatter((error) => `The value ${error.value} exceeds the maximum length of ${error.max}.`);\n/**\n * Exact length.\n *\n * ### Example\n *\n * ```ts\n * // string & Brand<\"Length1\">\n * const Length1String = length(1)(String);\n * ```\n *\n * @category String\n * @category Array\n */\nexport const length = (exact) => (parent) => brand(`Length${exact}`, parent, (value) => value.length === exact\n    ? ok(value)\n    : err({ type: \"Length\", value, exact }));\nexport const formatLengthError = createTypeErrorFormatter((error) => `The value ${error.value} does not have the required length of ${error.exact}.`);\n/** @category String */\nexport const NonEmptyString = minLength(1)(String);\n/** @category String */\nexport const String100 = maxLength(100)(String);\n/** @category String */\nexport const String1000 = maxLength(1000)(String);\n/** @category String */\nexport const NonEmptyString100 = minLength(1)(String100);\n/** @category String */\nexport const NonEmptyString1000 = minLength(1)(String1000);\n/** @category String */\nexport const NonEmptyTrimmedString = minLength(1)(TrimmedString);\n/** @category String */\nexport const TrimmedString100 = maxLength(100)(TrimmedString);\n/** @category String */\nexport const TrimmedString1000 = maxLength(1000)(TrimmedString);\n/** @category String */\nexport const NonEmptyTrimmedString100 = minLength(1)(TrimmedString100);\n/** @category String */\nexport const NonEmptyTrimmedString1000 = minLength(1)(TrimmedString1000);\n/**\n * The mnemonic, also known as a \"seed phrase,\" is a set of 12 words in a\n * specific order chosen from a predefined list (BIP39). It provides a\n * human-readable way to store a private key securely. The mnemonic is generated\n * safely on the user's device using cryptographically secure random number\n * generation, ensuring it remains private and unique.\n *\n * @category String\n */\nexport const Mnemonic = brand(\"Mnemonic\", NonEmptyTrimmedString, (value) => bip39.validateMnemonic(value, wordlist)\n    ? ok(value)\n    : err({ type: \"Mnemonic\", value }));\nexport const formatMnemonicError = createTypeErrorFormatter((error) => `Invalid BIP39 mnemonic: ${error.value}.`);\n/**\n * String matching a regular expression.\n *\n * ### Example\n *\n * ```ts\n * const Alphanumeric = regex(\"Alphanumeric\", /^[a-z0-9]+$/i)(String);\n * ```\n *\n * @category String\n */\nexport const regex = (name, pattern) => {\n    // Clone the regex to avoid shared state.\n    const clonedPattern = new RegExp(pattern.source, pattern.flags);\n    return (parent) => brand(name, parent, (value) => {\n        // Reset `lastIndex` before each use to ensure the regex starts matching\n        // from the beginning of the string.\n        clonedPattern.lastIndex = 0;\n        return clonedPattern.test(value)\n            ? ok(value)\n            : err({ type: \"Regex\", name, value, pattern });\n    });\n};\nexport const formatRegexError = createTypeErrorFormatter((error) => `The value ${error.value} does not match the pattern for ${error.name}: ${error.pattern}.`);\n/**\n * URL-safe string.\n *\n * A `UrlSafeString` uses a limited alphabet that is safe for URLs:\n *\n * - Uppercase letters (`A-Z`)\n * - Lowercase letters (`a-z`)\n * - Digits (`0-9`)\n * - Dash (`-`)\n * - Underscore (`_`)\n *\n * This is the same character set used by Base64Url encoding, but this type does\n * not validate that the string is actually Base64Url-encoded data.\n *\n * ### Example\n *\n * ```ts\n * const result = UrlSafeString.from(\"abc123_-\");\n * if (result.ok) {\n *   console.log(\"Valid URL-safe string:\", result.value);\n * } else {\n *   console.error(\"Invalid URL-safe string:\", result.error);\n * }\n * ```\n *\n * @category String\n */\nexport const UrlSafeString = regex(\"UrlSafeString\", /^[A-Za-z0-9_-]+$/)(String);\n/**\n * Base64Url without padding.\n *\n * Encode with {@link uint8ArrayToBase64Url}, decode with\n * {@link base64UrlToUint8Array}.\n *\n * @category String\n */\nexport const Base64Url = brand(\"Base64Url\", String, (value) => {\n    // Round-trip validation ensures consistency across different base64url\n    // implementations (Node.js Buffer, native browser API, manual fallback).\n    // Only strings that decode and encode identically are accepted.\n    let roundTrip;\n    try {\n        roundTrip = uint8ArrayToBase64Url(base64UrlToUint8Array(value));\n    }\n    catch {\n        //\n    }\n    return roundTrip === value\n        ? ok(value)\n        : err({ type: \"Base64Url\", value });\n});\nexport const formatBase64UrlError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid Base64Url string.`);\nconst base64UrlOptions = { alphabet: \"base64url\", omitPadding: true };\n/** Encodes a Uint8Array to a {@link Base64Url} string. */\nexport const uint8ArrayToBase64Url = hasNodeBuffer\n    ? (bytes) => globalThis.Buffer.from(bytes).toString(\"base64url\")\n    : // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        typeof globalThis.Uint8Array.prototype?.toBase64 !== \"undefined\"\n            ? (bytes) => \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            bytes.toBase64(base64UrlOptions)\n            : (bytes) => {\n                const binaryString = Array.from(bytes, (byte) => globalThis.String.fromCodePoint(byte)).join(\"\");\n                const base64 = globalThis.btoa(binaryString);\n                return base64\n                    .replace(/\\+/g, \"-\")\n                    .replace(/\\//g, \"_\")\n                    .replace(/=/g, \"\");\n            };\n/** Decodes a {@link Base64Url} string to a Uint8Array. */\nexport const base64UrlToUint8Array = hasNodeBuffer\n    ? (str) => {\n        const nodeBuffer = globalThis.Buffer.from(str, \"base64url\");\n        return new globalThis.Uint8Array(nodeBuffer);\n    }\n    : // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        typeof globalThis.Uint8Array?.fromBase64 !== \"undefined\"\n            ? (str) => \n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            globalThis.Uint8Array.fromBase64(str, base64UrlOptions)\n            : (str) => {\n                let base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n                while (base64.length % 4 !== 0) {\n                    base64 += \"=\";\n                }\n                const binaryString = globalThis.atob(base64);\n                return globalThis.Uint8Array.from(binaryString, (c) => c.charCodeAt(0));\n            };\n/**\n * Simple alphanumeric string for naming in file systems, URLs, and identifiers.\n *\n * Uses the same safe alphabet as {@link UrlSafeString} (letters, digits, `-`,\n * `_`). See `UrlSafeString` for details.\n *\n * The string must be between 1 and 64 characters.\n *\n * ### Example\n *\n * ```ts\n * const result = SimpleName.from(\"data-report-123\");\n * if (result.ok) {\n *   console.log(\"Valid SimpleName string:\", result.value);\n * } else {\n *   console.error(\"Invalid SimpleName string:\", result.error);\n * }\n * ```\n *\n * @category String\n */\nexport const SimpleName = brand(\"SimpleName\", UrlSafeString, (value) => value.length >= 1 && value.length <= 64\n    ? ok(value)\n    : err({ type: \"SimpleName\", value }));\n/**\n * Trimmed string between 8 and 64 characters, branded as `SimplePassword`.\n *\n * Take a look how `SimplePassword` is defined:\n *\n * ```ts\n * export const SimplePassword = brand(\n *   \"SimplePassword\",\n *   minLength(8)(maxLength(64)(TrimmedString)),\n * );\n * ```\n *\n * Nested functions are often OK (if not, make a helper), but with TC39 Hack\n * pipes it would be clearer:\n *\n * ```ts\n * // TrimmedString\n * //   |> minLength(8)(%)\n * //   |> maxLength(64)(%)\n * //   |> brand(\"SimplePassword\", %)\n * ```\n *\n * @category String\n */\nexport const SimplePassword = brand(\"SimplePassword\", minLength(8)(maxLength(64)(TrimmedString)));\nexport const formatSimplePasswordError = (formatTypeError) => createTypeErrorFormatter((error) => `Invalid password: ${formatTypeError(error.parentError)}`);\n/**\n * Evolu Id: 16 bytes encoded as a 22character Base64Url string.\n *\n * There are three ways to create an Evolu Id:\n *\n * - {@link createId}  default cryptographically secure random bytes\n *   (privacypreserving)\n * - {@link createIdFromString}  deterministic: first 16 bytes of SHA256 of a\n *   string\n * - {@link createIdAsUuidv7}  optional: embeds timestamp bits (UUID v7 layout)\n *\n * Privacy: the default random Id does not leak creation time and is safe to\n * share or log. The UUID v7 variant leaks creation time anywhere the Id is\n * copied (logs, URLs, exports); only use it when you explicitly want insertion\n * locality for very large writeheavy tables and accept timestamp exposure.\n *\n * ### Future\n *\n * A possible hybrid maskedtime approach (`timestamp ^ H(cluster_id, timestamp\n *\n * > > N)`) could provide locality without exposing raw creation time. See\n * > > https://brooker.co.za/blog/2025/10/22/uuidv7.html\n *\n * @category String\n */\nexport const Id = brand(\"Id\", String, (value) => value.length === 22 && Base64Url.fromParent(value).ok\n    ? ok(value)\n    : err({ type: \"Id\", value }));\nexport const formatIdError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid Id.`);\n/**\n * Creates a random {@link Id}. This is the recommended default.\n *\n * Use {@link createIdFromString} for deterministic mapping of external IDs or\n * {@link createIdAsUuidv7} when you accept timestamp leakage for index\n * locality.\n *\n * ### Example\n *\n * ```ts\n * const id = createId(deps);\n * const todoId = createId<\"Todo\">(deps);\n * ```\n */\nexport const createId = (deps) => {\n    const id = uint8ArrayToBase64Url(deps.randomBytes.create(16));\n    return id;\n};\n/**\n * Creates an {@link Id} from a string using SHA-256.\n *\n * When integrating with external systems that use different ID formats, use\n * this function to convert external IDs into valid Evolu IDs.\n *\n * In Evolu's CRDT, the ID serves as the unique identifier for conflict\n * resolution across distributed clients. When multiple clients create records\n * with the same external identifier, they must resolve to the same Evolu ID to\n * ensure data consistency.\n *\n * ### Example\n *\n * ```ts\n * // Both clients will generate the same ID\n * const id1 = createIdFromString(\"user-api-123\");\n * const id2 = createIdFromString(\"user-api-123\");\n * console.log(id1 === id2); // true\n *\n * upsert(\"todo\", {\n *   id: createIdFromString(\"external-todo-456\"),\n *   title: \"Synced from external system\",\n * });\n * ```\n *\n * **Important**: This transformation uses the first 16 bytes of SHA-256 hash of\n * the string bytes, therefore it's not possible to recover the original\n * external string from the generated {@link Id}. If you need to preserve the\n * original external ID, store it in a separate column.\n *\n * @category String\n */\nexport const createIdFromString = (value) => {\n    const hash = sha256(utf8ToBytes(value));\n    // Take first 16 bytes of hash and convert to Id\n    const id = idBytesToId(hash.slice(0, 16));\n    return id;\n};\n/**\n * Creates an {@link Id} embedding timestamp bits (UUID v7 layout) before\n * Base64Url encoding.\n *\n * Tradeoff: better insertion locality / index performance for huge datasets vs\n * leaking creation time everywhere the Id appears. Evolu uses {@link createId}\n * by default to avoid activity leakage; choose this only if you explicitly\n * accept timestamp exposure.\n *\n * ### Example\n *\n * ```ts\n * const id = createIdAsUuidv7({ randomBytes, time });\n * const todoId = createIdAsUuidv7<\"Todo\">({ randomBytes, time });\n * ```\n */\nexport const createIdAsUuidv7 = (deps) => {\n    const id = deps.randomBytes.create(16);\n    const timestamp = globalThis.BigInt(deps.time.now());\n    id[0] = globalThis.Number((timestamp >> 40n) & 0xffn);\n    id[1] = globalThis.Number((timestamp >> 32n) & 0xffn);\n    id[2] = globalThis.Number((timestamp >> 24n) & 0xffn);\n    id[3] = globalThis.Number((timestamp >> 16n) & 0xffn);\n    id[4] = globalThis.Number((timestamp >> 8n) & 0xffn);\n    id[5] = globalThis.Number(timestamp & 0xffn);\n    id[6] = (id[6] & 0x0f) | 0x70;\n    id[8] = (id[8] & 0x3f) | 0x80;\n    return id;\n};\n/**\n * Creates a branded {@link Id} Type for a table's primary key.\n *\n * The table name becomes an additional brand for type safety.\n *\n * ### Example\n *\n * ```ts\n * const TodoId = id(\"Todo\");\n * // string & Brand<\"Id\"> & Brand<\"Todo\">\n * type TodoId = typeof TodoId.Type;\n * ```\n *\n * @category String\n */\nexport const id = (table) => {\n    const fromUnknown = (value) => {\n        const parentResult = String.fromUnknown(value);\n        if (!parentResult.ok)\n            return parentResult;\n        return fromParent(parentResult.value);\n    };\n    const fromParent = (value) => {\n        const idResult = Id.fromParent(value);\n        if (!idResult.ok) {\n            return err({ type: \"TableId\", value, table });\n        }\n        return ok(idResult.value);\n    };\n    return {\n        ...createType(\"Id\", { fromUnknown, fromParent }),\n        table,\n    };\n};\nexport const formatTableIdError = createTypeErrorFormatter((error) => `Invalid Id for table ${error.table}: ${error.value}.`);\n/** Binary representation of an {@link Id}. */\nexport const IdBytes = brand(\"IdBytes\", length(16)(Uint8Array));\nexport const idBytesTypeValueLength = 16;\nexport const idToIdBytes = (id) => \n// Id is Base64Url (validated by Id.from), cast is safe\nbase64UrlToUint8Array(id);\nexport const idBytesToId = (idBytes) => \n// Base64Url encoding of 16 bytes always produces valid Id (22 chars)\nuint8ArrayToBase64Url(idBytes);\n/**\n * Positive number (> 0).\n *\n * ### Example\n *\n * ```ts\n * const PositiveNumber = positive(Number);\n *\n * const result = PositiveNumber.from(42); // ok\n * const errorResult = PositiveNumber.from(-5); // err\n * ```\n *\n * @category Number\n */\nexport const positive = (parent) => brand(\"Positive\", parent, (value) => value > 0 ? ok(value) : err({ type: \"Positive\", value }));\nexport const formatPositiveError = createTypeErrorFormatter((error) => `The value ${error.value} must be positive (> 0).`);\n/**\n * Negative number (< 0).\n *\n * ### Example\n *\n * ```ts\n * const NegativeNumber = negative(Number);\n * ```\n *\n * @category Number\n */\nexport const negative = (parent) => brand(\"Negative\", parent, (value) => value < 0 ? ok(value) : err({ type: \"Negative\", value }));\nexport const formatNegativeError = createTypeErrorFormatter((error) => `The value ${error.value} must be negative (< 0).`);\n/**\n * Non-positive number ( 0).\n *\n * ### Example\n *\n * ```ts\n * const NonPositiveNumber = nonPositive(Number);\n * ```\n *\n * @category Number\n */\nexport const nonPositive = (parent) => brand(\"NonPositive\", parent, (value) => value <= 0\n    ? ok(value)\n    : err({ type: \"NonPositive\", value }));\nexport const formatNonPositiveError = createTypeErrorFormatter((error) => `The value ${error.value} must be non-positive ( 0).`);\n/**\n * Non-negative number ( 0).\n *\n * ### Example\n *\n * ```ts\n * const NonNegativeNumber = nonNegative(Number);\n * ```\n *\n * @category Number\n */\nexport const nonNegative = (parent) => brand(\"NonNegative\", parent, (value) => value >= 0\n    ? ok(value)\n    : err({ type: \"NonNegative\", value }));\nexport const formatNonNegativeError = createTypeErrorFormatter((error) => `The value ${error.value} must be non-negative ( 0).`);\n/**\n * Non-negative number ( 0).\n *\n * @category Number\n */\nexport const NonNegativeNumber = nonNegative(Number);\n/**\n * Positive number (> 0).\n *\n * @category Number\n */\nexport const PositiveNumber = positive(NonNegativeNumber);\n/**\n * Non-positive number ( 0).\n *\n * @category Number\n */\nexport const NonPositiveNumber = nonPositive(Number);\n/**\n * Negative number (< 0).\n *\n * @category Number\n */\nexport const NegativeNumber = negative(NonPositiveNumber);\n/**\n * Integer within the safe range of JavaScript numbers.\n *\n * ### Example\n *\n * ```ts\n * const Int = int(Number);\n * ```\n *\n * @category Number\n */\nexport const int = (parent) => brand(\"Int\", parent, (value) => globalThis.Number.isSafeInteger(value)\n    ? ok(value)\n    : err({ type: \"Int\", value }));\nexport const formatIntError = createTypeErrorFormatter((error) => `The value ${error.value} must be an integer.`);\n/**\n * Integer within the safe range of JavaScript numbers.\n *\n * @category Number\n */\nexport const Int = int(Number);\n/**\n * Non-negative integer ( 0).\n *\n * @category Number\n */\nexport const NonNegativeInt = nonNegative(Int);\n/**\n * Positive integer (> 0).\n *\n * @category Number\n */\nexport const PositiveInt = positive(NonNegativeInt);\n/** Maximum safe positive integer value for practically infinite operations. */\nexport const maxPositiveInt = PositiveInt.orThrow(globalThis.Number.MAX_SAFE_INTEGER);\n/**\n * Non-positive integer ( 0).\n *\n * @category Number\n */\nexport const NonPositiveInt = nonPositive(Int);\n/**\n * Negative integer (< 0).\n *\n * @category Number\n */\nexport const NegativeInt = negative(NonPositiveInt);\n/**\n * Number greater than a specified value.\n *\n * @category Number\n */\nexport const greaterThan = (min) => (parent) => brand(`GreaterThan${min}`, parent, (value) => value > min ? ok(value) : err({ type: \"GreaterThan\", value, min }));\nexport const formatGreaterThanError = createTypeErrorFormatter((error) => `The value ${error.value} is not > ${error.min}.`);\n/**\n * Number less than a specified value.\n *\n * @category Number\n */\nexport const lessThan = (max) => (parent) => brand(`LessThan${max}`, parent, (value) => value < max ? ok(value) : err({ type: \"LessThan\", value, max }));\nexport const formatLessThanError = createTypeErrorFormatter((error) => `The value ${error.value} is not < ${error.max}.`);\n/**\n * Number  a specified value.\n *\n * @category Number\n */\nexport const greaterThanOrEqualTo = (min) => (parent) => brand(`GreaterThanOrEqualTo${min}`, parent, (value) => value >= min\n    ? ok(value)\n    : err({ type: \"GreaterThanOrEqualTo\", value, min }));\nexport const formatGreaterThanOrEqualToError = createTypeErrorFormatter((error) => `The value ${error.value} is not >= ${error.min}.`);\n/**\n * Number  a specified value.\n *\n * @category Number\n */\nexport const lessThanOrEqualTo = (max) => (parent) => brand(`LessThanOrEqualTo${max}`, parent, (value) => value <= max ? ok(value) : err({ type: \"LessThanOrEqualTo\", value, max }));\nexport const formatLessThanOrEqualToError = createTypeErrorFormatter((error) => `The value ${error.value} is not <= ${error.max}.`);\n/**\n * Number that is not NaN.\n *\n * @category Number\n */\nexport const nonNaN = (parent) => brand(\"NonNaN\", parent, (value) => !globalThis.Number.isNaN(value)\n    ? ok(value)\n    : err({ type: \"NonNaN\", value }));\nexport const formatNonNaNError = createTypeErrorFormatter(() => `The value must not be NaN.`);\n/** @category Number */\nexport const NonNaNNumber = nonNaN(Number);\n/**\n * Finite number.\n *\n * @category Number\n */\nexport const finite = (parent) => brand(\"Finite\", parent, (value) => globalThis.Number.isFinite(value)\n    ? ok(value)\n    : err({ type: \"Finite\", value }));\nexport const formatFiniteError = createTypeErrorFormatter((error) => `The value ${error.value} must be finite.`);\n/**\n * Finite number.\n *\n * This Type ensures that a number is finite.\n *\n * **Why is this important?**\n *\n * `JSON.stringify` serializes JavaScript numbers into `null` if they are not\n * finite (e.g., `Infinity`, `-Infinity`, or `NaN`). Using `FiniteNumber` helps\n * prevent these unexpected behaviors when working with JSON serialization.\n *\n * @category Number\n */\nexport const FiniteNumber = finite(Number);\n/**\n * Number that is a multiple of a divisor.\n *\n * @category Number\n */\nexport const multipleOf = (divisor) => (parent) => brand(`MultipleOf${divisor}`, parent, (value) => value % divisor === 0\n    ? ok(value)\n    : err({ type: \"MultipleOf\", value, divisor }));\nexport const formatMultipleOfError = createTypeErrorFormatter((error) => `The value ${error.value} is not a multiple of ${error.divisor}.`);\n/**\n * Number within a range, inclusive.\n *\n * ### Example\n *\n * ```ts\n * const Between1And10 = between(1, 10)(PositiveNumber);\n * const result = Between1And10.from(5); // ok(5)\n * const errorResult = Between1And10.from(11); // err\n * ```\n *\n * @category Number\n */\nexport const between = (min, max) => (parent) => brand(`Between${min}-${max}`, parent, (value) => value >= min && value <= max\n    ? ok(value)\n    : err({ type: \"Between\", value, min, max }));\nexport const formatBetweenError = createTypeErrorFormatter((error) => `The value ${error.value} is not between ${error.min} and ${error.max}, inclusive.`);\n/**\n * Literal {@link Type}.\n *\n * https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types\n *\n * ### Example\n *\n * ```ts\n * const LiteralHello = literal(\"Hello\");\n * const result = LiteralHello.from(\"Hello\"); // ok(\"Hello\")\n * const errorResult = LiteralHello.from(\"World\"); // err\n * ```\n *\n * TODO: Add JsonValue\n *\n * @category Base Factories\n */\nexport const literal = (expected) => {\n    const fromUnknown = (value) => value === expected\n        ? ok(expected)\n        : err({ type: \"Literal\", value, expected });\n    return {\n        ...createType(\"Literal\", {\n            fromUnknown,\n            fromParent: ok,\n        }),\n        expected,\n    };\n};\nexport const formatLiteralError = createTypeErrorFormatter((error) => `The value ${error.value} is not strictly equal to the expected literal: ${globalThis.String(error.expected)}.`);\n/**\n * Array of a specific {@link Type}.\n *\n * Usage:\n *\n * ```ts\n * const NumberArray = array(Number);\n *\n * const result1 = NumberArray.from([1, 2, 3]); // ok([1, 2, 3])\n * const result2 = NumberArray.from([\"a\", \"b\"]); // err(...)\n * ```\n *\n * @category Base Factories\n * @category Array\n */\nexport const array = (element) => {\n    const fromUnknown = (value) => {\n        if (!Array.isArray(value)) {\n            return err({\n                type: \"Array\",\n                value,\n                reason: { kind: \"NotArray\" },\n            });\n        }\n        const result = [];\n        for (let i = 0; i < value.length; i++) {\n            const elementResult = element.fromUnknown(value[i]);\n            if (!elementResult.ok) {\n                return err({\n                    type: \"Array\",\n                    value,\n                    reason: {\n                        kind: \"Element\",\n                        index: i,\n                        error: elementResult.error,\n                    },\n                });\n            }\n            result.push(elementResult.value);\n        }\n        return ok(result);\n    };\n    const fromParent = (value) => {\n        const result = [];\n        for (let i = 0; i < value.length; i++) {\n            const elementResult = element.fromParent(value[i]);\n            if (!elementResult.ok) {\n                return err({\n                    type: \"Array\",\n                    value,\n                    reason: {\n                        kind: \"Element\",\n                        index: i,\n                        error: elementResult.error,\n                    },\n                });\n            }\n            result.push(elementResult.value);\n        }\n        return ok(result);\n    };\n    return {\n        ...createType(\"Array\", { fromUnknown, fromParent }),\n        element,\n    };\n};\nexport const formatArrayError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    switch (error.reason.kind) {\n        case \"NotArray\":\n            return `Expected an array but received ${error.value}.`;\n        case \"Element\":\n            return `Invalid element at index ${error.reason.index}: ${formatTypeError(error.reason.error)}`;\n    }\n});\n/**\n * Set of a specific {@link Type}.\n *\n * ### Example\n *\n * ```ts\n * const NumberSet = set(Number);\n *\n * const result1 = NumberSet.from(new Set([1, 2, 3])); // ok(Set { 1, 2, 3 })\n * const result2 = NumberSet.from(new Set([\"a\", \"b\"])); // err(...)\n * ```\n *\n * @category Base Factories\n */\nexport const set = (element) => {\n    const fromUnknown = (value) => {\n        if (!(value instanceof globalThis.Set)) {\n            return err({\n                type: \"Set\",\n                value,\n                reason: { kind: \"NotSet\" },\n            });\n        }\n        let index = 0;\n        for (const item of value) {\n            const elementResult = element.fromUnknown(item);\n            if (!elementResult.ok) {\n                return err({\n                    type: \"Set\",\n                    value,\n                    reason: {\n                        kind: \"Element\",\n                        index,\n                        error: elementResult.error,\n                    },\n                });\n            }\n            index++;\n        }\n        return ok(value);\n    };\n    const fromParent = (value) => {\n        let index = 0;\n        for (const item of value) {\n            const elementResult = element.fromParent(item);\n            if (!elementResult.ok) {\n                return err({\n                    type: \"Set\",\n                    value,\n                    reason: {\n                        kind: \"Element\",\n                        index,\n                        error: elementResult.error,\n                    },\n                });\n            }\n            index++;\n        }\n        return ok(value);\n    };\n    return {\n        ...createType(\"Set\", { fromUnknown, fromParent }),\n        element,\n    };\n};\nexport const formatSetError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    switch (error.reason.kind) {\n        case \"NotSet\":\n            return `Expected a Set but received ${error.value}.`;\n        case \"Element\":\n            return `Invalid element at index ${error.reason.index}: ${formatTypeError(error.reason.error)}`;\n    }\n});\n/**\n * Record of a key {@link Type} and value {@link Type}.\n *\n * - The input must be a plain object (validated by {@link isPlainObject}).\n * - Each key is validated/transformed by the `key` Type.\n * - Each value is validated/transformed by the `value` Type.\n *\n * The resulting type is `Readonly<Record<KeyT, ValueT>>`.\n *\n * ### Example\n *\n * ```ts\n * const StringToNumberRecord = record(String, Number);\n *\n * // ok({ \"a\": 1, \"b\": 2 })\n * StringToNumberRecord.from({ a: 1, b: 2 });\n *\n * // err => \"Key\" because 42 is not a string key\n * StringToNumberRecord.from({ 42: 1, b: 2 });\n *\n * // err => \"Value\" because \"x\" is not a number\n * StringToNumberRecord.from({ a: \"x\", b: 2 });\n * ```\n *\n * @category Base Factories\n * @category Object\n */\nexport const record = (keyType, valueType) => {\n    const fromUnknown = (value) => {\n        if (!isPlainObject(value)) {\n            return err({\n                type: \"Record\",\n                value,\n                reason: { kind: \"NotRecord\" },\n            });\n        }\n        const result = {};\n        for (const [rawKey, rawValue] of Object.entries(value)) {\n            const keyResult = keyType.fromUnknown(rawKey);\n            if (!keyResult.ok) {\n                return err({\n                    type: \"Record\",\n                    value,\n                    reason: { kind: \"Key\", key: rawKey, error: keyResult.error },\n                });\n            }\n            const valueResult = valueType.fromUnknown(rawValue);\n            if (!valueResult.ok) {\n                return err({\n                    type: \"Record\",\n                    value,\n                    reason: {\n                        kind: \"Value\",\n                        key: rawKey,\n                        error: valueResult.error,\n                    },\n                });\n            }\n            result[keyResult.value] = valueResult.value;\n        }\n        return ok(result);\n    };\n    const fromParent = (value) => {\n        const result = {};\n        for (const [rawKey, rawValue] of Object.entries(value)) {\n            const keyResult = keyType.fromParent(rawKey);\n            if (!keyResult.ok) {\n                return err({\n                    type: \"Record\",\n                    value,\n                    reason: {\n                        kind: \"Key\",\n                        key: rawKey,\n                        error: keyResult.error,\n                    },\n                });\n            }\n            const valueResult = valueType.fromParent(rawValue);\n            if (!valueResult.ok) {\n                return err({\n                    type: \"Record\",\n                    value,\n                    reason: {\n                        kind: \"Value\",\n                        key: keyResult.value,\n                        error: valueResult.error,\n                    },\n                });\n            }\n            result[keyResult.value] = valueResult.value;\n        }\n        return ok(result);\n    };\n    return {\n        ...createType(\"Record\", {\n            fromUnknown,\n            fromParent,\n        }),\n        key: keyType,\n        value: valueType,\n    };\n};\nexport const formatRecordError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    switch (error.reason.kind) {\n        case \"NotRecord\":\n            return `Expected a record (plain object) but received ${error.value}.`;\n        case \"Key\":\n            return `Invalid key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;\n        case \"Value\":\n            return `Invalid value for key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;\n    }\n});\nexport function object(props, record) {\n    /* eslint-disable */\n    const propKeys = Object.keys(props);\n    const fromUnknown = (value) => {\n        if (!isPlainObject(value)) {\n            return err({\n                type: record ? \"ObjectWithRecord\" : \"Object\",\n                value,\n                reason: { kind: \"NotObject\" },\n            });\n        }\n        const errors = {};\n        const result = {};\n        for (const key of propKeys) {\n            if (!(key in value) && isOptionalType(props[key])) {\n                continue;\n            }\n            const propResult = props[key].fromUnknown(value[key]);\n            if (!propResult.ok) {\n                errors[key] = propResult.error;\n            }\n            else {\n                result[key] = propResult.value;\n            }\n        }\n        const extraKeys = Object.keys(value).filter((key) => !propKeys.includes(key));\n        if (record) {\n            for (const key of extraKeys) {\n                const keyResult = record.key.fromUnknown(key);\n                if (!keyResult.ok) {\n                    return err({\n                        type: \"ObjectWithRecord\",\n                        value,\n                        reason: {\n                            kind: \"IndexKey\",\n                            key,\n                            error: keyResult.error,\n                        },\n                    });\n                }\n                const valueResult = record.value.fromUnknown(value[key]);\n                if (!valueResult.ok) {\n                    return err({\n                        type: \"ObjectWithRecord\",\n                        value,\n                        reason: {\n                            kind: \"IndexValue\",\n                            key,\n                            error: valueResult.error,\n                        },\n                    });\n                }\n                result[keyResult.value] = valueResult.value;\n            }\n        }\n        else if (extraKeys.length > 0) {\n            return err({\n                type: \"Object\",\n                value,\n                reason: { kind: \"ExtraKeys\", extraKeys },\n            });\n        }\n        if (Object.keys(errors).length > 0) {\n            return err({\n                type: record ? \"ObjectWithRecord\" : \"Object\",\n                value,\n                reason: { kind: \"Props\", errors },\n            });\n        }\n        return ok(result);\n    };\n    const fromParent = (value) => {\n        const errors = {};\n        const result = {};\n        for (const key of propKeys) {\n            if (!(key in value) && isOptionalType(props[key])) {\n                continue;\n            }\n            const propResult = props[key].fromParent(value[key]);\n            if (!propResult.ok) {\n                errors[key] = propResult.error;\n            }\n            else {\n                result[key] = propResult.value;\n            }\n        }\n        if (record) {\n            for (const [key, val] of Object.entries(value)) {\n                if (!propKeys.includes(key)) {\n                    const keyResult = record.key.fromParent(key);\n                    if (!keyResult.ok) {\n                        return err({\n                            type: \"ObjectWithRecord\",\n                            value,\n                            reason: { kind: \"IndexKey\", key, error: keyResult.error },\n                        });\n                    }\n                    const valueResult = record.value.fromParent(val);\n                    if (!valueResult.ok) {\n                        return err({\n                            type: \"ObjectWithRecord\",\n                            value,\n                            reason: { kind: \"IndexValue\", key, error: valueResult.error },\n                        });\n                    }\n                    result[keyResult.value] = valueResult.value;\n                }\n            }\n        }\n        if (Object.keys(errors).length > 0) {\n            return err({\n                type: record ? \"ObjectWithRecord\" : \"Object\",\n                value,\n                reason: { kind: \"Props\", errors },\n            });\n        }\n        return ok(result);\n    };\n    return {\n        ...createType(record ? \"ObjectWithRecord\" : \"Object\", {\n            fromUnknown,\n            fromParent,\n        }),\n        props,\n        ...(record ? { record } : {}),\n    };\n    /* eslint-enable */\n}\nexport const formatObjectError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    switch (error.reason.kind) {\n        case \"NotObject\":\n            return `Expected a plain object but received ${error.value}`;\n        case \"ExtraKeys\":\n            return `Unexpected extra keys: ${error.reason.extraKeys.join(\", \")}`;\n        case \"Props\": {\n            const formattedErrors = Object.entries(error.reason.errors)\n                .filter(([, error]) => error !== undefined)\n                .map(([key, error]) => `- ${key}: ${formatTypeError(error)}`)\n                .join(\"\\n\");\n            return `Invalid object properties:\\n${formattedErrors}`;\n        }\n    }\n});\nexport const formatObjectWithRecordError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    switch (error.reason.kind) {\n        case \"NotObject\":\n            return `Expected an object, but received ${error.value}.`;\n        case \"Props\":\n            return formatObjectError(formatTypeError)({\n                type: \"Object\",\n                value: error.value,\n                reason: { kind: \"Props\", errors: error.reason.errors },\n            });\n        case \"IndexKey\":\n            return `Invalid index key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;\n        case \"IndexValue\":\n            return `Invalid value at index key ${error.reason.key}: ${formatTypeError(error.reason.error)}`;\n    }\n});\nexport function union(...args) {\n    /**\n     * Good First Issue:\n     *\n     * 1. Optimize for microbenchmarks:\n     *\n     *    - Detect if all arguments are literals and generate a fast-check function.\n     *    - This could significantly improve performance for unions of literals.\n     * 2. Enhance tagged union support:\n     *\n     *    - Detect if all arguments are objects with the same property but different\n     *         literal values (tagged unions).\n     *    - Generate a specialized function to improve validation performance for such\n     *         cases.\n     */\n    const members = args.map((arg) => (isType(arg) ? arg : literal(arg)));\n    const fromUnknown = (value) => {\n        const errors = [];\n        for (const member of members) {\n            const result = member.fromUnknown(value);\n            if (result.ok)\n                return result;\n            errors.push(result.error);\n        }\n        return err({\n            type: \"Union\",\n            value,\n            errors,\n        });\n    };\n    return {\n        ...createType(\"Union\", {\n            fromUnknown,\n            fromParent: fromUnknown,\n        }),\n        members,\n    };\n}\nexport const formatUnionError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    const formattedErrors = error.errors\n        .map((e, i) => `  ${i + 1}. ${formatTypeError(e)}`)\n        .join(\"\\n\");\n    return `Value ${error.value} does not match any member of the union.\\nErrors:\\n${formattedErrors}`;\n});\nexport const isUnionType = (t) => t.name === \"Union\" && Array.isArray(t.members);\n/**\n * Recursive {@link Type}.\n *\n * Recursive types can't be inferred, so we must define them using an interface\n * and `recursive` Type Factory that returns a {@link Type}.\n *\n * ### Example\n *\n * ```ts\n * interface Category {\n *   readonly name: string;\n *   readonly subcategories: ReadonlyArray<Category>;\n * }\n *\n * interface CategoryInput {\n *   readonly name: string;\n *   readonly subcategories: ReadonlyArray<CategoryInput>;\n * }\n *\n * type CategoryError = ObjectError<{\n *   readonly name: typeof String.Error;\n *   readonly subcategories: ArrayError<CategoryError>;\n * }>;\n *\n * const Category = recursive(\n *   (): Type<\"Object\", Category, CategoryInput, CategoryError> =>\n *     object({\n *       name: String,\n *       subcategories: array(Category),\n *     }),\n * );\n * ```\n *\n * @category Base Factories\n */\nexport const recursive = (create) => {\n    let type;\n    return {\n        name: \"Recursive\",\n        from: (value) => {\n            type ??= create();\n            return type.from(value);\n        },\n        fromUnknown: (value) => {\n            type ??= create();\n            return type.fromUnknown(value);\n        },\n        fromParent: (value) => {\n            type ??= create();\n            return type.fromParent(value);\n        },\n        is: (value) => {\n            type ??= create();\n            return type.is(value);\n        },\n        [EvoluTypeSymbol]: true,\n        getParentType: () => {\n            type ??= create();\n            return type;\n        },\n    };\n};\n/**\n * `union(null, T)` {@link Type}.\n *\n * ### Example\n *\n * ```ts\n * const NullOrString = nullOr(String);\n * NullOrString.from(\"hello\"); // ok(\"hello\")\n * NullOrString.from(null); // ok(null)\n * NullOrString.from(42); // err(...)\n * ```\n *\n * @category Base Factories\n */\nexport const nullOr = (type) => union(Null, type);\n/**\n * `union(undefined, T)` {@link Type}.\n *\n * ### Example\n *\n * ```ts\n * const UndefinedOrString = undefinedOr(String);\n * UndefinedOrString.from(\"world\"); // ok(\"world\")\n * UndefinedOrString.from(undefined); // ok()\n * UndefinedOrString.from(42); // err(...)\n * ```\n *\n * @category Base Factories\n */\nexport const undefinedOr = (type) => union(Undefined, type);\n/**\n * `union(undefined, null, T)` {@link Type}.\n *\n * Learn more:\n * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing\n *\n * ### Example\n *\n * ```ts\n * const NullishOrString = nullishOr(String);\n * NullishOrString.from(\"test\"); // ok(\"test\")\n * NullishOrString.from(null); // ok(null)\n * NullishOrString.from(undefined); // ok()\n * NullishOrString.from(42); // err(...)\n * ```\n *\n * @category Base Factories\n */\nexport const nullishOr = (type) => union(Undefined, Null, type);\n/**\n * Tuple {@link Type}.\n *\n * Represents a tuple of specific Types.\n *\n * ### Example\n *\n * ```ts\n * const NameAndAge = tuple(NonEmptyTrimmedString, PositiveNumber);\n *\n * const result = NameAndAge.from([\"Alice\", 25]); // ok([\"Alice\", 25])\n * const error = NameAndAge.from([\"Alice\", -10]); // err\n * ```\n *\n * @category Base Factories\n */\nexport const tuple = (...elements) => {\n    const fromUnknown = (value) => {\n        if (!Array.isArray(value) || value.length !== elements.length) {\n            return err({\n                type: \"Tuple\",\n                value,\n                reason: { kind: \"InvalidLength\", expected: elements.length },\n            });\n        }\n        const result = [];\n        for (let i = 0; i < elements.length; i++) {\n            const elementResult = elements[i].fromUnknown(value[i]);\n            if (!elementResult.ok) {\n                return err({\n                    type: \"Tuple\",\n                    value,\n                    reason: {\n                        kind: \"Element\",\n                        index: i,\n                        error: elementResult.error,\n                    },\n                });\n            }\n            result[i] = elementResult.value;\n        }\n        return ok(result);\n    };\n    const fromParent = (value) => {\n        if (!Array.isArray(value) || value.length !== elements.length) {\n            return err({\n                type: \"Tuple\",\n                value,\n                reason: { kind: \"InvalidLength\", expected: elements.length },\n            });\n        }\n        const result = [];\n        for (let i = 0; i < elements.length; i++) {\n            const elementResult = elements[i].fromParent(value[i]);\n            if (!elementResult.ok) {\n                return err({\n                    type: \"Tuple\",\n                    value,\n                    reason: {\n                        kind: \"Element\",\n                        index: i,\n                        error: elementResult.error,\n                    },\n                });\n            }\n            result.push(elementResult.value);\n        }\n        return ok(result);\n    };\n    return {\n        ...createType(\"Tuple\", {\n            fromUnknown,\n            fromParent,\n        }),\n        elements,\n    };\n};\nexport const formatTupleError = (formatTypeError) => createTypeErrorFormatter((error) => {\n    switch (error.reason.kind) {\n        case \"InvalidLength\":\n            return `Expected a tuple of length ${error.reason.expected}, but received ${error.value}.`;\n        case \"Element\":\n            return `Invalid element at index ${error.reason.index}:\\n  ${formatTypeError(error.reason.error)}`;\n    }\n});\n/**\n * 64-bit signed integer.\n *\n * `Int64` represents a `BigInt` constrained to a 64-bit signed integer range,\n * which is useful for platforms that do not support the `bigint` type, such as\n * SQLite.\n *\n * Because SQLite lacks a dedicated `bigint` type, it may return `number` or\n * 'Int64` depending on the stored value or even a wrong value if a platform\n * wrapper does not support it. A workaround for SQLite is to insert 'Int64`\n * serialized as a string (SQLite will convert it to int) and manually cast the\n * result to a string in SQL query and then to `Int64` in JS.\n *\n * https://www.sqlite.org/c3ref/int64.html\n *\n * @category Number\n */\nexport const Int64 = brand(\"Int64\", BigInt, (value) => value >= -9223372036854775808n && value <= 9223372036854775807n\n    ? ok(value)\n    : err({ type: \"Int64\", value }));\nexport const formatInt64Error = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid 64-bit signed integer (Int64).`);\n/**\n * Stringified {@link Int64}.\n *\n * @category String\n */\nexport const Int64String = brand(\"Int64\", NonEmptyTrimmedString, (value) => trySync(() => {\n    const maybeInt = globalThis.BigInt(value);\n    Int64.orThrow(maybeInt);\n    return value;\n}, () => ({ type: \"Int64String\", value })));\nexport const formatInt64StringError = createTypeErrorFormatter((error) => `The value ${error.value} is not a valid Int64 string.`);\n/**\n * JSON-compatible value: string, {@link FiniteNumber}, boolean, null,\n * {@link JsonArray}, or {@link JsonObject}.\n *\n * @category Base Types\n */\nexport const JsonValue = recursive(() => union(String, FiniteNumber, Boolean, Null, JsonArray, JsonObject));\n/**\n * JSON-compatible array of {@link JsonValue} elements.\n *\n * @category Array\n */\nexport const JsonArray = array(JsonValue);\n/**\n * JSON-compatible object with string keys and {@link JsonValue} values.\n *\n * @category Object\n */\nexport const JsonObject = record(String, JsonValue);\nexport const parseJson = (value) => trySync(() => JSON.parse(value), (error) => ({\n    type: `Json`,\n    value,\n    message: globalThis.String(error),\n}));\n/**\n * JSON-string {@link Type}.\n *\n * ### Example\n *\n * ```ts\n * const result = Json.from('{\"key\":\"value\"}'); // ok\n * const error = Json.from(\"invalid json\"); // err\n * ```\n *\n * @category String\n */\nexport const Json = brand(\"Json\", String, (value) => {\n    const result = parseJson(value);\n    if (!result.ok)\n        return result;\n    return ok(value);\n});\nexport const formatJsonError = createTypeErrorFormatter((error) => `Invalid JSON: ${error.value}. Error: ${error.message}`);\nexport const jsonValueToJson = (value) => JSON.stringify(value);\nexport const jsonToJsonValue = (value) => JSON.parse(value);\n/**\n * Creates a branded JSON string {@link Type} and type-safe conversion functions\n * for a given Type.\n *\n * This factory creates:\n *\n * 1. A branded string Type that validates JSON parsing and structural conformity\n * 2. A serialization function (Type  branded JSON string)\n * 3. A parsing function (branded JSON string  Type, skipping validation)\n *\n * Optimized for Evolu's SQLite workflow where we store typed JSON strings and\n * need type-safe conversions without double parsing.\n *\n * ### Example\n *\n * ```ts\n * const Person = object({\n *   name: NonEmptyString100,\n *   age: FiniteNumber,\n * });\n * type Person = typeof Person.Type;\n *\n * const [PersonJson, personToPersonJson, personJsonToPerson] = json(\n *   Person,\n *   \"PersonJson\",\n * );\n * // string & Brand<\"PersonJson\">\n * type PersonJson = typeof PersonJson.Type;\n *\n * // Usage:\n * const person: Person = { name: \"Alice\", age: 30 };\n * const jsonString = personToPersonJson(person); // PersonJson\n * const backToPerson = personJsonToPerson(jsonString); // Person\n * ```\n */\nexport const json = (type, name) => {\n    const BrandedJsonType = brand(name, String, (value) => {\n        const parseResult = parseJson(value);\n        if (!parseResult.ok)\n            return parseResult;\n        const validationResult = type.fromUnknown(parseResult.value);\n        if (!validationResult.ok)\n            return validationResult;\n        return ok(value);\n    });\n    return [\n        BrandedJsonType,\n        jsonValueToJson,\n        jsonToJsonValue,\n    ];\n};\n/**\n * Optional {@link Type}.\n *\n * Marks a `Type` as **optional**, meaning:\n *\n * - If the value is **present**, it must match the given `Type`.\n * - If the value is **absent**, it is **not included** in the final object.\n *\n * This is different from {@link undefinedOr}, which allows explicit `undefined`\n * but **still requires the key to exist**.\n *\n * ### Example:\n *\n * ```ts\n * const Todo = object({\n *   id: TodoId,\n *   title: NonEmptyString1000,\n *   isCompleted: optional(SqliteBoolean),\n * });\n * ```\n */\nexport const optional = (type) => ({\n    ...createType(\"Optional\", {\n        fromUnknown: type.fromUnknown,\n        fromParent: type.fromParent,\n    }),\n    parent: type,\n});\n/** Determines if a given type is an {@link OptionalType}. */\nexport const isOptionalType = (x) => typeof x === \"object\" && x != null && \"name\" in x && x.name === \"Optional\";\n/**\n * Creates a partial object type where all properties are optional.\n *\n * This is useful when we want to validate an object in which none of the keys\n * are required, but if they are present they must conform to their\n * corresponding Types.\n *\n * ### Example\n *\n * ```ts\n * const PartialUser = partial({\n *   name: NonEmptyString,\n *   age: PositiveNumber,\n * });\n *\n * // Valid: an empty object is accepted\n * PartialUser.from({});\n *\n * // Valid: when provided, the properties must validate correctly\n * PartialUser.from({ name: \"Alice\" });\n *\n * // Invalid: if a property is present but fails validation it returns an error\n * PartialUser.from({ age: -5 });\n * ```\n *\n * @category Object\n */\nexport const partial = (props) => {\n    const optionalProps = {};\n    for (const key in props) {\n        if (Object.prototype.hasOwnProperty.call(props, key)) {\n            optionalProps[key] = optional(props[key]);\n        }\n    }\n    return object(optionalProps);\n};\n/**\n * Converts each nullable property (a union that includes {@link Null}) into an\n * {@link optional} property. This means consumers can omit the property\n * entirely, or set it to `null`, or set it to the non-null member of the\n * union.\n *\n * @category Object\n */\nexport const nullableToOptional = (props) => {\n    const transformedProps = {};\n    for (const key in props) {\n        const type = props[key];\n        if (isUnionType(type)) {\n            const hasNull = type.members.some((m) => m === Null);\n            if (hasNull) {\n                transformedProps[key] = optional(type);\n                continue;\n            }\n        }\n        transformedProps[key] = type;\n    }\n    return object(transformedProps);\n};\n/**\n * Create a new `object` {@link Type} by omitting some keys.\n *\n * @category Object\n */\nexport function omit(objectType, ...keys) {\n    const newProps = {};\n    for (const key in objectType.props) {\n        if (!keys.includes(key)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            newProps[key] = objectType.props[key];\n        }\n    }\n    return object(newProps);\n}\nexport const maxMutationSize = 655360;\n/**\n * Evolu has to limit the maximum mutation size. Otherwise, sync couldn't use\n * the `maxProtocolMessageRangesSize`. The max size is 640KB in bytes, measured\n * via MessagePack. Evolu Protocol DbChange will be smaller thanks to various\n * optimizations.\n */\nexport const validMutationSize = (type) => brand(\"ValidMutationSize\", type, (value) => pack(value).byteLength <= maxMutationSize\n    ? ok(value)\n    : err({ type: \"ValidMutationSize\", value }));\nexport const formatValidMutationSizeError = createTypeErrorFormatter((error) => `The mutation size exceeds the maximum limit of ${maxMutationSize} bytes. The provided mutation has a size of ${pack(error.value).byteLength} bytes.`);\n/**\n * Formats Evolu Type errors into user-friendly messages.\n *\n * Evolu Type typed errors ensure every error type must have a formatter.\n * TypeScript enforces this at compile-time, preventing unhandled validation\n * errors from reaching users.\n *\n * The `createFormatTypeError` function handles both built-in {@link TypeErrors}\n * and custom errors, and lets us override default formatting for specific\n * errors.\n *\n * ### Example\n *\n * ```ts\n * const formatTypeError = createFormatTypeError<\n *   MinLengthError | MaxLengthError\n * >((error): string => {\n *   switch (error.type) {\n *     case \"MinLength\":\n *       return `Text must be at least ${error.min} character${error.min === 1 ? \"\" : \"s\"} long`;\n *     case \"MaxLength\":\n *       return `Text is too long (maximum ${error.max} characters)`;\n *   }\n * });\n * ```\n *\n * Alternatively, write a custom formatter from scratch without using\n * `createFormatTypeError`. This gives us full control over error formatting:\n *\n * ```ts\n * const Person = object({\n *   name: NonEmptyTrimmedString100,\n *   age: optional(PositiveInt),\n * });\n *\n * // Define only the errors actually used by Person Type\n * type PersonErrors =\n *   | StringError\n *   | MaxLengthError\n *   | MinLengthError\n *   | TrimmedError\n *   | PositiveError\n *   | NonNegativeError\n *   | IntError\n *   | NumberError\n *   | ObjectError<Record<string, PersonErrors>>;\n *\n * const formatTypeError: TypeErrorFormatter<PersonErrors> = (error) => {\n *   switch (error.type) {\n *     case \"String\":\n *       return formatStringError(error);\n *     case \"Number\":\n *       return \"Must be a number\";\n *     case \"MinLength\":\n *       return `Must be at least ${error.min} characters`;\n *     case \"MaxLength\":\n *       return `Cannot exceed ${error.max} characters`;\n *     case \"Trimmed\":\n *       return \"Cannot have leading or trailing spaces\";\n *     case \"Positive\":\n *       return \"Must be a positive number\";\n *     case \"NonNegative\":\n *       return \"Must be zero or positive\";\n *     case \"Int\":\n *       return \"Must be an integer\";\n *     case \"Object\": {\n *       if (error.reason.kind === \"NotObject\") return \"Must be an object\";\n *       if (error.reason.kind === \"ExtraKeys\")\n *         return \"Contains unexpected fields\";\n *       const firstError = Object.values(error.reason.errors).find(\n *         (e) => e !== undefined,\n *       )!;\n *       return formatTypeError(firstError);\n *     }\n *   }\n * };\n * ```\n *\n * @category Utilities\n */\nexport const createFormatTypeError = (extraFormatter) => {\n    const formatTypeError = (error) => {\n        const extraMessage = extraFormatter?.(error);\n        if (extraMessage != null)\n            return extraMessage;\n        error = error;\n        switch (error.type) {\n            case \"String\":\n                return formatStringError(error);\n            case \"Number\":\n                return formatNumberError(error);\n            case \"BigInt\":\n                return formatBigIntError(error);\n            case \"Boolean\":\n                return formatBooleanError(error);\n            case \"Undefined\":\n                return formatUndefinedError(error);\n            case \"Null\":\n                return formatNullError(error);\n            case \"Function\":\n                return formatFunctionError(error);\n            case \"Uint8Array\":\n                return formatUint8ArrayError(error);\n            case \"InstanceOf\":\n                return formatInstanceOfError(error);\n            case \"EvoluType\":\n                return formatIsTypeError(error);\n            case \"CurrencyCode\":\n                return formatCurrencyCodeError(error);\n            case \"DateIso\":\n                return formatDateIsoError(error);\n            case \"Trimmed\":\n                return formatTrimmedError(error);\n            case \"MinLength\":\n                return formatMinLengthError(error);\n            case \"MaxLength\":\n                return formatMaxLengthError(error);\n            case \"Length\":\n                return formatLengthError(error);\n            case \"Mnemonic\":\n                return formatMnemonicError(error);\n            case \"Regex\":\n                return formatRegexError(error);\n            case \"Id\":\n                return formatIdError(error);\n            case \"TableId\":\n                return formatTableIdError(error);\n            case \"Positive\":\n                return formatPositiveError(error);\n            case \"Negative\":\n                return formatNegativeError(error);\n            case \"NonPositive\":\n                return formatNonPositiveError(error);\n            case \"NonNegative\":\n                return formatNonNegativeError(error);\n            case \"Int\":\n                return formatIntError(error);\n            case \"GreaterThan\":\n                return formatGreaterThanError(error);\n            case \"LessThan\":\n                return formatLessThanError(error);\n            case \"GreaterThanOrEqualTo\":\n                return formatGreaterThanOrEqualToError(error);\n            case \"LessThanOrEqualTo\":\n                return formatLessThanOrEqualToError(error);\n            case \"NonNaN\":\n                return formatNonNaNError(error);\n            case \"Finite\":\n                return formatFiniteError(error);\n            case \"MultipleOf\":\n                return formatMultipleOfError(error);\n            case \"Between\":\n                return formatBetweenError(error);\n            case \"Literal\":\n                return formatLiteralError(error);\n            case \"Int64\":\n                return formatInt64Error(error);\n            case \"Int64String\":\n                return formatInt64StringError(error);\n            case \"Json\":\n                return formatJsonError(error);\n            case \"ValidMutationSize\":\n                return formatValidMutationSizeError(error);\n            // Composite Types\n            case \"SimplePassword\":\n                return formatSimplePasswordError(formatTypeError)(error);\n            case \"Array\":\n                return formatArrayError(formatTypeError)(error);\n            case \"Set\":\n                return formatSetError(formatTypeError)(error);\n            case \"Record\":\n                return formatRecordError(formatTypeError)(error);\n            case \"Object\":\n                return formatObjectError(formatTypeError)(error);\n            case \"ObjectWithRecord\":\n                return formatObjectWithRecordError(formatTypeError)(error);\n            case \"Union\":\n                return formatUnionError(formatTypeError)(error);\n            case \"Tuple\":\n                return formatTupleError(formatTypeError)(error);\n            default: {\n                // Fallback for unknown error types\n                const unknownError = error;\n                return `A value ${safelyStringifyUnknownValue(unknownError.value)} is not valid for type ${unknownError.type}.`;\n            }\n        }\n    };\n    return formatTypeError;\n};\n/**\n * Converts an Evolu {@link TypeError} to Standard Schema V1 issues format.\n *\n * This function recursively converts Evolu's typed errors into the Standard\n * Schema issue format with proper path tracking for nested structures.\n *\n * @category Utilities\n */\nexport const typeErrorToStandardSchemaIssues = (error, formatTypeError, path = []) => {\n    if (error.type === \"Array\") {\n        const arrayError = error;\n        if (arrayError.reason.kind === \"NotArray\") {\n            return [{ message: formatTypeError(error), path }];\n        }\n        return typeErrorToStandardSchemaIssues(arrayError.reason.error, formatTypeError, [...path, arrayError.reason.index]);\n    }\n    if (error.type === \"Set\") {\n        const setError = error;\n        if (setError.reason.kind === \"NotSet\") {\n            return [{ message: formatTypeError(error), path }];\n        }\n        return typeErrorToStandardSchemaIssues(setError.reason.error, formatTypeError, [...path, setError.reason.index]);\n    }\n    if (error.type === \"Object\") {\n        const objectError = error;\n        if (objectError.reason.kind === \"NotObject\" ||\n            objectError.reason.kind === \"ExtraKeys\") {\n            return [{ message: formatTypeError(error), path }];\n        }\n        const issues = [];\n        for (const [key, propError] of Object.entries(objectError.reason.errors)) {\n            issues.push(...typeErrorToStandardSchemaIssues(propError, formatTypeError, [...path, key]));\n        }\n        return issues;\n    }\n    if (error.type === \"ObjectWithRecord\") {\n        const objectWithRecordError = error;\n        if (objectWithRecordError.reason.kind === \"NotObject\") {\n            return [{ message: formatTypeError(error), path }];\n        }\n        if (objectWithRecordError.reason.kind === \"IndexKey\" ||\n            objectWithRecordError.reason.kind === \"IndexValue\") {\n            return typeErrorToStandardSchemaIssues(objectWithRecordError.reason.error, formatTypeError, [...path, objectWithRecordError.reason.key]);\n        }\n        const issues = [];\n        for (const [key, propError] of Object.entries(objectWithRecordError.reason.errors)) {\n            issues.push(...typeErrorToStandardSchemaIssues(propError, formatTypeError, [...path, key]));\n        }\n        return issues;\n    }\n    if (error.type === \"Record\") {\n        const recordError = error;\n        if (recordError.reason.kind === \"NotRecord\") {\n            return [{ message: formatTypeError(error), path }];\n        }\n        return typeErrorToStandardSchemaIssues(recordError.reason.error, formatTypeError, [...path, recordError.reason.key]);\n    }\n    if (error.type === \"Tuple\") {\n        const tupleError = error;\n        if (tupleError.reason.kind === \"InvalidLength\") {\n            return [{ message: formatTypeError(error), path }];\n        }\n        return typeErrorToStandardSchemaIssues(tupleError.reason.error, formatTypeError, [...path, tupleError.reason.index]);\n    }\n    if (error.type === \"Union\") {\n        const unionError = error;\n        return unionError.errors.flatMap((err) => typeErrorToStandardSchemaIssues(err, formatTypeError, path));\n    }\n    if (error.type === \"Brand\") {\n        const brandError = error;\n        if (\"parentError\" in brandError) {\n            return typeErrorToStandardSchemaIssues(brandError.parentError, formatTypeError, path);\n        }\n        return [{ message: formatTypeError(error), path }];\n    }\n    return [{ message: formatTypeError(error), path }];\n};\n/**\n * Shared formatter cache for Standard Schema integration - avoids circular\n * dependency by lazily creating the formatter on first use rather than during\n * module initialization.\n */\nlet cachedStandardSchemaFormatTypeError;\n", "import { NonNegativeInt } from \"./Type.js\";\nexport { bytesToHex, bytesToUtf8, concatBytes, hexToBytes, utf8ToBytes, } from \"@noble/ciphers/utils.js\";\n/**\n * Custom error for {@link Buffer}-related failures like premature end of data.\n * Provides better stack traces for debugging binary protocol issues.\n */\nexport class BufferError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\n/** Creates a {@link Buffer} for efficient byte operations. */\nexport const createBuffer = (arrayLike) => {\n    let value = arrayLike\n        ? new globalThis.Uint8Array(arrayLike)\n        : new globalThis.Uint8Array(512);\n    let length = NonNegativeInt.orThrow(arrayLike ? arrayLike.length : 0);\n    const buffer = {\n        getCapacity: () => NonNegativeInt.orThrow(value.length),\n        getLength: () => length,\n        extend: (arg) => {\n            const targetSize = length + arg.length;\n            if (value.length < targetSize) {\n                const oldValue = value;\n                const newCapacity = Math.max(value.length * 2, targetSize);\n                value = new globalThis.Uint8Array(newCapacity);\n                value.set(oldValue);\n            }\n            value.set(arg, length);\n            length = NonNegativeInt.orThrow(length + arg.length);\n        },\n        shift: () => {\n            if (length === 0) {\n                throw new BufferError(\"Buffer parse ended prematurely\");\n            }\n            const first = value[0];\n            value = value.subarray(1);\n            length--;\n            return NonNegativeInt.orThrow(first);\n        },\n        shiftN: (n) => {\n            if (length < n) {\n                throw new BufferError(\"Buffer parse ended prematurely\");\n            }\n            const subarray = value.subarray(0, n);\n            value = value.subarray(n);\n            length = NonNegativeInt.orThrow(length - n);\n            return subarray;\n        },\n        truncate: (newLength) => {\n            if (newLength > length) {\n                throw new BufferError(\"Cannot truncate to a length greater than current\");\n            }\n            length = newLength;\n        },\n        reset: () => {\n            length = NonNegativeInt.orThrow(0);\n        },\n        unwrap: () => value.subarray(0, length),\n    };\n    return buffer;\n};\n", "/**\n * Creates an LRU (least recently used) cache with a maximum capacity.\n *\n * When the cache reaches capacity, the least recently used entry is evicted.\n * Both `get` and `set` operations update the access order.\n *\n * ### Example\n *\n * ```ts\n * const cache = createLruCache<string, number>(2);\n * cache.set(\"a\", 1);\n * cache.set(\"b\", 2);\n * cache.set(\"c\", 3); // Evicts \"a\"\n * cache.has(\"a\"); // false\n * ```\n */\nexport const createLruCache = (capacity) => {\n    const internalMap = new Map();\n    return {\n        has: (key) => internalMap.has(key),\n        get: (key) => {\n            const value = internalMap.get(key);\n            if (value === undefined)\n                return undefined;\n            // Move to end (most recently used)\n            internalMap.delete(key);\n            internalMap.set(key, value);\n            return value;\n        },\n        set: (key, val) => {\n            // If key exists, delete it first to update order\n            if (internalMap.has(key)) {\n                internalMap.delete(key);\n            }\n            else if (internalMap.size === capacity) {\n                // Evict least recently used (first entry)\n                const firstKey = internalMap.keys().next().value;\n                internalMap.delete(firstKey);\n            }\n            internalMap.set(key, val);\n        },\n        delete: (key) => {\n            internalMap.delete(key);\n        },\n        map: internalMap,\n    };\n};\n", "import { createId } from \"./Type.js\";\n/** Creates a {@link Callbacks} registry for managing callbacks. */\nexport const createCallbacks = (deps) => {\n    const callbackMap = new Map();\n    return {\n        register: (callback) => {\n            const id = createId(deps);\n            callbackMap.set(id, callback);\n            return id;\n        },\n        execute: (id, ...args) => {\n            const callback = callbackMap.get(id);\n            if (!callback)\n                return;\n            callbackMap.delete(id);\n            if (args.length === 0) {\n                // Called without argument (undefined case)\n                callback();\n            }\n            else {\n                callback(args[0]);\n            }\n        },\n    };\n};\n", "/** Creates a {@link Console} for logging with configurable output. */\nexport const createConsole = (config = {}) => {\n    const instance = {\n        enabled: config.enableLogging ?? false,\n        log: (...args) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.log(...args);\n        },\n        info: (...args) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.info(...args);\n        },\n        warn: (...args) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.warn(...args);\n        },\n        error: (...args) => {\n            // Always log errors, even if disabled\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            console.error(...args);\n        },\n        debug: (...args) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.debug(...args);\n        },\n        time: (label) => {\n            // eslint-disable-next-line no-console\n            if (instance.enabled)\n                console.time(label);\n        },\n        timeLog: (label, ...data) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.timeLog(label, ...data);\n        },\n        timeEnd: (label) => {\n            // eslint-disable-next-line no-console\n            if (instance.enabled)\n                console.timeEnd(label);\n        },\n        dir: (object, options) => {\n            // eslint-disable-next-line no-console\n            if (instance.enabled)\n                console.dir(object, options);\n        },\n        table: (tabularData, properties) => {\n            // eslint-disable-next-line no-console\n            if (instance.enabled)\n                console.table(tabularData, properties);\n        },\n        count: (label) => {\n            // eslint-disable-next-line no-console\n            if (instance.enabled)\n                console.count(label);\n        },\n        countReset: (label) => {\n            // eslint-disable-next-line no-console\n            if (instance.enabled)\n                console.countReset(label);\n        },\n        assert: (value, message, ...optionalParams) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.assert(value, message, ...optionalParams);\n        },\n        trace: (message, ...optionalParams) => {\n            // eslint-disable-next-line no-console, @typescript-eslint/no-unsafe-argument\n            if (instance.enabled)\n                console.trace(message, ...optionalParams);\n        },\n    };\n    return instance;\n};\n/** Creates a console instance with timestamp prefixes. */\nexport const createConsoleWithTime = (config = { timestampType: \"relative\" }) => {\n    const console = createConsole(config);\n    const startTime = performance.now();\n    const getTimestamp = () => {\n        if (config.timestampType === \"relative\") {\n            const elapsed = (performance.now() - startTime) / 1000;\n            // Format for better readability at different time scales\n            if (elapsed < 60) {\n                // Under 1 minute: show seconds with millisecond precision\n                return `+${elapsed.toFixed(3)}s`;\n            }\n            else if (elapsed < 3600) {\n                // 1 minute to 1 hour: show minutes and seconds with millisecond precision\n                const minutes = Math.floor(elapsed / 60);\n                const seconds = (elapsed % 60).toFixed(3);\n                return `+${minutes}m${seconds}s`;\n            }\n            else {\n                // Over 1 hour: show hours, minutes, and seconds with millisecond precision\n                const hours = Math.floor(elapsed / 3600);\n                const minutes = Math.floor((elapsed % 3600) / 60);\n                const seconds = ((elapsed % 3600) % 60).toFixed(3);\n                return `+${hours}h${minutes}m${seconds}s`;\n            }\n        }\n        else {\n            // Absolute time - format as HH:MM:SS.mmm\n            const now = new Date();\n            const hours = now.getHours().toString().padStart(2, \"0\");\n            const minutes = now.getMinutes().toString().padStart(2, \"0\");\n            const seconds = now.getSeconds().toString().padStart(2, \"0\");\n            const milliseconds = now.getMilliseconds().toString().padStart(3, \"0\");\n            return `${hours}:${minutes}:${seconds}.${milliseconds}`;\n        }\n    };\n    const withTimestamp = (fn) => (...args) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        fn(`[${getTimestamp()}]`, ...args);\n    };\n    // Override methods that should have timestamps\n    console.log = withTimestamp(console.log);\n    console.info = withTimestamp(console.info);\n    console.warn = withTimestamp(console.warn);\n    console.error = withTimestamp(console.error);\n    console.debug = withTimestamp(console.debug);\n    console.trace = withTimestamp(console.trace);\n    return console;\n};\n", "/**\n * Basic utils for ARX (add-rotate-xor) salsa and chacha ciphers.\n\nRFC8439 requires multi-step cipher stream, where\nauthKey starts with counter: 0, actual msg with counter: 1.\n\nFor this, we need a way to re-use nonce / counter:\n\n    const counter = new Uint8Array(4);\n    chacha(..., counter, ...); // counter is now 1\n    chacha(..., counter, ...); // counter is now 2\n\nThis is complicated:\n\n- 32-bit counters are enough, no need for 64-bit: max ArrayBuffer size in JS is 4GB\n- Original papers don't allow mutating counters\n- Counter overflow is undefined [^1]\n- Idea A: allow providing (nonce | counter) instead of just nonce, re-use it\n- Caveat: Cannot be re-used through all cases:\n- * chacha has (counter | nonce)\n- * xchacha has (nonce16 | counter | nonce16)\n- Idea B: separate nonce / counter and provide separate API for counter re-use\n- Caveat: there are different counter sizes depending on an algorithm.\n- salsa & chacha also differ in structures of key & sigma:\n  salsa20:      s[0] | k(4) | s[1] | nonce(2) | cnt(2) | s[2] | k(4) | s[3]\n  chacha:       s(4) | k(8) | cnt(1) | nonce(3)\n  chacha20orig: s(4) | k(8) | cnt(2) | nonce(2)\n- Idea C: helper method such as `setSalsaState(key, nonce, sigma, data)`\n- Caveat: we can't re-use counter array\n\nxchacha [^2] uses the subkey and remaining 8 byte nonce with ChaCha20 as normal\n(prefixed by 4 NUL bytes, since [RFC8439] specifies a 12-byte nonce).\n\n[^1]: https://mailarchive.ietf.org/arch/msg/cfrg/gsOnTJzcbgG6OqD8Sc0GO5aR_tU/\n[^2]: https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha#appendix-A.2\n\n * @module\n */\nimport {\n  type PRG,\n  type XorStream,\n  abool,\n  abytes,\n  anumber,\n  checkOpts,\n  clean,\n  copyBytes,\n  randomBytes,\n  u32,\n} from './utils.ts';\n\n// Replaces `TextEncoder`, which is not available in all environments\nconst encodeStr = (str: string) => Uint8Array.from(str.split(''), (c) => c.charCodeAt(0));\nconst sigma16 = encodeStr('expand 16-byte k');\nconst sigma32 = encodeStr('expand 32-byte k');\nconst sigma16_32 = u32(sigma16);\nconst sigma32_32 = u32(sigma32);\n\n/** Rotate left. */\nexport function rotl(a: number, b: number): number {\n  return (a << b) | (a >>> (32 - b));\n}\n\n/** Ciphers must use u32 for efficiency. */\nexport type CipherCoreFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  output: Uint32Array,\n  counter: number,\n  rounds?: number\n) => void;\n\n/** Method which extends key + short nonce into larger nonce / diff key. */\nexport type ExtendNonceFn = (\n  sigma: Uint32Array,\n  key: Uint32Array,\n  input: Uint32Array,\n  output: Uint32Array\n) => void;\n\n/** ARX cipher options.\n * * `allowShortKeys` for 16-byte keys\n * * `counterLength` in bytes\n * * `counterRight`: right: `nonce|counter`; left: `counter|nonce`\n * */\nexport type CipherOpts = {\n  allowShortKeys?: boolean; // Original salsa / chacha allow 16-byte keys\n  extendNonceFn?: ExtendNonceFn;\n  counterLength?: number;\n  counterRight?: boolean;\n  rounds?: number;\n};\n\n// Is byte array aligned to 4 byte offset (u32)?\nfunction isAligned32(b: Uint8Array) {\n  return b.byteOffset % 4 === 0;\n}\n\n// Salsa and Chacha block length is always 512-bit\nconst BLOCK_LEN = 64;\nconst BLOCK_LEN32 = 16;\n\n// new Uint32Array([2**32])   // => Uint32Array(1) [ 0 ]\n// new Uint32Array([2**32-1]) // => Uint32Array(1) [ 4294967295 ]\nconst MAX_COUNTER = 2 ** 32 - 1;\n\nconst U32_EMPTY = Uint32Array.of();\nfunction runCipher(\n  core: CipherCoreFn,\n  sigma: Uint32Array,\n  key: Uint32Array,\n  nonce: Uint32Array,\n  data: Uint8Array,\n  output: Uint8Array,\n  counter: number,\n  rounds: number\n): void {\n  const len = data.length;\n  const block = new Uint8Array(BLOCK_LEN);\n  const b32 = u32(block);\n  // Make sure that buffers aligned to 4 bytes\n  const isAligned = isAligned32(data) && isAligned32(output);\n  const d32 = isAligned ? u32(data) : U32_EMPTY;\n  const o32 = isAligned ? u32(output) : U32_EMPTY;\n  for (let pos = 0; pos < len; counter++) {\n    core(sigma, key, nonce, b32, counter, rounds);\n    if (counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    const take = Math.min(BLOCK_LEN, len - pos);\n    // aligned to 4 bytes\n    if (isAligned && take === BLOCK_LEN) {\n      const pos32 = pos / 4;\n      if (pos % 4 !== 0) throw new Error('arx: invalid block position');\n      for (let j = 0, posj: number; j < BLOCK_LEN32; j++) {\n        posj = pos32 + j;\n        o32[posj] = d32[posj] ^ b32[j];\n      }\n      pos += BLOCK_LEN;\n      continue;\n    }\n    for (let j = 0, posj; j < take; j++) {\n      posj = pos + j;\n      output[posj] = data[posj] ^ block[j];\n    }\n    pos += take;\n  }\n}\n\n/** Creates ARX-like (ChaCha, Salsa) cipher stream from core function. */\nexport function createCipher(core: CipherCoreFn, opts: CipherOpts): XorStream {\n  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts(\n    { allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 },\n    opts\n  );\n  if (typeof core !== 'function') throw new Error('core must be a function');\n  anumber(counterLength);\n  anumber(rounds);\n  abool(counterRight);\n  abool(allowShortKeys);\n  return (\n    key: Uint8Array,\n    nonce: Uint8Array,\n    data: Uint8Array,\n    output?: Uint8Array,\n    counter = 0\n  ): Uint8Array => {\n    abytes(key, undefined, 'key');\n    abytes(nonce, undefined, 'nonce');\n    abytes(data, undefined, 'data');\n    const len = data.length;\n    if (output === undefined) output = new Uint8Array(len);\n    abytes(output, undefined, 'output');\n    anumber(counter);\n    if (counter < 0 || counter >= MAX_COUNTER) throw new Error('arx: counter overflow');\n    if (output.length < len)\n      throw new Error(`arx: output (${output.length}) is shorter than data (${len})`);\n    const toClean = [];\n\n    // Key & sigma\n    // key=16 -> sigma16, k=key|key\n    // key=32 -> sigma32, k=key\n    let l = key.length;\n    let k: Uint8Array;\n    let sigma: Uint32Array;\n    if (l === 32) {\n      toClean.push((k = copyBytes(key)));\n      sigma = sigma32_32;\n    } else if (l === 16 && allowShortKeys) {\n      k = new Uint8Array(32);\n      k.set(key);\n      k.set(key, 16);\n      sigma = sigma16_32;\n      toClean.push(k);\n    } else {\n      abytes(key, 32, 'arx key');\n      throw new Error('invalid key size');\n      // throw new Error(`\"arx key\" expected Uint8Array of length 32, got length=${l}`);\n    }\n\n    // Nonce\n    // salsa20:      8   (8-byte counter)\n    // chacha20orig: 8   (8-byte counter)\n    // chacha20:     12  (4-byte counter)\n    // xsalsa20:     24  (16 -> hsalsa,  8 -> old nonce)\n    // xchacha20:    24  (16 -> hchacha, 8 -> old nonce)\n    // Align nonce to 4 bytes\n    if (!isAligned32(nonce)) toClean.push((nonce = copyBytes(nonce)));\n\n    const k32 = u32(k);\n    // hsalsa & hchacha: handle extended nonce\n    if (extendNonceFn) {\n      if (nonce.length !== 24) throw new Error(`arx: extended nonce must be 24 bytes`);\n      extendNonceFn(sigma, k32, u32(nonce.subarray(0, 16)), k32);\n      nonce = nonce.subarray(16);\n    }\n\n    // Handle nonce counter\n    const nonceNcLen = 16 - counterLength;\n    if (nonceNcLen !== nonce.length)\n      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);\n\n    // Pad counter when nonce is 64 bit\n    if (nonceNcLen !== 12) {\n      const nc = new Uint8Array(12);\n      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);\n      nonce = nc;\n      toClean.push(nonce);\n    }\n    const n32 = u32(nonce);\n    runCipher(core, sigma, k32, n32, data, output, counter, rounds);\n    clean(...toClean);\n    return output;\n  };\n}\n\n/** Internal class which wraps chacha20 or chacha8 to create CSPRNG. */\nexport class _XorStreamPRG implements PRG {\n  readonly blockLen: number;\n  readonly keyLen: number;\n  readonly nonceLen: number;\n  private state: Uint8Array;\n  private buf: Uint8Array;\n  private key: Uint8Array;\n  private nonce: Uint8Array;\n  private pos: number;\n  private ctr: number;\n  private cipher: XorStream;\n  constructor(\n    cipher: XorStream,\n    blockLen: number,\n    keyLen: number,\n    nonceLen: number,\n    seed: Uint8Array\n  ) {\n    this.cipher = cipher;\n    this.blockLen = blockLen;\n    this.keyLen = keyLen;\n    this.nonceLen = nonceLen;\n    this.state = new Uint8Array(this.keyLen + this.nonceLen);\n    this.reseed(seed);\n    this.ctr = 0;\n    this.pos = this.blockLen;\n    this.buf = new Uint8Array(this.blockLen);\n    this.key = this.state.subarray(0, this.keyLen);\n    this.nonce = this.state.subarray(this.keyLen);\n  }\n  private reseed(seed: Uint8Array) {\n    abytes(seed);\n    if (!seed || seed.length === 0) throw new Error('entropy required');\n    for (let i = 0; i < seed.length; i++) this.state[i % this.state.length] ^= seed[i];\n    this.ctr = 0;\n    this.pos = this.blockLen;\n  }\n  addEntropy(seed: Uint8Array): void {\n    this.state.set(this.randomBytes(this.state.length));\n    this.reseed(seed);\n  }\n  randomBytes(len: number): Uint8Array {\n    anumber(len);\n    if (len === 0) return new Uint8Array(0);\n    const out = new Uint8Array(len);\n    let outPos = 0;\n    // Leftovers\n    if (this.pos < this.blockLen) {\n      const take = Math.min(len, this.blockLen - this.pos);\n      out.set(this.buf.subarray(this.pos, this.pos + take), 0);\n      this.pos += take;\n      outPos += take;\n      if (outPos === len) return out; // fast path\n    }\n    // Full blocks directly to out\n    const blocks = Math.floor((len - outPos) / this.blockLen);\n    if (blocks > 0) {\n      const blockBytes = blocks * this.blockLen;\n      const b = out.subarray(outPos, outPos + blockBytes);\n      this.cipher(this.key, this.nonce, b, b, this.ctr);\n      this.ctr += blocks;\n      outPos += blockBytes;\n    }\n    // Save leftovers\n    const left = len - outPos;\n    if (left > 0) {\n      this.buf.fill(0);\n      // NOTE: cipher will handle overflow\n      this.cipher(this.key, this.nonce, this.buf, this.buf, this.ctr++);\n      out.set(this.buf.subarray(0, left), outPos);\n      this.pos = left;\n    }\n    return out;\n  }\n  clone(): _XorStreamPRG {\n    return new _XorStreamPRG(\n      this.cipher,\n      this.blockLen,\n      this.keyLen,\n      this.nonceLen,\n      this.randomBytes(this.state.length)\n    );\n  }\n  clean(): void {\n    this.pos = 0;\n    this.ctr = 0;\n    this.buf.fill(0);\n    this.state.fill(0);\n  }\n}\n\nexport type XorPRG = (seed?: Uint8Array) => _XorStreamPRG;\n\nexport const createPRG = (\n  cipher: XorStream,\n  blockLen: number,\n  keyLen: number,\n  nonceLen: number\n): XorPRG => {\n  return (seed: Uint8Array = randomBytes(32)): _XorStreamPRG =>\n    new _XorStreamPRG(cipher, blockLen, keyLen, nonceLen, seed);\n};\n", "/**\n * Poly1305 ([PDF](https://cr.yp.to/mac/poly1305-20050329.pdf),\n * [wiki](https://en.wikipedia.org/wiki/Poly1305))\n * is a fast and parallel secret-key message-authentication code suitable for\n * a wide variety of applications. It was standardized in\n * [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and is now used in TLS 1.3.\n *\n * Polynomial MACs are not perfect for every situation:\n * they lack Random Key Robustness: the MAC can be forged, and can't be used in PAKE schemes.\n * See [invisible salamanders attack](https://keymaterial.net/2020/09/07/invisible-salamanders-in-aes-gcm-siv/).\n * To combat invisible salamanders, `hash(key)` can be included in ciphertext,\n * however, this would violate ciphertext indistinguishability:\n * an attacker would know which key was used - so `HKDF(key, i)`\n * could be used instead.\n *\n * Check out [original website](https://cr.yp.to/mac.html).\n * Based on Public Domain [poly1305-donna](https://github.com/floodyberry/poly1305-donna).\n * @module\n */\n// prettier-ignore\nimport {\n  abytes, aexists, aoutput, bytesToHex,\n  clean, concatBytes, copyBytes, hexToNumber, numberToBytesBE,\n  type IHash2\n} from './utils.ts';\n\nfunction u8to16(a: Uint8Array, i: number) {\n  return (a[i++] & 0xff) | ((a[i++] & 0xff) << 8);\n}\n\nfunction bytesToNumberLE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\n/** Small version of `poly1305` without loop unrolling. Unused, provided for auditability. */\nfunction poly1305_small(msg: Uint8Array, key: Uint8Array): Uint8Array {\n  abytes(msg);\n  abytes(key, 32, 'key');\n  const POW_2_130_5 = BigInt(2) ** BigInt(130) - BigInt(5); // 2^130-5\n  const POW_2_128_1 = BigInt(2) ** BigInt(128) - BigInt(1); // 2^128-1\n  const CLAMP_R = BigInt('0x0ffffffc0ffffffc0ffffffc0fffffff');\n  const r = bytesToNumberLE(key.subarray(0, 16)) & CLAMP_R;\n  const s = bytesToNumberLE(key.subarray(16));\n  // Process by 16 byte chunks\n  let acc = BigInt(0);\n  for (let i = 0; i < msg.length; i += 16) {\n    const m = msg.subarray(i, i + 16);\n    const n = bytesToNumberLE(m) | (BigInt(1) << BigInt(8 * m.length));\n    acc = ((acc + n) * r) % POW_2_130_5;\n  }\n  const res = (acc + s) & POW_2_128_1;\n  return numberToBytesBE(res, 16).reverse(); // LE\n}\n\n// Can be used to replace `computeTag` in chacha.ts. Unused, provided for auditability.\n// @ts-expect-error\nfunction poly1305_computeTag_small(\n  authKey: Uint8Array,\n  lengths: Uint8Array,\n  ciphertext: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  const res = [];\n  const updatePadded2 = (msg: Uint8Array) => {\n    res.push(msg);\n    const leftover = msg.length % 16;\n    if (leftover) res.push(new Uint8Array(16).slice(leftover));\n  };\n  if (AAD) updatePadded2(AAD);\n  updatePadded2(ciphertext);\n  res.push(lengths);\n  return poly1305_small(concatBytes(...res), authKey);\n}\n\n/** Poly1305 class. Prefer poly1305() function instead. */\nexport class Poly1305 implements IHash2 {\n  readonly blockLen = 16;\n  readonly outputLen = 16;\n  private buffer = new Uint8Array(16);\n  private r = new Uint16Array(10); // Allocating 1 array with .subarray() here is slower than 3\n  private h = new Uint16Array(10);\n  private pad = new Uint16Array(8);\n  private pos = 0;\n  protected finished = false;\n\n  // Can be speed-up using BigUint64Array, at the cost of complexity\n  constructor(key: Uint8Array) {\n    key = copyBytes(abytes(key, 32, 'key'));\n    const t0 = u8to16(key, 0);\n    const t1 = u8to16(key, 2);\n    const t2 = u8to16(key, 4);\n    const t3 = u8to16(key, 6);\n    const t4 = u8to16(key, 8);\n    const t5 = u8to16(key, 10);\n    const t6 = u8to16(key, 12);\n    const t7 = u8to16(key, 14);\n\n    // https://github.com/floodyberry/poly1305-donna/blob/e6ad6e091d30d7f4ec2d4f978be1fcfcbce72781/poly1305-donna-16.h#L47\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;\n    this.r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;\n    this.r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;\n    this.r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;\n    this.r[5] = (t4 >>> 1) & 0x1ffe;\n    this.r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;\n    this.r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;\n    this.r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;\n    this.r[9] = (t7 >>> 5) & 0x007f;\n    for (let i = 0; i < 8; i++) this.pad[i] = u8to16(key, 16 + 2 * i);\n  }\n\n  private process(data: Uint8Array, offset: number, isLast = false) {\n    const hibit = isLast ? 0 : 1 << 11;\n    const { h, r } = this;\n    const r0 = r[0];\n    const r1 = r[1];\n    const r2 = r[2];\n    const r3 = r[3];\n    const r4 = r[4];\n    const r5 = r[5];\n    const r6 = r[6];\n    const r7 = r[7];\n    const r8 = r[8];\n    const r9 = r[9];\n\n    const t0 = u8to16(data, offset + 0);\n    const t1 = u8to16(data, offset + 2);\n    const t2 = u8to16(data, offset + 4);\n    const t3 = u8to16(data, offset + 6);\n    const t4 = u8to16(data, offset + 8);\n    const t5 = u8to16(data, offset + 10);\n    const t6 = u8to16(data, offset + 12);\n    const t7 = u8to16(data, offset + 14);\n\n    let h0 = h[0] + (t0 & 0x1fff);\n    let h1 = h[1] + (((t0 >>> 13) | (t1 << 3)) & 0x1fff);\n    let h2 = h[2] + (((t1 >>> 10) | (t2 << 6)) & 0x1fff);\n    let h3 = h[3] + (((t2 >>> 7) | (t3 << 9)) & 0x1fff);\n    let h4 = h[4] + (((t3 >>> 4) | (t4 << 12)) & 0x1fff);\n    let h5 = h[5] + ((t4 >>> 1) & 0x1fff);\n    let h6 = h[6] + (((t4 >>> 14) | (t5 << 2)) & 0x1fff);\n    let h7 = h[7] + (((t5 >>> 11) | (t6 << 5)) & 0x1fff);\n    let h8 = h[8] + (((t6 >>> 8) | (t7 << 8)) & 0x1fff);\n    let h9 = h[9] + ((t7 >>> 5) | hibit);\n\n    let c = 0;\n\n    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);\n    c = d0 >>> 13;\n    d0 &= 0x1fff;\n    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);\n    c += d0 >>> 13;\n    d0 &= 0x1fff;\n\n    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);\n    c = d1 >>> 13;\n    d1 &= 0x1fff;\n    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);\n    c += d1 >>> 13;\n    d1 &= 0x1fff;\n\n    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);\n    c = d2 >>> 13;\n    d2 &= 0x1fff;\n    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);\n    c += d2 >>> 13;\n    d2 &= 0x1fff;\n\n    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);\n    c = d3 >>> 13;\n    d3 &= 0x1fff;\n    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);\n    c += d3 >>> 13;\n    d3 &= 0x1fff;\n\n    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;\n    c = d4 >>> 13;\n    d4 &= 0x1fff;\n    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);\n    c += d4 >>> 13;\n    d4 &= 0x1fff;\n\n    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;\n    c = d5 >>> 13;\n    d5 &= 0x1fff;\n    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);\n    c += d5 >>> 13;\n    d5 &= 0x1fff;\n\n    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;\n    c = d6 >>> 13;\n    d6 &= 0x1fff;\n    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);\n    c += d6 >>> 13;\n    d6 &= 0x1fff;\n\n    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;\n    c = d7 >>> 13;\n    d7 &= 0x1fff;\n    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);\n    c += d7 >>> 13;\n    d7 &= 0x1fff;\n\n    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;\n    c = d8 >>> 13;\n    d8 &= 0x1fff;\n    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);\n    c += d8 >>> 13;\n    d8 &= 0x1fff;\n\n    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;\n    c = d9 >>> 13;\n    d9 &= 0x1fff;\n    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;\n    c += d9 >>> 13;\n    d9 &= 0x1fff;\n\n    c = ((c << 2) + c) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = c >>> 13;\n    d1 += c;\n\n    h[0] = d0;\n    h[1] = d1;\n    h[2] = d2;\n    h[3] = d3;\n    h[4] = d4;\n    h[5] = d5;\n    h[6] = d6;\n    h[7] = d7;\n    h[8] = d8;\n    h[9] = d9;\n  }\n\n  private finalize() {\n    const { h, pad } = this;\n    const g = new Uint16Array(10);\n    let c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    for (let i = 2; i < 10; i++) {\n      h[i] += c;\n      c = h[i] >>> 13;\n      h[i] &= 0x1fff;\n    }\n    h[0] += c * 5;\n    c = h[0] >>> 13;\n    h[0] &= 0x1fff;\n    h[1] += c;\n    c = h[1] >>> 13;\n    h[1] &= 0x1fff;\n    h[2] += c;\n\n    g[0] = h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n    for (let i = 1; i < 10; i++) {\n      g[i] = h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    }\n    g[9] -= 1 << 13;\n\n    let mask = (c ^ 1) - 1;\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n    mask = ~mask;\n    for (let i = 0; i < 10; i++) h[i] = (h[i] & mask) | g[i];\n    h[0] = (h[0] | (h[1] << 13)) & 0xffff;\n    h[1] = ((h[1] >>> 3) | (h[2] << 10)) & 0xffff;\n    h[2] = ((h[2] >>> 6) | (h[3] << 7)) & 0xffff;\n    h[3] = ((h[3] >>> 9) | (h[4] << 4)) & 0xffff;\n    h[4] = ((h[4] >>> 12) | (h[5] << 1) | (h[6] << 14)) & 0xffff;\n    h[5] = ((h[6] >>> 2) | (h[7] << 11)) & 0xffff;\n    h[6] = ((h[7] >>> 5) | (h[8] << 8)) & 0xffff;\n    h[7] = ((h[8] >>> 8) | (h[9] << 5)) & 0xffff;\n\n    let f = h[0] + pad[0];\n    h[0] = f & 0xffff;\n    for (let i = 1; i < 8; i++) {\n      f = (((h[i] + pad[i]) | 0) + (f >>> 16)) | 0;\n      h[i] = f & 0xffff;\n    }\n    clean(g);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    data = copyBytes(data);\n    const { buffer, blockLen } = this;\n    const len = data.length;\n\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input\n      if (take === blockLen) {\n        for (; blockLen <= len - pos; pos += blockLen) this.process(data, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(buffer, 0, false);\n        this.pos = 0;\n      }\n    }\n    return this;\n  }\n  destroy(): void {\n    clean(this.h, this.r, this.buffer, this.pad);\n  }\n  digestInto(out: Uint8Array): Uint8Array {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    const { buffer, h } = this;\n    let { pos } = this;\n    if (pos) {\n      buffer[pos++] = 1;\n      for (; pos < 16; pos++) buffer[pos] = 0;\n      this.process(buffer, 0, true);\n    }\n    this.finalize();\n    let opos = 0;\n    for (let i = 0; i < 8; i++) {\n      out[opos++] = h[i] >>> 0;\n      out[opos++] = h[i] >>> 8;\n    }\n    return out;\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n}\n\nexport type CHash = ReturnType<typeof wrapConstructorWithKey>;\nexport function wrapConstructorWithKey<H extends IHash2>(\n  hashCons: (key: Uint8Array) => H\n): {\n  (msg: Uint8Array, key: Uint8Array): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(key: Uint8Array): H;\n} {\n  const hashC = (msg: Uint8Array, key: Uint8Array): Uint8Array =>\n    hashCons(key).update(msg).digest();\n  const tmp = hashCons(new Uint8Array(32)); // tmp array, used just once below\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (key: Uint8Array) => hashCons(key);\n  return hashC;\n}\n\n/** Poly1305 MAC from RFC 8439. */\nexport const poly1305: CHash = /** @__PURE__ */ (() =>\n  wrapConstructorWithKey((key) => new Poly1305(key)))();\n", "/**\n * ChaCha stream cipher, released\n * in 2008. Developed after Salsa20, ChaCha aims to increase diffusion per round.\n * It was standardized in [RFC 8439](https://www.rfc-editor.org/rfc/rfc8439) and\n * is now used in TLS 1.3.\n *\n * [XChaCha20](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha)\n * extended-nonce variant is also provided. Similar to XSalsa, it's safe to use with\n * randomly-generated nonces.\n *\n * Check out [PDF](http://cr.yp.to/chacha/chacha-20080128.pdf) and\n * [wiki](https://en.wikipedia.org/wiki/Salsa20) and\n * [website](https://cr.yp.to/chacha.html).\n *\n * @module\n */\nimport { type XorPRG, createCipher, createPRG, rotl } from './_arx.ts';\nimport { poly1305 } from './_poly1305.ts';\nimport {\n  type ARXCipher,\n  type CipherWithOutput,\n  type XorStream,\n  abytes,\n  clean,\n  equalBytes,\n  getOutput,\n  u64Lengths,\n  wrapCipher,\n} from './utils.ts';\n\n/**\n * ChaCha core function. It is implemented twice:\n * 1. Simple loop (chachaCore_small, hchacha_small)\n * 2. Unrolled loop (chachaCore, hchacha) - 4x faster, but larger & harder to read\n * The specific implementation is selected in `createCipher` below.\n */\n\n/** quarter-round */\n// prettier-ignore\nfunction chachaQR(x: Uint32Array, a: number, b: number, c: number, d: number) {\n  x[a] = (x[a] + x[b]) | 0; x[d] = rotl(x[d] ^ x[a], 16);\n  x[c] = (x[c] + x[d]) | 0; x[b] = rotl(x[b] ^ x[c], 12);\n  x[a] = (x[a] + x[b]) | 0; x[d] = rotl(x[d] ^ x[a], 8);\n  x[c] = (x[c] + x[d]) | 0; x[b] = rotl(x[b] ^ x[c], 7);\n}\n\n/** single round */\nfunction chachaRound(x: Uint32Array, rounds = 20) {\n  for (let r = 0; r < rounds; r += 2) {\n    chachaQR(x, 0, 4, 8, 12);\n    chachaQR(x, 1, 5, 9, 13);\n    chachaQR(x, 2, 6, 10, 14);\n    chachaQR(x, 3, 7, 11, 15);\n    chachaQR(x, 0, 5, 10, 15);\n    chachaQR(x, 1, 6, 11, 12);\n    chachaQR(x, 2, 7, 8, 13);\n    chachaQR(x, 3, 4, 9, 14);\n  }\n}\n\nconst ctmp = /* @__PURE__ */ new Uint32Array(16);\n\n/** Small version of chacha without loop unrolling. Unused, provided for auditability. */\n// prettier-ignore\nfunction chacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, out: Uint32Array,\n  isHChacha: boolean = true, rounds: number = 20\n): void {\n  // Create initial array using common pattern\n  const y = Uint32Array.from([\n    s[0], s[1], s[2], s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n    k[0], k[1], k[2], k[3], // Key      Key     Key     Key\n    k[4], k[5], k[6], k[7], // Key      Key     Key     Key\n    i[0], i[1], i[2], i[3], // Counter  Counter Nonce   Nonce\n  ]);\n  const x = ctmp;\n  x.set(y);\n  chachaRound(x, rounds);\n\n  // hchacha extracts 8 specific bytes, chacha adds orig to result\n  if (isHChacha) {\n    const xindexes = [0, 1, 2, 3, 12, 13, 14, 15];\n    for (let i = 0; i < 8; i++) out[i] = x[xindexes[i]];\n  } else {\n    for (let i = 0; i < 16; i++) out[i] = (y[i] + x[i]) | 0;\n  }\n}\n\n/** Identical to `chachaCore`. Unused. */\n// @ts-ignore\nconst chachaCore_small: typeof chachaCore = (s, k, n, out, cnt, rounds) =>\n  chacha(s, k, Uint32Array.from([n[0], n[1], cnt, 0]), out, false, rounds);\n/** Identical to `hchacha`. Unused. */\n// @ts-ignore\nconst hchacha_small: typeof hchacha = chacha;\n\n/** Identical to `chachaCore_small`. Unused. */\n// prettier-ignore\nfunction chachaCore(\n  s: Uint32Array, k: Uint32Array, n: Uint32Array, out: Uint32Array, cnt: number, rounds = 20\n): void {\n  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], // \"expa\"   \"nd 3\"  \"2-by\"  \"te k\"\n      y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], // Key      Key     Key     Key\n      y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], // Key      Key     Key     Key\n      y12 = cnt,  y13 = n[0], y14 = n[1], y15 = n[2];  // Counter  Counter\tNonce   Nonce\n  // Save state to temporary variables\n  let x00 = y00, x01 = y01, x02 = y02, x03 = y03,\n      x04 = y04, x05 = y05, x06 = y06, x07 = y07,\n      x08 = y08, x09 = y09, x10 = y10, x11 = y11,\n      x12 = y12, x13 = y13, x14 = y14, x15 = y15;\n  for (let r = 0; r < rounds; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  // Write output\n  let oi = 0;\n  out[oi++] = (y00 + x00) | 0; out[oi++] = (y01 + x01) | 0;\n  out[oi++] = (y02 + x02) | 0; out[oi++] = (y03 + x03) | 0;\n  out[oi++] = (y04 + x04) | 0; out[oi++] = (y05 + x05) | 0;\n  out[oi++] = (y06 + x06) | 0; out[oi++] = (y07 + x07) | 0;\n  out[oi++] = (y08 + x08) | 0; out[oi++] = (y09 + x09) | 0;\n  out[oi++] = (y10 + x10) | 0; out[oi++] = (y11 + x11) | 0;\n  out[oi++] = (y12 + x12) | 0; out[oi++] = (y13 + x13) | 0;\n  out[oi++] = (y14 + x14) | 0; out[oi++] = (y15 + x15) | 0;\n}\n/**\n * hchacha hashes key and nonce into key' and nonce' for xchacha20.\n * Identical to `hchacha_small`.\n * Need to find a way to merge it with `chachaCore` without 25% performance hit.\n */\n// prettier-ignore\nexport function hchacha(\n  s: Uint32Array, k: Uint32Array, i: Uint32Array, out: Uint32Array\n): void {\n  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3],\n      x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3],\n      x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7],\n      x12 = i[0], x13 = i[1], x14 = i[2], x15 = i[3];\n  for (let r = 0; r < 20; r += 2) {\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 16);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 12);\n    x00 = (x00 + x04) | 0; x12 = rotl(x12 ^ x00, 8);\n    x08 = (x08 + x12) | 0; x04 = rotl(x04 ^ x08, 7);\n\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 16);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 12);\n    x01 = (x01 + x05) | 0; x13 = rotl(x13 ^ x01, 8);\n    x09 = (x09 + x13) | 0; x05 = rotl(x05 ^ x09, 7);\n\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 16);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 12);\n    x02 = (x02 + x06) | 0; x14 = rotl(x14 ^ x02, 8);\n    x10 = (x10 + x14) | 0; x06 = rotl(x06 ^ x10, 7);\n\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 16);\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 12);\n    x03 = (x03 + x07) | 0; x15 = rotl(x15 ^ x03, 8)\n    x11 = (x11 + x15) | 0; x07 = rotl(x07 ^ x11, 7);\n\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 16);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 12);\n    x00 = (x00 + x05) | 0; x15 = rotl(x15 ^ x00, 8);\n    x10 = (x10 + x15) | 0; x05 = rotl(x05 ^ x10, 7);\n\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 16);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 12);\n    x01 = (x01 + x06) | 0; x12 = rotl(x12 ^ x01, 8);\n    x11 = (x11 + x12) | 0; x06 = rotl(x06 ^ x11, 7);\n\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 16);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 12);\n    x02 = (x02 + x07) | 0; x13 = rotl(x13 ^ x02, 8);\n    x08 = (x08 + x13) | 0; x07 = rotl(x07 ^ x08, 7);\n\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 16)\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 12);\n    x03 = (x03 + x04) | 0; x14 = rotl(x14 ^ x03, 8);\n    x09 = (x09 + x14) | 0; x04 = rotl(x04 ^ x09, 7);\n  }\n  let oi = 0;\n  out[oi++] = x00; out[oi++] = x01;\n  out[oi++] = x02; out[oi++] = x03;\n  out[oi++] = x12; out[oi++] = x13;\n  out[oi++] = x14; out[oi++] = x15;\n}\n\n/** Original, non-RFC chacha20 from DJB. 8-byte nonce, 8-byte counter. */\nexport const chacha20orig: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  allowShortKeys: true,\n});\n/**\n * ChaCha stream cipher. Conforms to RFC 8439 (IETF, TLS). 12-byte nonce, 4-byte counter.\n * With smaller nonce, it's not safe to make it random (CSPRNG), due to collision chance.\n */\nexport const chacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  allowShortKeys: false,\n});\n\n/**\n * XChaCha eXtended-nonce ChaCha. With 24-byte nonce, it's safe to make it random (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 8,\n  extendNonceFn: hchacha,\n  allowShortKeys: false,\n});\n\n/** Reduced 8-round chacha, described in original paper. */\nexport const chacha8: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 8,\n});\n\n/** Reduced 12-round chacha, described in original paper. */\nexport const chacha12: XorStream = /* @__PURE__ */ createCipher(chachaCore, {\n  counterRight: false,\n  counterLength: 4,\n  rounds: 12,\n});\n\nconst ZEROS16 = /* @__PURE__ */ new Uint8Array(16);\n// Pad to digest size with zeros\nconst updatePadded = (h: ReturnType<typeof poly1305.create>, msg: Uint8Array) => {\n  h.update(msg);\n  const leftover = msg.length % 16;\n  if (leftover) h.update(ZEROS16.subarray(leftover));\n};\n\nconst ZEROS32 = /* @__PURE__ */ new Uint8Array(32);\nfunction computeTag(\n  fn: XorStream,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  ciphertext: Uint8Array,\n  AAD?: Uint8Array\n): Uint8Array {\n  if (AAD !== undefined) abytes(AAD, undefined, 'AAD');\n  const authKey = fn(key, nonce, ZEROS32);\n  const lengths = u64Lengths(ciphertext.length, AAD ? AAD.length : 0, true);\n\n  // Methods below can be replaced with\n  // return poly1305_computeTag_small(authKey, lengths, ciphertext, AAD)\n  const h = poly1305.create(authKey);\n  if (AAD) updatePadded(h, AAD);\n  updatePadded(h, ciphertext);\n  h.update(lengths);\n  const res = h.digest();\n  clean(authKey, lengths);\n  return res;\n}\n\n/**\n * AEAD algorithm from RFC 8439.\n * Salsa20 and chacha (RFC 8439) use poly1305 differently.\n * We could have composed them, but it's hard because of authKey:\n * In salsa20, authKey changes position in salsa stream.\n * In chacha, authKey can't be computed inside computeTag, it modifies the counter.\n */\nexport const _poly1305_aead =\n  (xorStream: XorStream) =>\n  (key: Uint8Array, nonce: Uint8Array, AAD?: Uint8Array): CipherWithOutput => {\n    const tagLength = 16;\n    return {\n      encrypt(plaintext: Uint8Array, output?: Uint8Array) {\n        const plength = plaintext.length;\n        output = getOutput(plength + tagLength, output, false);\n        output.set(plaintext);\n        const oPlain = output.subarray(0, -tagLength);\n        // Actual encryption\n        xorStream(key, nonce, oPlain, oPlain, 1);\n        const tag = computeTag(xorStream, key, nonce, oPlain, AAD);\n        output.set(tag, plength); // append tag\n        clean(tag);\n        return output;\n      },\n      decrypt(ciphertext: Uint8Array, output?: Uint8Array) {\n        output = getOutput(ciphertext.length - tagLength, output, false);\n        const data = ciphertext.subarray(0, -tagLength);\n        const passedTag = ciphertext.subarray(-tagLength);\n        const tag = computeTag(xorStream, key, nonce, data, AAD);\n        if (!equalBytes(passedTag, tag)) throw new Error('invalid tag');\n        output.set(ciphertext.subarray(0, -tagLength));\n        // Actual decryption\n        xorStream(key, nonce, output, output, 1); // start stream with i=1\n        clean(tag);\n        return output;\n      },\n    };\n  };\n\n/**\n * ChaCha20-Poly1305 from RFC 8439.\n *\n * Unsafe to use random nonces under the same key, due to collision chance.\n * Prefer XChaCha instead.\n */\nexport const chacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 12, tagLength: 16 },\n  _poly1305_aead(chacha20)\n);\n/**\n * XChaCha20-Poly1305 extended-nonce chacha.\n *\n * Can be safely used with random nonces (CSPRNG).\n * See [IRTF draft](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-xchacha).\n */\nexport const xchacha20poly1305: ARXCipher = /* @__PURE__ */ wrapCipher(\n  { blockSize: 64, nonceLength: 24, tagLength: 16 },\n  _poly1305_aead(xchacha20)\n);\n\n/**\n * Chacha20 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Compatible with libtomcrypt. It does not have a specification, so unclear how secure it is.\n */\nexport const rngChacha20: XorPRG = /* @__PURE__ */ createPRG(chacha20orig, 64, 32, 8);\n/**\n * Chacha20/8 CSPRNG (cryptographically secure pseudorandom number generator).\n * It's best to limit usage to non-production, non-critical cases: for example, test-only.\n * Faster than `rngChacha20`.\n */\nexport const rngChacha8: XorPRG = /* @__PURE__ */ createPRG(chacha8, 64, 32, 12);\n", "/**\n * Cryptographic utilities\n *\n * Type-safe cryptographic operations including random number generation, SLIP21\n * key derivation, XChaCha20-Poly1305 symmetric encryption, PADM padding, and\n * timing-safe comparisons.\n *\n * @module\n */\nimport { xchacha20poly1305 } from \"@noble/ciphers/chacha.js\";\nimport { hmac } from \"@noble/hashes/hmac.js\";\nimport { sha512 } from \"@noble/hashes/sha2.js\";\nimport { randomBytes, utf8ToBytes } from \"@noble/hashes/utils.js\";\nimport { trySync } from \"./Result.js\";\nimport { brand, length, NonNegativeInt, Uint8Array } from \"./Type.js\";\nconst Entropy = brand(\"Entropy\", Uint8Array);\nexport const Entropy16 = length(16)(Entropy);\nexport const Entropy32 = length(32)(Entropy);\nexport const Entropy64 = length(64)(Entropy);\nexport const createRandomBytes = () => ({\n    create: randomBytes,\n});\n/**\n * SLIP21.\n *\n * https://github.com/satoshilabs/slips/blob/master/slip-0021.md\n */\nexport const createSlip21 = (seed, path) => {\n    let currentNode = hmac(sha512, utf8ToBytes(\"Symmetric key seed\"), seed);\n    for (const element of path) {\n        const label = typeof element === \"number\" ? element.toString() : element;\n        currentNode = deriveSlip21Node(label, currentNode);\n    }\n    return currentNode.slice(32, 64);\n};\n/**\n * Derives a single node in the SLIP-21 hierarchical key derivation.\n *\n * @see {@link createSlip21}\n */\nexport const deriveSlip21Node = (label, parentNode) => {\n    const labelBytes = utf8ToBytes(label);\n    const message = new globalThis.Uint8Array(labelBytes.byteLength + 1);\n    message[0] = 0;\n    message.set(labelBytes, 1);\n    return hmac(sha512, parentNode.slice(0, 32), message);\n};\n/** The encryption key for {@link SymmetricCrypto}. */\nexport const EncryptionKey = brand(\"EncryptionKey\", Entropy32);\n/**\n * XChaCha20-Poly1305 encryption\n *\n * https://github.com/paulmillr/noble-ciphers?tab=readme-ov-file#which-cipher-should-i-pick\n */\nexport const createSymmetricCrypto = (deps) => {\n    const nonceLength = NonNegativeInt.orThrow(24);\n    const symmetricCrypto = {\n        nonceLength,\n        encrypt: (plaintext, encryptionKey) => {\n            const nonce = deps.randomBytes.create(nonceLength);\n            const ciphertext = xchacha20poly1305(encryptionKey, nonce).encrypt(plaintext);\n            return { nonce, ciphertext };\n        },\n        decrypt: (ciphertext, encryptionKey, nonce) => trySync(() => xchacha20poly1305(encryptionKey, nonce).decrypt(ciphertext), (error) => ({\n            type: \"SymmetricCryptoDecryptError\",\n            error,\n        })),\n    };\n    return symmetricCrypto;\n};\n/**\n * Returns the PADM padded length for a given input length.\n *\n * PADM limits information leakage about the length of the plain-text for a\n * wide range of encrypted data sizes.\n *\n * See the PURBs paper for details: https://bford.info/pub/sec/purb.pdf\n */\nexport const createPadmePaddedLength = (length) => {\n    if (length <= 0)\n        return NonNegativeInt.orThrow(0);\n    const e = 31 - Math.clz32(length >>> 0);\n    const s = 32 - Math.clz32(e >>> 0);\n    const z = Math.max(0, e - s);\n    const mask = (1 << z) - 1;\n    return NonNegativeInt.orThrow((length + mask) & ~mask);\n};\n/** Creates a PADM padding array of zeros for the given input length. */\nexport const createPadmePadding = (length) => {\n    const paddedLength = createPadmePaddedLength(length);\n    const paddingLength = NonNegativeInt.orThrow(paddedLength - length);\n    return new globalThis.Uint8Array(paddingLength);\n};\n", "export const eqStrict = (x, y) => x === y;\nexport const eqString = eqStrict;\nexport const eqNumber = eqStrict;\nexport const eqBigInt = eqStrict;\nexport const eqBoolean = eqStrict;\nexport const eqUndefined = eqStrict;\nexport const eqNull = eqStrict;\n/** Derives an {@link Eq} from an {@link Order}. */\nexport const eqFromOrder = (order) => (x, y) => order(x, y) === 0;\n/**\n * Creates an equivalence function for array-like structures based on an\n * equivalence for their elements.\n *\n * ### Example\n *\n * ```ts\n * const eqArrayNumber = createEqArrayLike(eqNumber);\n * eqArrayNumber([1, 2, 3], [1, 2, 3]); // true (works with regular arrays)\n * eqArrayNumber(new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3])); // true (works with Uint8Array)\n * eqArrayNumber([1, 2, 3], [1, 2, 4]); // false\n * ```\n */\nexport const createEqArrayLike = (item) => (x, y) => {\n    if (x === y)\n        return true;\n    if (x.length !== y.length)\n        return false;\n    for (let i = 0; i < x.length; i++) {\n        if (!item(x[i], y[i]))\n            return false;\n    }\n    return true;\n};\n/**\n * Compares two array-like structures of numbers for equality.\n *\n * ### Example\n *\n * ```ts\n * eqArrayNumber([1, 2, 3], [1, 2, 3]); // true (works with regular arrays)\n * eqArrayNumber(new Uint8Array([1, 2, 3]), new Uint8Array([1, 2, 3])); // true (works with Uint8Array)\n * eqArrayNumber([1, 2, 3], [1, 2, 4]); // false\n * ```\n */\nexport const eqArrayNumber = createEqArrayLike(eqNumber);\n/**\n * Creates an equivalence function for objects based on an equivalence for their\n * fields.\n *\n * ### Example\n *\n * ```ts\n * const eqObjectNumber = createEqObject({ a: eqNumber });\n * eqObjectNumber({ a: 1 }, { a: 1 }); // true\n * eqObjectNumber({ a: 1 }, { a: 2 }); // false\n * ```\n */\nexport const createEqObject = (eqs) => (x, y) => {\n    if (x === y)\n        return true;\n    for (const key in eqs) {\n        if (!eqs[key](x[key], y[key])) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Deeply compares two {@link JsonValue} values for equality.\n *\n * - Uses an iterative approach with a stack to handle large or deeply nested\n *   objects without risking stack overflow.\n * - Handles circular references with a WeakMap to prevent infinite loops.\n * - Unlike JSON.stringify, this function directly compares values, avoiding\n *   serialization overhead and leveraging short-circuit evaluation for faster\n *   failure on mismatched structures.\n *\n * ### Example\n *\n * ```ts\n * const obj1: Json = { name: \"Alice\", hobbies: [\"reading\", \"hiking\"] };\n * const obj2: Json = { name: \"Alice\", hobbies: [\"reading\", \"hiking\"] };\n * console.log(eqJson(obj1, obj2)); // true\n * ```\n */\nexport const eqJsonValue = (a, b) => {\n    const stack = [[a, b]];\n    const seen = new WeakMap();\n    while (stack.length > 0) {\n        const [x, y] = stack.pop();\n        if (x === y)\n            continue;\n        const typeX = typeof x;\n        const typeY = typeof y;\n        if (typeX !== typeY || x === null || y === null)\n            return false;\n        if (typeX === \"number\" && isNaN(x) && isNaN(y)) {\n            continue;\n        }\n        if (typeX === \"object\") {\n            const isArrayX = Array.isArray(x);\n            const isArrayY = Array.isArray(y);\n            if (isArrayX !== isArrayY)\n                return false;\n            const xObj = x;\n            const yObj = y;\n            if (seen.has(xObj)) {\n                const ySet = seen.get(xObj);\n                if (ySet.has(yObj)) {\n                    continue;\n                }\n                ySet.add(yObj);\n            }\n            else {\n                const ySet = new WeakSet();\n                ySet.add(yObj);\n                seen.set(xObj, ySet);\n            }\n            if (isArrayX && isArrayY) {\n                const xArr = x;\n                const yArr = y;\n                if (xArr.length !== yArr.length)\n                    return false;\n                for (let i = 0; i < xArr.length; i++) {\n                    stack.push([xArr[i], yArr[i]]);\n                }\n            }\n            else {\n                const xObjTyped = x;\n                const yObjTyped = y;\n                const xKeys = Object.keys(xObjTyped);\n                const yKeys = Object.keys(yObjTyped);\n                if (xKeys.length !== yKeys.length)\n                    return false;\n                const yKeySet = new Set(yKeys);\n                for (const key of xKeys) {\n                    if (!yKeySet.has(key))\n                        return false;\n                    stack.push([xObjTyped[key], yObjTyped[key]]);\n                }\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Deeply compares two {@link JsonValueInput} values for equality.\n *\n * - Uses an iterative approach with a stack to handle large or deeply nested\n *   objects without risking stack overflow.\n * - Handles circular references with a WeakMap to prevent infinite loops.\n * - Unlike JSON.stringify, this function directly compares values, avoiding\n *   serialization overhead and leveraging short-circuit evaluation for faster\n *   failure on mismatched structures.\n *\n * ### Example\n *\n * ```ts\n * const obj1: Json = { name: \"Alice\", hobbies: [\"reading\", \"hiking\"] };\n * const obj2: Json = { name: \"Alice\", hobbies: [\"reading\", \"hiking\"] };\n * console.log(eqJson(obj1, obj2)); // true\n * ```\n */\nexport const eqJsonValueInput = (a, b) => eqJsonValue(a, b);\n", "/** Creates a {@link TransferableError} from an unknown error. */\nexport const createTransferableError = (error) => {\n    const convertError = (err) => {\n        const transferableError = Object.getOwnPropertyNames(err).reduce((acc, key) => {\n            const value = err[key];\n            if (key === \"cause\" && value instanceof Error) {\n                // Recursively process the `cause` property\n                acc[key] = convertError(value);\n            }\n            else if (typeof value !== \"function\") {\n                acc[key] = value;\n            }\n            return acc;\n        }, {});\n        return transferableError;\n    };\n    if (error instanceof Error) {\n        return {\n            type: \"TransferableError\",\n            error: convertError(error),\n        };\n    }\n    try {\n        // Clone other values that are transferable\n        return {\n            type: \"TransferableError\",\n            error: structuredClone(error),\n        };\n    }\n    catch {\n        // Fallback for non-transferable or problematic values\n        try {\n            return {\n                type: \"TransferableError\",\n                error: String(error), // Attempt to convert to a string\n            };\n        }\n        catch {\n            // Final fallback if even `String(error)` fails\n            return {\n                type: \"TransferableError\",\n                error: \"[Unserializable Object]\",\n            };\n        }\n    }\n};\n", "/**\n * Helper function to ensure exhaustive matching in a switch statement. Throws\n * an error if an unhandled case is encountered.\n *\n * Remember, it's useful only when we don't return anything from the switch\n * statement. Otherwise, a return type of a function is enough.\n *\n * ### Example\n *\n * ```ts\n * type Color = \"red\" | \"green\" | \"blue\";\n *\n * function handleColor(color: Color): void {\n *   switch (color) {\n *     case \"red\":\n *       console.log(\"Handling red\");\n *       break;\n *     case \"green\":\n *       console.log(\"Handling green\");\n *       break;\n *     case \"blue\":\n *       console.log(\"Handling blue\");\n *       break;\n *     default:\n *       exhaustiveCheck(color); // Ensures all cases are handled\n *   }\n * }\n * ```\n */\nexport const exhaustiveCheck = (value) => {\n    throw new Error(`exhaustiveCheck unhandled case: ${JSON.stringify(value)}`);\n};\n/**\n * Returns the input value unchanged.\n *\n * Useful as a default transformation, placeholder callback, or when a function\n * is required but no transformation is needed.\n *\n * ### Example\n *\n * ```ts\n * const values = [1, 2, 3];\n * const same = values.map(identity); // [1, 2, 3]\n *\n * const getTransform = (shouldDouble: boolean) =>\n *   shouldDouble ? (x: number) => x * 2 : identity;\n * ```\n */\nexport const identity = (a) => a;\nexport function readonly(value) {\n    return value;\n}\nexport const constVoid = () => undefined;\nexport const constUndefined = () => undefined;\nexport const constNull = () => null;\nexport const constTrue = () => true;\nexport const constFalse = () => false;\n", "/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://www.rfc-editor.org/rfc/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal SHA1 legacy hash class. */\nexport class _SHA1 extends HashMD<_SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new _SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** Internal MD5 legacy hash class. */\nexport class _MD5 extends HashMD<_MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new _MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class _RIPEMD160 extends HashMD<_RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new _RIPEMD160());\n", "import { idToIdBytes } from \"./Type.js\";\nimport { md5 } from \"@noble/hashes/legacy.js\";\n/**\n * Creates a deterministic identicon SVG from an {@link Id}.\n *\n * Works with any {@link Id} including branded IDs like `OwnerId`, etc.\n *\n * Available styles:\n *\n * - `\"github\"` (default): 5x5 grid with horizontal mirroring (GitHub-style)\n * - `\"quadrant\"`: 2x2 grid with direct RGB color mapping from bytes\n * - `\"gradient\"`: Diagonal stripes with smooth color gradients\n * - `\"sutnar\"`: Three compositional variants with adaptive colors\n *\n * ### Example\n *\n * ```ts\n * const svg = createIdenticon(id);\n * const quadrantStyle = createIdenticon(id, \"quadrant\");\n * const gradientStyle = createIdenticon(id, \"gradient\");\n * const sutnarStyle = createIdenticon(id, \"sutnar\");\n *\n * // Works with branded IDs\n * const ownerSvg = createIdenticon(ownerId);\n * ```\n */\nexport const createIdenticon = (id, style = \"github\") => {\n    const bytes = idToIdBytes(id);\n    switch (style) {\n        case \"github\": {\n            // GitHub-style identicon: MD5 hash the bytes first\n            const hashedBytes = md5(bytes);\n            // Map function for value ranges\n            const map = (value, inMin, inMax, outMin, outMax) => ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;\n            // Extract 12-bit hue from bytes[12] (lower 4 bits) + bytes[13]\n            const h = ((hashedBytes[12] & 0x0f) << 8) | hashedBytes[13];\n            const hue = map(h, 0, 4095, 0, 360);\n            const saturation = 65 - map(hashedBytes[14], 0, 255, 0, 20);\n            const lightness = 75 - map(hashedBytes[15], 0, 255, 0, 20);\n            const fgColor = `hsl(${hue},${saturation}%,${lightness}%)`;\n            const bgColor = `hsl(${hue},${saturation}%,90%)`;\n            let rects = `<rect width=\"5\" height=\"5\" fill=\"${bgColor}\"/>`;\n            // Extract nibbles and generate pattern\n            let nibbleIndex = 0;\n            for (let x = 2; x >= 0; x--) {\n                for (let y = 0; y < 5; y++) {\n                    const byte = hashedBytes[Math.floor(nibbleIndex / 2)];\n                    const nibble = nibbleIndex % 2 === 0 ? byte >> 4 : byte & 0x0f;\n                    const paint = nibble % 2 === 0;\n                    nibbleIndex++;\n                    if (paint) {\n                        rects += `<rect x=\"${x}\" y=\"${y}\" width=\"1\" height=\"1\" fill=\"${fgColor}\"/>`;\n                        const mx = 4 - x;\n                        if (mx !== x) {\n                            rects += `<rect x=\"${mx}\" y=\"${y}\" width=\"1\" height=\"1\" fill=\"${fgColor}\"/>`;\n                        }\n                    }\n                }\n            }\n            return `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 5 5\" shape-rendering=\"crispEdges\">${rects}</svg>`;\n        }\n        case \"quadrant\": {\n            const toHex = (b) => b.toString(16).padStart(2, \"0\");\n            let rects = \"\";\n            for (let i = 0; i < 4; i++) {\n                const x = i % 2;\n                const y = Math.floor(i / 2);\n                const r = bytes[i * 3];\n                const g = bytes[i * 3 + 1];\n                const b = bytes[i * 3 + 2];\n                const color = `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n                rects += `<rect x=\"${x}\" y=\"${y}\" width=\"1\" height=\"1\" fill=\"${color}\"/>`;\n            }\n            return `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 2 2\">${rects}</svg>`;\n        }\n        case \"gradient\": {\n            // Smooth color gradients with diagonal stripes.\n            const toHex = (b) => b.toString(16).padStart(2, \"0\");\n            // Generate colors from bytes.\n            const color1 = `#${toHex(bytes[0])}${toHex(bytes[1])}${toHex(bytes[2])}`;\n            const color2 = `#${toHex(bytes[3])}${toHex(bytes[4])}${toHex(bytes[5])}`;\n            const color3 = `#${toHex(bytes[6])}${toHex(bytes[7])}${toHex(bytes[8])}`;\n            let defs = \"\";\n            let shapes = \"\";\n            // Diagonal stripes with gradient.\n            defs += `<linearGradient id=\"grad1-${id}\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">`;\n            defs += `<stop offset=\"0%\" style=\"stop-color:${color1};stop-opacity:1\" />`;\n            defs += `<stop offset=\"100%\" style=\"stop-color:${color2};stop-opacity:1\" />`;\n            defs += `</linearGradient>`;\n            defs += `<linearGradient id=\"grad2-${id}\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\">`;\n            defs += `<stop offset=\"0%\" style=\"stop-color:${color2};stop-opacity:1\" />`;\n            defs += `<stop offset=\"100%\" style=\"stop-color:${color3};stop-opacity:1\" />`;\n            defs += `</linearGradient>`;\n            shapes += `<rect width=\"100\" height=\"100\" fill=\"url(#grad1-${id})\"/>`;\n            const stripeWidth = 15 + (bytes[9] / 255) * 20;\n            const angle = 30 + (bytes[10] / 255) * 60;\n            shapes += `<rect x=\"20\" y=\"-50\" width=\"${stripeWidth}\" height=\"200\" fill=\"url(#grad2-${id})\" transform=\"rotate(${angle} 50 50)\" opacity=\"0.7\"/>`;\n            shapes += `<rect x=\"60\" y=\"-50\" width=\"${stripeWidth}\" height=\"200\" fill=\"url(#grad2-${id})\" transform=\"rotate(${angle} 50 50)\" opacity=\"0.5\"/>`;\n            return `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\"><defs>${defs}</defs>${shapes}</svg>`;\n        }\n        case \"sutnar\": {\n            // Three compositional variants with adaptive colors.\n            const hue = (bytes[0] / 255) * 360;\n            const saturation = 50 + (bytes[1] / 255) * 30;\n            const lightness = 50 + (bytes[2] / 255) * 20;\n            // Generate palette from base hue with variations\n            const toHsl = (h, s, l) => `hsl(${h},${s}%,${l}%)`;\n            const color1 = toHsl(hue, saturation, lightness);\n            const color2 = toHsl((hue + 120) % 360, saturation, lightness);\n            const color3 = toHsl((hue + 240) % 360, saturation, lightness);\n            const color4 = toHsl(hue, saturation * 0.3, lightness * 0.5);\n            const color5 = toHsl(hue, saturation * 0.5, Math.min(lightness * 1.3, 90));\n            const palette = [color1, color2, color3, color4, color5];\n            // Layout variant based on first byte.\n            const variant = bytes[3] % 3;\n            let shapes = \"\";\n            // Almost white background with subtle tint.\n            shapes += `<rect width=\"100\" height=\"100\" fill=\"${toHsl(hue, 10, 95)}\"/>`;\n            if (variant === 0) {\n                // Composition A: Circle + horizontal bar.\n                const circleColor = palette[bytes[4] % palette.length];\n                const barColor = palette[(bytes[4] + 1) % palette.length];\n                shapes += `<circle cx=\"30\" cy=\"50\" r=\"22\" fill=\"${circleColor}\"/>`;\n                shapes += `<rect x=\"60\" y=\"40\" width=\"35\" height=\"20\" fill=\"${barColor}\"/>`;\n            }\n            else if (variant === 1) {\n                // Composition B: Vertical bar + circle.\n                const barColor = palette[bytes[5] % palette.length];\n                const circleColor = palette[(bytes[5] + 1) % palette.length];\n                shapes += `<rect x=\"15\" y=\"10\" width=\"18\" height=\"80\" fill=\"${barColor}\"/>`;\n                shapes += `<circle cx=\"70\" cy=\"50\" r=\"15\" fill=\"${circleColor}\"/>`;\n            }\n            else {\n                // Composition C: Square + circle.\n                const squareColor = palette[bytes[6] % palette.length];\n                const circleColor = palette[(bytes[6] + 1) % palette.length];\n                shapes += `<rect x=\"20\" y=\"20\" width=\"30\" height=\"30\" fill=\"${squareColor}\"/>`;\n                shapes += `<circle cx=\"70\" cy=\"70\" r=\"18\" fill=\"${circleColor}\"/>`;\n            }\n            return `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 100 100\">${shapes}</svg>`;\n        }\n    }\n};\n", "/** Creates an {@link Instances}. */\nexport const createInstances = () => {\n    const instances = new Map();\n    return {\n        ensure: (key, create, onCacheHit) => {\n            let instance = instances.get(key);\n            if (instance == null) {\n                instance = create();\n                instances.set(key, instance);\n            }\n            else if (onCacheHit) {\n                onCacheHit(instance);\n            }\n            return instance;\n        },\n        get: (key) => instances.get(key) ?? null,\n        has: (key) => instances.has(key),\n        delete: (key) => {\n            const instance = instances.get(key);\n            if (instance == null)\n                return false;\n            instances.delete(key);\n            instance[Symbol.dispose]();\n            return true;\n        },\n        [Symbol.dispose]: () => {\n            const errors = [];\n            for (const instance of instances.values()) {\n                try {\n                    instance[Symbol.dispose]();\n                }\n                catch (error) {\n                    errors.push(error);\n                }\n            }\n            instances.clear();\n            if (errors.length === 1)\n                throw errors[0];\n            if (errors.length > 1) {\n                throw new AggregateError(errors, \"Multiple disposal errors occurred\");\n            }\n        },\n    };\n};\n", "import { createLruCache } from \"./Cache.js\";\nimport { eqArrayNumber } from \"./Eq.js\";\nimport { createTransferableError } from \"./Error.js\";\nimport { err, ok, tryAsync, trySync } from \"./Result.js\";\nimport { Null, Number, PositiveInt, String, Uint8Array, union, } from \"./Type.js\";\n/**\n * A value that can be stored in Sqlite.\n *\n * Note that Evolu can't support Int64 because expo-sqlite (and some others) do\n * not support it.\n */\nexport const SqliteValue = union(Null, String, Number, Uint8Array);\nexport const eqSqliteValue = (x, y) => {\n    if (x instanceof globalThis.Uint8Array &&\n        y instanceof globalThis.Uint8Array) {\n        return eqArrayNumber(x, y);\n    }\n    return x === y;\n};\n/**\n * Creates a fully featured {@link Sqlite} instance from a {@link SqliteDriver}\n * implementation.\n */\nexport const createSqlite = (deps) => async (name, options) => tryAsync(async () => {\n    const driver = await deps.createSqliteDriver(name, options);\n    let isDisposed = false;\n    const doRollback = () => trySync(() => {\n        deps.console?.log(\"[sql] rollback\");\n        driver.exec(sql `rollback;`, true);\n    }, createSqliteError);\n    const sqlite = {\n        exec: (query) => trySync(() => {\n            deps.console?.log(\"[sql]\", { query });\n            const result = maybeLogSqliteQueryExecutionTime(query, () => driver.exec(query, isSqlMutation(query.sql)));\n            deps.console?.log(\"[sql]\", { result });\n            return result;\n        }, (error) => ({\n            type: \"SqliteError\",\n            error: createTransferableError(error),\n        })),\n        transaction: (callback) => {\n            const transactionResult = trySync(() => {\n                deps.console?.log(\"[sql] begin\");\n                driver.exec(sql `begin;`, true);\n                const result = callback();\n                if (!result.ok)\n                    return result;\n                deps.console?.log(\"[sql] commit\");\n                driver.exec(sql `commit;`, true);\n                return result;\n            }, createSqliteError);\n            // There was an SqliteError during begin, callback, or commit\n            if (!transactionResult.ok) {\n                const rollback = doRollback();\n                if (!rollback.ok) {\n                    deps.console?.log(\"[sql] rollback failed\", rollback.error);\n                    return err({\n                        type: \"SqliteError\",\n                        error: transactionResult.error.error,\n                        rollbackError: rollback.error.error,\n                    });\n                }\n                return transactionResult;\n            }\n            // Callback returned an error\n            if (!transactionResult.value.ok) {\n                const rollback = doRollback();\n                if (!rollback.ok) {\n                    deps.console?.log(\"[sql] rollback failed\", rollback.error);\n                    return err({\n                        type: \"SqliteError\",\n                        error: createTransferableError(transactionResult.value.error),\n                        rollbackError: rollback.error.error,\n                    });\n                }\n                return transactionResult.value;\n            }\n            return ok(transactionResult.value.value);\n        },\n        export: () => trySync(() => {\n            return driver.export();\n        }, (error) => ({\n            type: \"SqliteError\",\n            error: createTransferableError(error),\n        })),\n        [Symbol.dispose]: () => {\n            if (isDisposed)\n                return;\n            isDisposed = true;\n            driver[Symbol.dispose]();\n        },\n    };\n    return sqlite;\n}, createSqliteError);\nconst createSqliteError = (error) => ({\n    type: \"SqliteError\",\n    error: createTransferableError(error),\n});\nconst maybeLogSqliteQueryExecutionTime = (query, callback) => {\n    if (!query.options?.logQueryExecutionTime) {\n        return callback();\n    }\n    const start = performance.now();\n    const result = callback();\n    const elapsed = performance.now() - start;\n    // eslint-disable-next-line no-console\n    console.log(`SqliteQueryExecutionTime: ${elapsed.toString()}ms`, query);\n    return result;\n};\nexport const createPreparedStatementsCache = (factory, disposeFn) => {\n    let isDisposed = false;\n    const cache = new Map();\n    return {\n        get: (query, alwaysPrepare) => {\n            if (alwaysPrepare !== true && !query.options?.prepare)\n                return null;\n            let statement = cache.get(query.sql);\n            if (!statement) {\n                statement = factory(query.sql);\n                cache.set(query.sql, statement);\n            }\n            return statement;\n        },\n        [Symbol.dispose]: () => {\n            if (isDisposed)\n                return;\n            isDisposed = true;\n            cache.forEach(disposeFn);\n            cache.clear();\n        },\n    };\n};\n/**\n * Creates a safe SQL query using a tagged template literal.\n *\n * Parameters are automatically escaped and bound as SQLite values. Use\n * `sql.identifier` for column/table names and `sql.raw` for unescaped SQL.\n *\n * ### Example\n *\n * ```ts\n * const id = 42;\n * const name = \"Alice\";\n *\n * const result = sqlite.exec(sql`\n *   select *\n *   from users\n *   where id = ${id} and name = ${name};\n * `);\n *\n * // For identifiers\n * const tableName = \"users\";\n * sqlite.exec(sql`\n *   create table ${sql.identifier(tableName)} (\n *     \"id\" text primary key,\n *     \"name\" text not null\n *   );\n * `);\n *\n * // For raw SQL (use with caution)\n * const orderBy = \"created_at desc\";\n * sqlite.exec(sql`select * from users order by ${sql.raw(orderBy)};`);\n * ```\n *\n * ### TIP\n *\n * Use `prettier-plugin-sql-cst` for SQL formatting. Like Prettier for\n * JavaScript, this plugin formats SQL expressions differently depending on\n * their length.\n */\nexport const sql = (strings, ...parameters) => {\n    let sql = \"\";\n    const values = [];\n    for (let i = 0; i < strings.length; i++) {\n        sql += strings[i];\n        if (i < parameters.length) {\n            const param = parameters[i];\n            if (typeof param === \"object\" && param != null && \"type\" in param) {\n                sql += param.sql;\n            }\n            else {\n                sql += \"?\";\n                values.push(param);\n            }\n        }\n    }\n    return { sql: sql, parameters: values };\n};\nsql.identifier = (identifier) => ({\n    type: \"SqlIdentifier\",\n    // From Kysely\n    sql: `\"${identifier.replace(/\"/g, '\"\"')}\"`,\n});\n/**\n * Insert any string.\n *\n * Sql.raw sometimes breaks auto-formatting because the parser does not consider\n * it valid SQL. A workaround is to remove it, format it, and put it back.\n *\n * **Warning**: This is not escaped.\n */\nsql.raw = (raw) => ({ type: \"RawSql\", sql: raw });\nsql.prepared = (strings, ...parameters) => {\n    const query = sql(strings, ...parameters);\n    return { ...query, options: { prepare: true } };\n};\n/**\n * Checks if a SQL string contains mutation keywords (insert, update, delete,\n * etc.). Results are cached for performance.\n */\nexport const isSqlMutation = (sql) => {\n    /**\n     * Without cache, \"insert 1_000_000\" Storage test dropped from 57742\n     * inserts/sec to 34k. Regex we used was fast, but CodeQL flagged it as a\n     * potential ReDoS vulnerability, so manual comment removal was the only\n     * option. LRU cache restores performance.\n     */\n    const cached = isSqlMutationCache.get(sql);\n    if (cached !== undefined)\n        return cached;\n    const result = isSqlMutationRegEx.test(removeSqlComments(sql));\n    isSqlMutationCache.set(sql, result);\n    return result;\n};\nconst isSqlMutationCache = createLruCache(PositiveInt.orThrow(10_000));\nconst isSqlMutationRegEx = new RegExp(`\\\\b(${[\n    \"alter\",\n    \"create\",\n    \"delete\",\n    \"drop\",\n    \"insert\",\n    \"replace\",\n    \"update\",\n    \"begin\",\n    \"commit\",\n    \"rollback\",\n    \"pragma\",\n    \"vacuum\",\n].join(\"|\")})\\\\b`, \"i\");\n/**\n * Removes SQL line comments (--) from a SQL string without using regex to avoid\n * ReDoS vulnerabilities.\n */\nconst removeSqlComments = (sql) => {\n    // Fast path: if there are no comments, return the original string\n    if (!sql.includes(\"--\"))\n        return sql;\n    let result = \"\";\n    let i = 0;\n    while (i < sql.length) {\n        // Check for comment start\n        if (i < sql.length - 1 && sql[i] === \"-\" && sql[i + 1] === \"-\") {\n            // Skip until end of line or end of string\n            i += 2;\n            while (i < sql.length && sql[i] !== \"\\n\") {\n                i++;\n            }\n            // Keep the newline if present\n            if (i < sql.length && sql[i] === \"\\n\") {\n                result += \"\\n\";\n                i++;\n            }\n        }\n        else {\n            result += sql[i];\n            i++;\n        }\n    }\n    return result;\n};\nexport const explainSqliteQueryPlan = (deps) => (query) => {\n    const result = deps.sqlite.exec({\n        ...query,\n        sql: `EXPLAIN QUERY PLAN ${query.sql}`,\n    });\n    if (!result.ok)\n        return result;\n    // eslint-disable-next-line no-console\n    console.log(\"[explainSqliteQueryPlan]\", query);\n    // eslint-disable-next-line no-console\n    console.log(drawSqliteQueryPlan(result.value.rows));\n    return ok();\n};\nconst drawSqliteQueryPlan = (rows) => rows\n    .map((row) => {\n    let parentId = row.parent;\n    let indent = 0;\n    do {\n        const parent = rows.find((r) => r.id === parentId);\n        if (!parent)\n            break;\n        parentId = parent.parent;\n        indent++;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, no-constant-condition\n    } while (true);\n    return `${\"  \".repeat(indent)}${row.detail}`;\n})\n    .join(\"\\n\");\n/**\n * SQLite represents boolean values using `0` (false) and `1` (true) instead of\n * a dedicated boolean type.\n *\n * See: https://www.sqlite.org/quirks.html#no_separate_boolean_datatype\n *\n * ### Tips\n *\n * - Use {@link sqliteTrue} and {@link sqliteFalse} constants for better\n *   readability.\n * - Use {@link booleanToSqliteBoolean} and {@link sqliteBooleanToBoolean} for\n *   converting between JavaScript booleans and SQLite boolean values.\n */\nexport const SqliteBoolean = union(0, 1);\n/**\n * Represents the {@link SqliteBoolean} value for `true`.\n *\n * See {@link SqliteBoolean}.\n */\nexport const sqliteTrue = 1;\n/**\n * Represents the {@link SqliteBoolean} value for `false`.\n *\n * See {@link SqliteBoolean}.\n */\nexport const sqliteFalse = 0;\n/**\n * Converts a JavaScript boolean to a {@link SqliteBoolean}.\n *\n * ### Example\n *\n * ```ts\n * const isActive = true;\n * const sqlValue = booleanToSqliteBoolean(isActive); // Returns 1\n * ```\n */\nexport const booleanToSqliteBoolean = (value) => value ? sqliteTrue : sqliteFalse;\n/**\n * Converts a {@link SqliteBoolean} to a JavaScript boolean.\n *\n * ### Example\n *\n * ```ts\n * const sqlValue: SqliteBoolean = 1;\n * const bool = sqliteBooleanToBoolean(sqlValue); // Returns true\n * ```\n */\nexport const sqliteBooleanToBoolean = (value) => value === sqliteTrue;\n", "import { eqStrict } from \"./Eq.js\";\n/**\n * Creates a store with the given initial state. The store encapsulates its\n * state, which can be read with `get` and updated with `set` or `modify`. All\n * changes are broadcast to subscribers.\n *\n * By default, state changes are detected using `===` (shallow equality). You\n * can provide a custom equality function as the second argument.\n */\nexport const createStore = (initialState, eq = eqStrict) => {\n    const listeners = new Set();\n    let currentState = initialState;\n    const updateState = (newState) => {\n        if (eq(newState, currentState))\n            return;\n        currentState = newState;\n        listeners.forEach((listener) => {\n            listener();\n        });\n    };\n    return {\n        subscribe: (listener) => {\n            listeners.add(listener);\n            return () => listeners.delete(listener);\n        },\n        get: () => currentState,\n        set: (state) => {\n            updateState(state);\n        },\n        modify: (updater) => {\n            updateState(updater(currentState));\n        },\n    };\n};\n", "import { assert } from \"./Assert.js\";\nimport { createTransferableError } from \"./Error.js\";\n/**\n * Creates a {@link Worker} that supports initialization with dependencies and\n * safe error handling.\n */\nexport const createInitializedWorker = ({ init, onMessage, }) => {\n    let onMessageCallback = null;\n    let deps = null;\n    const pendingMessages = [];\n    let initializing = false;\n    const postMessage = (msg) => {\n        assert(onMessageCallback != null, \"The onMessage wasn't set\");\n        onMessageCallback(msg);\n    };\n    const postMessageTransferableError = (error) => {\n        postMessage({\n            type: \"onError\",\n            error: createTransferableError(error),\n        });\n    };\n    /**\n     * Wraps function to catch errors and send them to the main thread instead of\n     * crashing the worker.\n     */\n    const withErrorReporting = (handler) => (...args) => {\n        try {\n            handler(...args);\n        }\n        catch (error) {\n            postMessageTransferableError(error);\n        }\n    };\n    const worker = {\n        postMessage: (message) => {\n            if (message.type !== \"init\") {\n                if (!deps) {\n                    pendingMessages.push(message);\n                }\n                else {\n                    withErrorReporting(onMessage(deps))(message);\n                }\n                return;\n            }\n            if (initializing)\n                return;\n            initializing = true;\n            init(message, postMessage, withErrorReporting)\n                .then((_deps) => {\n                if (_deps == null)\n                    return;\n                deps = _deps;\n                for (const message of pendingMessages) {\n                    withErrorReporting(onMessage(deps))(message);\n                }\n                pendingMessages.length = 0;\n            })\n                .catch(postMessageTransferableError);\n        },\n        onMessage: (callback) => {\n            onMessageCallback = callback;\n        },\n    };\n    return worker;\n};\n/**\n * Creates a {@link Worker} with type-safe message handlers for each message\n * type. This provides better type safety and organization compared to a single\n * onMessage handler.\n */\nexport const createInitializedWorkerWithHandlers = ({ init, handlers, }) => createInitializedWorker({\n    init,\n    onMessage: (deps) => (message) => {\n        const messageType = message.type;\n        const handler = handlers[messageType];\n        // TypeScript knows handler exists because handlers covers all non-init message types\n        handler(deps)(message);\n    },\n});\n", "import * as bip39 from \"@scure/bip39\";\nimport { wordlist } from \"@scure/bip39/wordlists/english.js\";\nimport { createSlip21, EncryptionKey, Entropy16, Entropy32, } from \"../Crypto.js\";\nimport { getOrNull } from \"../Result.js\";\nimport { brand, Id, IdBytes, idBytesToId, idToIdBytes, NonNegativeInt, } from \"../Type.js\";\n/** OwnerId is a branded {@link Id} that uniquely identifies an {@link Owner}. */\nexport const OwnerId = brand(\"OwnerId\", Id);\n/** Bytes representation of {@link OwnerId}. */\nexport const OwnerIdBytes = brand(\"OwnerIdBytes\", IdBytes);\n/** Converts {@link OwnerId} to {@link OwnerIdBytes}. */\nexport const ownerIdToOwnerIdBytes = (ownerId) => idToIdBytes(ownerId);\n/** Converts {@link OwnerIdBytes} to {@link OwnerId}. */\nexport const ownerIdBytesToOwnerId = (ownerIdBytes) => idBytesToId(ownerIdBytes);\nexport const ownerWriteKeyLength = NonNegativeInt.orThrow(16);\n/** Symmetric encryption key for {@link Owner} data protection. */\nexport const OwnerEncryptionKey = brand(\"OwnerEncryptionKey\", EncryptionKey);\n/**\n * A secure token for write operations. It's derived from {@link OwnerSecret} by\n * default and can be rotated via {@link createOwnerWriteKey}.\n */\nexport const OwnerWriteKey = brand(\"OwnerWriteKey\", Entropy16);\n/**\n * Creates a new random {@link OwnerWriteKey} for rotation.\n *\n * The initial OwnerWriteKey is deterministically derived from\n * {@link OwnerSecret}. Use `createOwnerWriteKey` to rotate (replace) the write\n * key without changing the owner identity.\n */\nexport const createOwnerWriteKey = (deps) => deps.randomBytes.create(16);\n/**\n * 32 bytes of cryptographic entropy used to derive {@link Owner} keys.\n *\n * Can be created using {@link createOwnerSecret} or converted from a\n * {@link Mnemonic} using {@link mnemonicToOwnerSecret}.\n */\nexport const OwnerSecret = brand(\"OwnerSecret\", Entropy32);\n/** Creates a {@link OwnerSecret}. */\nexport const createOwnerSecret = (deps) => deps.randomBytes.create(32);\n/** Converts an {@link OwnerSecret} to a {@link Mnemonic}. */\nexport const ownerSecretToMnemonic = (secret) => bip39.entropyToMnemonic(secret, wordlist);\n/** Converts a {@link Mnemonic} to an {@link OwnerSecret}. */\nexport const mnemonicToOwnerSecret = (mnemonic) => bip39.mnemonicToEntropy(mnemonic, wordlist);\n/**\n * Creates an {@link Owner} from a {@link OwnerSecret} using SLIP-21 key\n * derivation.\n */\nconst createOwner = (secret) => ({\n    id: ownerIdBytesToOwnerId(OwnerIdBytes.orThrow(createSlip21(secret, [\"Evolu\", \"OwnerIdBytes\"]).slice(0, 16))),\n    encryptionKey: OwnerEncryptionKey.orThrow(createSlip21(secret, [\"Evolu\", \"OwnerEncryptionKey\"])),\n    writeKey: OwnerWriteKey.orThrow(createSlip21(secret, [\"Evolu\", \"OwnerWriteKey\"]).slice(0, 16)),\n});\n/** Creates an {@link AppOwner} from an {@link OwnerSecret}. */\nexport const createAppOwner = (secret) => ({\n    ...createOwner(secret),\n    type: \"AppOwner\",\n    mnemonic: ownerSecretToMnemonic(secret),\n});\n/** Creates a {@link ShardOwner} from an {@link OwnerSecret}. */\nexport const createShardOwner = (secret) => {\n    return {\n        ...createOwner(secret),\n        type: \"ShardOwner\",\n    };\n};\n/**\n * Derives a {@link ShardOwner} from an {@link AppOwner} using the specified path.\n *\n * **Advantages of derived owners:**\n *\n * - **Deterministic**: Same path always produces the same ShardOwner across all\n *   devices\n * - **Immediate availability**: Can be hardcoded and used before sync occurs\n * - **Consistent setup**: All devices start with identical data structure\n * - **Lifecycle management**: Can implement epoch patterns for clean data\n *   deletion and recreation\n *\n * **Common patterns:**\n *\n * - Use paths like `[\"shard\", 1]` for versioned data lifecycle\n * - Use paths like `[\"project\", \"MyApp\", 1]` for named partitions with versions\n * - Each device can derive the same owners and set up initial structure\n */\nexport const deriveShardOwner = (owner, path) => {\n    const secret = createSlip21(owner.encryptionKey, path);\n    return {\n        ...createOwner(secret),\n        type: \"ShardOwner\",\n    };\n};\n/**\n * Creates a {@link SharedOwner} from an {@link OwnerSecret} for collaborative\n * write access.\n *\n * Use {@link createSharedReadonlyOwner} to create a read-only version for\n * sharing.\n */\nexport const createSharedOwner = (secret) => ({\n    ...createOwner(secret),\n    type: \"SharedOwner\",\n});\n/** Creates a {@link SharedReadonlyOwner} from a {@link SharedOwner}. */\nexport const createSharedReadonlyOwner = (sharedOwner) => ({\n    type: \"SharedReadonlyOwner\",\n    id: sharedOwner.id,\n    encryptionKey: sharedOwner.encryptionKey,\n});\n/**\n * Creates an {@link OwnerWebSocketTransport} for the given relay URL and\n * {@link OwnerId}.\n *\n * The URL must be a WebSocket base URL without query parameters or fragments\n * (e.g., `wss://relay.evolu.dev`, not `wss://relay.evolu.dev?foo=bar`). The\n * function appends the `ownerId` as a query parameter.\n *\n * ### Example\n *\n * ```ts\n * // Create transport \"wss://relay.evolu.dev?ownerId=...\"\n * const transport = createOwnerWebSocketTransport({\n *   url: \"wss://relay.evolu.dev\",\n *   ownerId: owner.id,\n * });\n *\n * // Use with createEvolu\n * const evolu = createEvolu(deps)(Schema, {\n *   transports: [transport],\n * });\n * ```\n */\nexport const createOwnerWebSocketTransport = (config) => ({\n    type: \"WebSocket\",\n    url: `${config.url}?ownerId=${config.ownerId}`,\n});\n/**\n * Extracts {@link OwnerId} from an {@link OwnerWebSocketTransport} URL query\n * string.\n *\n * Parses the query string `?ownerId=...` and validates that the extracted value\n * is a valid {@link OwnerId}.\n *\n * ### Example\n *\n * ```ts\n * parseOwnerIdFromOwnerWebSocketTransportUrl(\n *   \"/sync?ownerId=_12345678abcdefgh\",\n * );\n * // Returns: OwnerId or null\n * ```\n */\nexport const parseOwnerIdFromOwnerWebSocketTransportUrl = (url) => getOrNull(OwnerId.fromUnknown(url.split(\"=\")[1]));\n", "import { assertNonEmptyReadonlyArray } from \"./Assert.js\";\nimport { err, ok } from \"./Result.js\";\nimport { PositiveInt } from \"./Type.js\";\nexport const increment = (n) => n + 1;\nexport const decrement = (n) => n - 1;\n/** Clamps a number within a given range. */\nexport const clamp = (min, max) => (n) => Math.min(Math.max(n, min), max);\n/**\n * Creates a predicate that checks if a number is within a range, inclusive.\n *\n * ### Example\n *\n * ```ts\n * const isBetween10And20 = isBetween(10, 20);\n * console.log(isBetween10And20(15)); // true\n * console.log(isBetween10And20(25)); // false\n * ```\n */\nexport const isBetween = (min, max) => (value) => value >= min && value <= max;\n/** Returns the minimum value, preserving branded type if applicable. */\nexport const min = (...values) => values.reduce((a, b) => (a < b ? a : b));\n/** Returns the maximum value, preserving branded type if applicable. */\nexport const max = (...values) => values.reduce((a, b) => (a > b ? a : b));\n/**\n * Divides items into buckets as evenly as possible, ensuring each bucket has at\n * least the minimum number of items. Returns a success result if the minimum is\n * met, or an error result with the required number of items if not.\n *\n * ### Example\n *\n * ```ts\n * computeBalancedBuckets(10, 3, 2); // Returns ok([4, 7, 10])\n * computeBalancedBuckets(5, 3, 2); // Returns err(6)\n * ```\n */\nexport const computeBalancedBuckets = (numberOfItems, \n/** Default: 16 */\nnumberOfBuckets = PositiveInt.orThrow(16), \n/** Default: 2 */\nminNumberOfItemsPerBucket = PositiveInt.orThrow(2)) => {\n    const minRequiredItems = numberOfBuckets * minNumberOfItemsPerBucket;\n    if (numberOfItems < minRequiredItems)\n        return err(PositiveInt.orThrow(minRequiredItems));\n    const indexes = [];\n    const itemsPerBucket = Math.floor(numberOfItems / numberOfBuckets);\n    const extraItems = numberOfItems % numberOfBuckets;\n    let bucketBoundary = 0;\n    for (let i = 0; i < numberOfBuckets; i++) {\n        const hasExtraItem = i < extraItems;\n        const itemsInThisBucket = itemsPerBucket + (hasExtraItem ? 1 : 0);\n        bucketBoundary += itemsInThisBucket;\n        indexes.push(PositiveInt.orThrow(bucketBoundary));\n    }\n    assertNonEmptyReadonlyArray(indexes);\n    return ok(indexes);\n};\n", "import * as Kysely from \"kysely\";\nimport { createRecord, getProperty, mapObject, } from \"../Object.js\";\nimport { ok } from \"../Result.js\";\nimport { sql, SqliteBoolean, } from \"../Sqlite.js\";\nimport { array, DateIso, nullableToOptional, nullOr, object, omit, optional, record, set, String, validMutationSize, } from \"../Type.js\";\nimport { OwnerId } from \"./Owner.js\";\nimport { readonly } from \"../Function.js\";\nexport const evoluSchemaToDbSchema = (schema, indexesConfig) => {\n    const tables = mapObject(schema, (table) => new Set(Object.keys(table).filter((k) => k !== \"id\")));\n    const indexes = indexesConfig\n        ? indexesConfig(createIndex).map((index) => ({\n            name: index.toOperationNode().name.name,\n            sql: index.compile().sql,\n        }))\n        : [];\n    return { tables, indexes };\n};\n/**\n * System columns that are implicitly defined by Evolu.\n *\n * - `createdAt`: Set by Evolu on row creation, derived from {@link Timestamp}.\n * - `updatedAt`: Set by Evolu on every row change, derived from {@link Timestamp}.\n * - `isDeleted`: Soft delete flag created by Evolu and used by the developer to\n *   mark rows as deleted.\n * - `ownerId`: Represents ownership and logically partitions the database.\n */\nexport const SystemColumns = object({\n    createdAt: DateIso,\n    updatedAt: DateIso,\n    isDeleted: nullOr(SqliteBoolean),\n    ownerId: OwnerId,\n});\nexport const systemColumns = readonly(new Set(Object.keys(SystemColumns.props)));\nexport const systemColumnsWithId = readonly([...systemColumns, \"id\"]);\n/**\n * Type Factory to create insertable {@link Type}. It makes nullable Types\n * optional (so they are not required), omits Id, and ensures the\n * {@link maxMutationSize}.\n *\n * ### Example\n *\n * ```ts\n * const InsertableTodo = insertable(Schema.todo);\n * type InsertableTodo = typeof InsertableTodo.Type;\n * const todo = InsertableTodo.from({ title });\n * if (!todo.ok) return; // handle errors\n * ```\n */\nexport const insertable = (props) => {\n    const optionalNullable = nullableToOptional(props);\n    const withoutId = omit(optionalNullable, \"id\");\n    return validMutationSize(withoutId);\n};\n/**\n * Type Factory to create updateable {@link Type}. It makes everything except for\n * the `id` column optional (so they are not required) and ensures the\n * {@link maxMutationSize}.\n *\n * ### Example\n *\n * ```ts\n * const UpdateableTodo = updateable(Schema.todo);\n * type UpdateableTodo = typeof UpdateableTodo.Type;\n *\n * // `id` is required; all other fields are optional.\n * const todoResult = UpdateableTodo.from({\n *   id: \"123\",\n *   title: \"New Title\",\n * });\n * if (!todo.ok) return; // handle errors\n * ```\n */\nexport const updateable = (props) => {\n    const propsWithIsDeleted = { ...props, isDeleted: SqliteBoolean };\n    const updateableProps = mapObject(propsWithIsDeleted, (value, key) => key === \"id\" ? value : optional(value));\n    return validMutationSize(object(updateableProps));\n};\n/**\n * Type Factory to create an upsertable Type. It makes nullable Types optional\n * (so they are not required) and ensures the {@link maxMutationSize}.\n *\n * Upsert is like insert, except it requires an ID. It's useful for inserting\n * rows with external ID via {@link createIdFromString}.\n *\n * Note that it's not possible to upsert a row with `createdAt` nor `updatedAt`,\n * because they are derived from {@link CrdtMessage} timestamp. For external\n * createdAt, use a different column.\n *\n * ### Example\n *\n * ```ts\n * const UpsertableTodo = upsertable(Schema.todo);\n * type UpsertableTodo = typeof UpsertableTodo.Type;\n * const todo = UpsertableTodo.from({\n *   id,\n *   title,\n * });\n * if (!todo.ok) return; // handle errors\n * ```\n */\nexport const upsertable = (props) => {\n    const propsWithDefaults = {\n        ...props,\n        isDeleted: optional(SqliteBoolean),\n    };\n    return validMutationSize(nullableToOptional(propsWithDefaults));\n};\nexport const DbIndex = object({ name: String, sql: String });\nexport const DbSchema = object({\n    tables: record(String, set(String)),\n    indexes: array(DbIndex),\n});\n/** Get the current database schema by reading SQLite metadata. */\nexport const getDbSchema = (deps) => ({ allIndexes = false } = {}) => {\n    const tables = createRecord();\n    const tableAndColumnInfoRows = deps.sqlite.exec(sql `\n      select\n        sqlite_master.name as tableName,\n        table_info.name as columnName\n      from\n        sqlite_master\n        join pragma_table_info(sqlite_master.name) as table_info;\n    `);\n    if (!tableAndColumnInfoRows.ok)\n        return tableAndColumnInfoRows;\n    tableAndColumnInfoRows.value.rows.forEach((row) => {\n        const { tableName, columnName } = row;\n        (tables[tableName] ??= new Set()).add(columnName);\n    });\n    const indexesRows = deps.sqlite.exec(allIndexes\n        ? sql `\n            select name, sql\n            from sqlite_master\n            where type = 'index' and name not like 'sqlite_%';\n          `\n        : sql `\n            select name, sql\n            from sqlite_master\n            where\n              type = 'index'\n              and name not like 'sqlite_%'\n              and name not like 'evolu_%';\n          `);\n    if (!indexesRows.ok)\n        return indexesRows;\n    const indexes = indexesRows.value.rows.map((row) => ({\n        name: row.name,\n        /**\n         * SQLite returns \"CREATE INDEX\" for \"create index\" for some reason.\n         * Other keywords remain unchanged. We have to normalize the casing for\n         * {@link indexesAreEqual} manually.\n         */\n        sql: row.sql\n            .replace(\"CREATE INDEX\", \"create index\")\n            .replace(\"CREATE UNIQUE INDEX\", \"create unique index\"),\n    }));\n    return ok({ tables, indexes });\n};\nconst indexesAreEqual = (self, that) => self.name === that.name && self.sql === that.sql;\nexport const ensureDbSchema = (deps) => (newSchema, currentSchema) => {\n    const queries = [];\n    if (!currentSchema) {\n        const dbSchema = getDbSchema(deps)();\n        if (!dbSchema.ok)\n            return dbSchema;\n        currentSchema = dbSchema.value;\n    }\n    for (const [tableName, newColumns] of Object.entries(newSchema.tables)) {\n        const currentColumns = getProperty(currentSchema.tables, tableName);\n        if (!currentColumns) {\n            queries.push(createAppTable(tableName, newColumns));\n        }\n        else {\n            for (const newColumn of newColumns.difference(currentColumns)) {\n                queries.push(sql `\n            alter table ${sql.identifier(tableName)}\n            add column ${sql.identifier(newColumn)} any;\n          `);\n            }\n        }\n    }\n    // Remove current indexes that are not in the newSchema.\n    currentSchema.indexes\n        .filter((currentIndex) => !newSchema.indexes.some((newIndex) => indexesAreEqual(newIndex, currentIndex)))\n        .forEach((index) => {\n        queries.push(sql `drop index ${sql.identifier(index.name)};`);\n    });\n    // Add new indexes that are not in the currentSchema.\n    newSchema.indexes\n        .filter((newIndex) => !currentSchema.indexes.some((currentIndex) => indexesAreEqual(newIndex, currentIndex)))\n        .forEach((newIndex) => {\n        queries.push({ sql: `${newIndex.sql};`, parameters: [] });\n    });\n    for (const query of queries) {\n        const result = deps.sqlite.exec(query);\n        if (!result.ok)\n            return result;\n    }\n    return ok();\n};\nconst createAppTable = (tableName, columns) => sql `\n  create table ${sql.identifier(tableName)} (\n    \"id\" text,\n    ${sql.raw(`${[...systemColumns, ...columns]\n    // With strict tables and any type, data is preserved exactly as received\n    // without any type affinity coercion. This allows storing any data type\n    // while maintaining strict null enforcement for primary key columns.\n    // TODO: Use proper SQLite types for system columns (text for createdAt,\n    // updatedAt, ownerId, integer for isDeleted) instead of \"any\".\n    .map((name) => `${sql.identifier(name).sql} any`)\n    .join(\", \")}, `)}\n    primary key (\"ownerId\", \"id\")\n  )\n  without rowid, strict;\n`;\n// https://kysely.dev/docs/recipes/splitting-query-building-and-execution\nexport const kysely = new Kysely.Kysely({\n    dialect: {\n        createAdapter: () => new Kysely.SqliteAdapter(),\n        createDriver: () => new Kysely.DummyDriver(),\n        createIntrospector() {\n            throw new Error(\"Not implemeneted\");\n        },\n        createQueryCompiler: () => new Kysely.SqliteQueryCompiler(),\n    },\n});\nconst createIndex = kysely.schema.createIndex.bind(kysely.schema);\n", "/**\n * Creates an ordering function from a \"less than\" comparator.\n *\n * ### Example\n *\n * ```ts\n * const orderNumber = createOrder<number>((x, y) => x < y);\n * expect(orderNumber(1, 2)).toEqual(-1);\n * expect(orderNumber(2, 1)).toEqual(1);\n * expect(orderNumber(1, 1)).toEqual(0);\n * ```\n */\nexport const createOrder = (isLessThan) => (x, y) => x === y ? 0 : isLessThan(x, y) ? -1 : 1;\n/**\n * Returns an order that reverses the order of the given order.\n *\n * ### Example\n *\n * ```ts\n * reverseOrder(orderNumber)(1, 2); // 1\n * reverseOrder(orderNumber)(2, 1); // -1\n * reverseOrder(orderNumber)(1, 1); // 0\n * ```\n */\nexport const reverseOrder = (order) => (a, b) => order(b, a);\n/**\n * An order for `string` values in ascending order.\n *\n * ### Example\n *\n * ```ts\n * orderString(\"a\", \"b\"); // -1\n * orderString(\"b\", \"a\"); // 1\n * orderString(\"a\", \"a\"); // 0\n * [\"c\", \"b\", \"a\"].toSorted(orderString); // [\"a\", \"b\", \"c\"]\n * ```\n */\nexport const orderString = createOrder((a, b) => a < b);\n/**\n * An order for numbers in ascending order.\n *\n * ### Example\n *\n * ```ts\n * orderNumber(1, 2); // -1\n * orderNumber(2, 1); // 1\n * orderNumber(1, 1); // 0\n * [2, 1, 3].toSorted(orderNumber); // [1, 2, 3]\n * reverseOrder(orderNumber)(1, 2); // 1\n * reverseOrder(orderNumber)(2, 1); // -1\n * reverseOrder(orderNumber)(1, 1); // 0\n * ```\n */\nexport const orderNumber = createOrder((a, b) => a < b);\n/**\n * An order for bigints in ascending order.\n *\n * ### Example\n *\n * ```ts\n * orderBigInt(1n, 2n); // -1\n * orderBigInt(2n, 1n); // 1\n * orderBigInt(1n, 1n); // 0\n * [2n, 1n, 3n].toSorted(orderBigInt); // [1n, 2n, 3n]\n * ```\n */\nexport const orderBigInt = createOrder((a, b) => a < b);\n/** An {@link Order} for Uint8Array. */\nexport const orderUint8Array = (a, b) => {\n    if (a.byteLength > b.byteLength)\n        return 1;\n    if (a.byteLength < b.byteLength)\n        return -1;\n    for (let i = 0; i < a.byteLength; i++) {\n        if (a[i] < b[i])\n            return -1;\n        if (a[i] > b[i])\n            return 1;\n    }\n    return 0;\n};\n", "import { bytesToHex } from \"../Buffer.js\";\nimport { createEqObject, eqNumber, eqString } from \"../Eq.js\";\nimport { increment } from \"../Number.js\";\nimport { orderUint8Array } from \"../Order.js\";\nimport { err, ok } from \"../Result.js\";\nimport { brand, lessThanOrEqualTo, NonNegativeInt, object, regex, String, Uint8Array, } from \"../Type.js\";\n/**\n * Millis is a timestamp in milliseconds, like `Date.now()`, but limited to the\n * maximum value representable in 6 bytes (281474976710655) minus 1 (reserved\n * for infinity). This enables more efficient binary serialization, saving 2\n * bytes compared to the typical 8-byte (64-bit) timestamp representation.\n *\n * This limit is enforced to prevent data corruption. If a device's clock\n * exceeds this range, Evolu will stop saving data until the clock is\n * corrected.\n *\n * `new Date(281474976710654).toString()` = Tue Aug 02 10889 07:31:49\n */\nexport const Millis = brand(\"Millis\", lessThanOrEqualTo(281474976710655 - 1)(NonNegativeInt));\nexport const minMillis = 0;\nexport const maxMillis = (281474976710655 - 1);\nexport const Counter = brand(\"Counter\", lessThanOrEqualTo(65535)(NonNegativeInt));\nexport const minCounter = 0;\nexport const maxCounter = 65535;\n/**\n * A NodeId uniquely identifies an owner's device. Generated once per device\n * using cryptographic randomness.\n *\n * Collision probability (birthday paradox):\n *\n * - 1,000 devices: ~0.00000000000271% (negligible).\n * - 1M devices: ~0.00000271% (1 in 37M chance).\n * - 135M devices: ~1% chance.\n * - 4.29B devices: ~50% chance.\n *\n * https://lemire.me/blog/2019/12/12/are-64-bit-random-identifiers-free-from-collision\n *\n * What happens if different devices generate the same NodeId?\n *\n * If devices with the same NodeId use different owners, no issues occur.\n *\n * If devices with the same NodeId use the same owner, problems only arise when\n * they generate CRDT messages with identical timestamps (same millis, counter,\n * and NodeId). In this case, the protocol sync algorithm treats them as the\n * same message: the first will be synced with the relay, while the affected\n * message will not be delivered. The affected devices will see different data\n * yet they will think they are synced. This is extremely rare and can be\n * resolved by resetting one device to generate a new NodeId.\n */\nexport const NodeId = regex(\"NodeId\", /^[a-f0-9]{16}$/)(String);\nexport const minNodeId = \"0000000000000000\";\nexport const maxNodeId = \"ffffffffffffffff\";\n/**\n * Hybrid Logical Clock timestamp.\n *\n * Timestamps serve as globally unique, causally ordered identifiers for CRDT\n * messages in Evolu's sync protocol.\n *\n * ### Why Hybrid Logical Clocks\n *\n * Evolu uses Hybrid Logical Clocks (HLC), which combine physical time (millis)\n * with a logical counter. This hybrid approach preserves causality like logical\n * clocks while staying close to physical time for better human\n * interpretability.\n *\n * The counter component ensures causality is maintained even when physical\n * clocks are imperfect. When clocks drift or operations occur concurrently, the\n * counter increments to establish a total order. This means Evolu achieves\n * well-defined, eventually-consistent behavior regardless of physical clock\n * accuracy.\n *\n * Vector clocks can accurately track causality and detect concurrent\n * operations, but they require unbounded space in peer-to-peer systems and\n * crucially, still don't solve our fundamental problem: when they detect\n * operations as concurrent, we still need a deterministic way to choose a\n * winner. Additionally, any deterministic conflict resolution can be gamed by\n * malicious actors.\n *\n * HLC timestamps work well in practice because modern device clocks accurately\n * reflect the order of sequential edits in the common case. Evolu's `maxDrift`\n * configuration protects against buggy clocks and prevents problematic\n * future-dated entries from propagating through the network.\n *\n * ### References\n *\n * - https://muratbuffalo.blogspot.com/2014/07/hybrid-logical-clocks.html\n * - https://sergeiturukin.com/2017/06/26/hybrid-logical-clocks.html\n * - https://jaredforsyth.com/posts/hybrid-logical-clocks/\n * - https://willowprotocol.org/more/timestamps_really/index.html\n *\n * ### Privacy Considerations\n *\n * Timestamps are metadata visible to relays and collaborators. While it can be\n * considered a privacy leak, let us explain why it's necessary, and how to\n * avoid it if maximum privacy is required.\n *\n * With real-time communication, participants always see activity (receiving\n * bytes). We cannot trust anyone not to store that information, so explicitly\n * exposing timestamps doesn't add additional risk.\n *\n * If we really want not to leak user activity, we can implement a local write\n * queue:\n *\n * 1. Write changes immediately to a local-only table\n * 2. Periodically and randomly flush messages to sync tables\n *\n * **Trade-off:** It breaks real-time collaboration.\n */\nexport const Timestamp = object({\n    millis: Millis,\n    counter: Counter,\n    nodeId: NodeId,\n});\n/** Equality function for comparing {@link Timestamp}. */\nexport const eqTimestamp = createEqObject({\n    millis: eqNumber,\n    counter: eqNumber,\n    nodeId: eqString,\n});\nexport const createTimestamp = ({ millis = minMillis, counter = minCounter, nodeId = minNodeId, } = {}) => ({ millis, counter, nodeId });\nexport const createInitialTimestamp = (deps) => {\n    const nodeId = bytesToHex(deps.randomBytes.create(8));\n    return createTimestamp({ nodeId });\n};\nconst getNextMillis = (deps) => (millis) => {\n    const now = Millis.from(deps.time.now());\n    if (!now.ok) {\n        return err({ type: \"TimestampTimeOutOfRangeError\" });\n    }\n    const next = Math.max(now.value, ...millis);\n    return next - now.value > deps.timestampConfig.maxDrift\n        ? err({\n            type: \"TimestampDriftError\",\n            now: now.value,\n            next,\n        })\n        : ok(next);\n};\nconst incrementCounter = (counter) => {\n    const next = Counter.from(increment(counter));\n    if (!next.ok)\n        return err({ type: \"TimestampCounterOverflowError\" });\n    return ok(next.value);\n};\nexport const sendTimestamp = (deps) => (timestamp) => {\n    const millis = getNextMillis(deps)([timestamp.millis]);\n    if (!millis.ok)\n        return millis;\n    const counter = millis.value === timestamp.millis\n        ? incrementCounter(timestamp.counter)\n        : ok(minCounter);\n    if (!counter.ok)\n        return counter;\n    return ok({\n        millis: millis.value,\n        counter: counter.value,\n        nodeId: timestamp.nodeId,\n    });\n};\nexport const receiveTimestamp = (deps) => (local, remote) => {\n    const millis = getNextMillis(deps)([local.millis, remote.millis]);\n    if (!millis.ok)\n        return millis;\n    const counter = millis.value === local.millis && millis.value === remote.millis\n        ? incrementCounter(Math.max(local.counter, remote.counter))\n        : millis.value === local.millis\n            ? incrementCounter(local.counter)\n            : millis.value === remote.millis\n                ? incrementCounter(remote.counter)\n                : ok(minCounter);\n    if (!counter.ok)\n        return counter;\n    return ok({\n        millis: millis.value,\n        counter: counter.value,\n        nodeId: local.nodeId,\n    });\n};\n/** Sortable bytes representation of {@link Timestamp}. */\nexport const TimestampBytes = brand(\"TimestampBytes\", Uint8Array);\nexport const timestampBytesLength = NonNegativeInt.orThrow(16);\nexport const timestampToTimestampBytes = (timestamp) => {\n    const { millis, counter, nodeId } = timestamp;\n    // 6 bytes for millis, 2 bytes for counter, 8 bytes for nodeId.\n    const value = new globalThis.Uint8Array(16);\n    // Encode `millis` into the first 6 bytes.\n    const millisBigInt = BigInt(millis);\n    value[0] = Number((millisBigInt >> 40n) & 0xffn);\n    value[1] = Number((millisBigInt >> 32n) & 0xffn);\n    value[2] = Number((millisBigInt >> 24n) & 0xffn);\n    value[3] = Number((millisBigInt >> 16n) & 0xffn);\n    value[4] = Number((millisBigInt >> 8n) & 0xffn);\n    value[5] = Number(millisBigInt & 0xffn);\n    // Encode `counter` into the next 2 bytes.\n    value[6] = (counter >> 8) & 0xff;\n    value[7] = counter & 0xff;\n    // Encode `nodeId` (16-character hex string) into the next 8 bytes.\n    for (let i = 0; i < 8; i++) {\n        const byte = parseInt(nodeId.slice(i * 2, i * 2 + 2), 16);\n        value[8 + i] = byte;\n    }\n    return value;\n};\nexport const timestampBytesToTimestamp = (timestamp) => {\n    // Decode `millis` from the first 6 bytes.\n    const millis = (BigInt(timestamp[0]) << 40n) |\n        (BigInt(timestamp[1]) << 32n) |\n        (BigInt(timestamp[2]) << 24n) |\n        (BigInt(timestamp[3]) << 16n) |\n        (BigInt(timestamp[4]) << 8n) |\n        BigInt(timestamp[5]);\n    // Decode `counter` from the next 2 bytes.\n    const counter = (timestamp[6] << 8) | timestamp[7];\n    // Decode `nodeId` from the last 8 bytes.\n    let nodeId = \"\";\n    for (let i = 8; i < 16; i++) {\n        nodeId += timestamp[i].toString(16).padStart(2, \"0\");\n    }\n    return { millis: Number(millis), counter, nodeId };\n};\n/**\n * An {@link Order} for {@link TimestampBytes}.\n *\n * This `Order` uses lexicographic byte order to compare serialized\n * {@link TimestampBytes} produced by {@link timestampToTimestampBytes}. See\n * {@link orderUint8Array} for the underlying implementation.\n */\nexport const orderTimestampBytes = orderUint8Array;\n/**\n * Convert a {@link Timestamp} to an ISO 8601 {@link DateIso} string.\n *\n * The conversion uses the timestamp's `millis` (a {@link Millis} value) and\n * `Date.prototype.toISOString()` to produce a `DateIso`.\n */\nexport const timestampToDateIso = (timestamp) => \n// `as DateIso` is safe because Timestamp guarantees a valid `millis`\nnew Date(timestamp.millis).toISOString();\n", "import { sha256 } from \"@noble/hashes/sha2.js\";\nimport { firstInArray, isNonEmptyReadonlyArray, } from \"../Array.js\";\nimport { assert } from \"../Assert.js\";\nimport { concatBytes } from \"../Buffer.js\";\nimport { decrement } from \"../Number.js\";\nimport { err, ok } from \"../Result.js\";\nimport { sql, SqliteValue } from \"../Sqlite.js\";\nimport { Boolean, brand, Id, NonNegativeInt, nullOr, object, PositiveInt, record, String, } from \"../Type.js\";\nimport { systemColumnsWithId } from \"./Schema.js\";\nimport { orderTimestampBytes } from \"./Timestamp.js\";\nexport const fingerprintSize = NonNegativeInt.orThrow(12);\n/** A fingerprint of an empty range. */\nexport const zeroFingerprint = new Uint8Array(fingerprintSize);\nexport const InfiniteUpperBound = Symbol(\"InfiniteUpperBound\");\nexport const RangeType = {\n    Fingerprint: 1,\n    Skip: 0,\n    Timestamps: 2,\n};\nexport const DbChangeValues = record(String, SqliteValue);\nexport const ValidDbChangeValues = brand(\"ValidDbChangeValues\", DbChangeValues, (value) => {\n    const invalidColumns = systemColumnsWithId.filter((key) => key in value);\n    if (invalidColumns.length > 0)\n        return err({\n            type: \"ValidDbChangeValues\",\n            value,\n            invalidColumns,\n        });\n    return ok(value);\n});\n/**\n * A DbChange is a change to a table row. Together with a unique\n * {@link Timestamp}, it forms a {@link CrdtMessage}.\n */\nexport const DbChange = object({\n    table: String,\n    id: Id,\n    values: ValidDbChangeValues,\n    isInsert: Boolean,\n    isDelete: nullOr(Boolean),\n});\n/**\n * Creates a {@link BaseSqliteStorage} implementation.\n *\n * # Stateless Design\n *\n * This implementation is fully stateless - it requires no in-memory state\n * between invocations. All necessary metadata (timestamp bounds for insertion\n * strategy optimization) is persisted in the evolu_usage table. This makes\n * Evolu Relay suitable for stateless serverless environments like AWS Lambda,\n * Cloudflare Workers with Durable Objects, and other platforms where memory\n * doesn't persist between requests. While not extensively tested in all these\n * environments yet, the stateless design should work well across them.\n */\nexport const createBaseSqliteStorage = (deps) => (config) => {\n    return {\n        insertTimestamp: (ownerId, timestamp, strategy) => {\n            const level = randomSkiplistLevel(deps);\n            return insertTimestamp(deps)(ownerId, timestamp, level, strategy);\n        },\n        getExistingTimestamps: (ownerIdBytes, timestampsBytes) => {\n            const concatenatedTimestamps = concatBytes(...timestampsBytes);\n            const result = deps.sqlite.exec(sql `\n          with recursive\n            split_timestamps(timestampBytes, pos) as (\n              select\n                substr(${concatenatedTimestamps}, 1, 16),\n                17 as pos\n              union all\n              select\n                substr(${concatenatedTimestamps}, pos, 16),\n                pos + 16\n              from split_timestamps\n              where pos <= length(${concatenatedTimestamps})\n            )\n          select s.timestampBytes\n          from\n            split_timestamps s\n            join evolu_timestamp t\n              on t.ownerId = ${ownerIdBytes} and s.timestampBytes = t.t;\n        `);\n            if (!result.ok)\n                return result;\n            return ok(result.value.rows.map((row) => row.timestampBytes));\n        },\n        getSize: (ownerId) => {\n            const size = getSize(deps)(ownerId);\n            if (!size.ok) {\n                config.onStorageError(size.error);\n                return null;\n            }\n            return size.value;\n        },\n        fingerprint: (ownerId, begin, end) => {\n            assertBeginEnd(begin, end);\n            const result = fingerprint(deps)(ownerId, begin, end);\n            if (!result.ok) {\n                config.onStorageError(result.error);\n                return null;\n            }\n            return result.value;\n        },\n        fingerprintRanges: (ownerId, buckets, upperBound) => {\n            const ranges = fingerprintRanges(deps)(ownerId, buckets, upperBound);\n            if (!ranges.ok) {\n                config.onStorageError(ranges.error);\n                return null;\n            }\n            return ranges.value;\n        },\n        findLowerBound: (ownerId, begin, end, upperBound) => {\n            const lowerBound = findLowerBound(deps)(ownerId, begin, end, upperBound);\n            if (!lowerBound.ok) {\n                config.onStorageError(lowerBound.error);\n                return null;\n            }\n            return lowerBound.value;\n        },\n        iterate: (ownerId, begin, end, callback) => {\n            assertBeginEnd(begin, end);\n            const length = end - begin;\n            if (length === 0)\n                return;\n            // This is much faster than SQL limit with offset.\n            const first = getTimestampByIndex(deps)(ownerId, begin);\n            if (!first.ok) {\n                config.onStorageError(first.error);\n                return;\n            }\n            if (!callback(first.value, begin))\n                return;\n            if (length === 1)\n                return;\n            /**\n             * TODO: In rare cases, we might overfetch a lot of rows here, but we\n             * don't have real usage numbers yet. Fetching one row at a time would\n             * probably be slower in almost all cases. In the future, we should\n             * fetch in chunks (e.g., 1,000 rows at a time). For now, consider\n             * logging unused rows to gather data and calculate an average, then use\n             * that information to determine an optimal chunk size. Before\n             * implementing chunking, be sure to run performance tests (including\n             * fetching one by one).\n             */\n            const result = deps.sqlite.exec(sql `\n          select t\n          from evolu_timestamp\n          where ownerId = ${ownerId} and t > ${first.value}\n          order by t\n          limit ${length - 1};\n        `);\n            if (!result.ok) {\n                config.onStorageError(result.error);\n                return;\n            }\n            for (let i = 0; i < result.value.rows.length; i++) {\n                const index = NonNegativeInt.orThrow(begin + 1 + i);\n                if (!callback(result.value.rows[i].t, index))\n                    return;\n            }\n        },\n        deleteOwner: (ownerId) => {\n            const result = deps.sqlite.exec(sql `\n          delete from evolu_timestamp where ownerId = ${ownerId};\n        `);\n            if (!result.ok) {\n                config.onStorageError(result.error);\n                return false;\n            }\n            return true;\n        },\n    };\n};\nconst assertBeginEnd = (begin, end) => {\n    assert(begin <= end, \"invalid begin or end\");\n};\nexport const createBaseSqliteStorageTables = (deps) => {\n    for (const query of [\n        /**\n         * Creates the `evolu_timestamp` table for storing timestamps of multiple\n         * owners.\n         *\n         * All timestamps are stored in a single table using `ownerId` as part of\n         * the primary key. The table implements a Skiplist structure via the `l`\n         * (level) column for fast, scalable queries without the need for tree\n         * balancing.\n         *\n         * Columns:\n         *\n         * - `t`  TimestampBytes\n         * - `h1`/`h2`  12-byte fingerprint split into two integers for fast XOR\n         * - `c`  incremental count\n         * - `l`  Skiplist level (1 to 10)\n         */\n        sql `\n      create table evolu_timestamp (\n        \"ownerId\" blob not null,\n        \"t\" blob not null,\n        \"h1\" integer,\n        \"h2\" integer,\n        \"c\" integer,\n        \"l\" integer not null,\n        primary key (\"ownerId\", \"t\")\n      )\n      strict;\n    `,\n        sql `\n      create index evolu_timestamp_index on evolu_timestamp (\n        \"ownerId\",\n        \"l\",\n        \"t\",\n        \"h1\",\n        \"h2\",\n        \"c\"\n      );\n    `,\n        /**\n         * Creates the `evolu_usage` table for tracking data consumption per owner.\n         *\n         * Columns:\n         *\n         * - `ownerId`  OwnerIdBytes (primary key)\n         * - `storedBytes`  total bytes stored in database\n         * - `firstTimestamp`  for timestamp insertion strategies\n         * - `lastTimestamp`  for timestamp insertion strategies\n         */\n        sql `\n      create table evolu_usage (\n        \"ownerId\" blob primary key,\n        \"storedBytes\" integer not null,\n        \"firstTimestamp\" blob,\n        \"lastTimestamp\" blob\n      )\n      strict;\n    `,\n    ]) {\n        const result = deps.sqlite.exec(query);\n        if (!result.ok)\n            return result;\n    }\n    return ok();\n};\n/**\n * Determines the insertion strategy for a timestamp based on its position\n * relative to the current first and last timestamps.\n *\n * Returns a tuple with the strategy and updated timestamp bounds.\n */\nexport const getTimestampInsertStrategy = (timestamp, firstTimestamp, lastTimestamp) => {\n    if (orderTimestampBytes(timestamp, lastTimestamp) === 1) {\n        return [\"append\", firstTimestamp, timestamp];\n    }\n    if (orderTimestampBytes(timestamp, firstTimestamp) === -1) {\n        return [\"prepend\", timestamp, lastTimestamp];\n    }\n    return [\"insert\", firstTimestamp, lastTimestamp];\n};\n/**\n * AFAIK, we can't do both insert and update in one query, and that's probably\n * why append is 2x faster than insert. Prepend also has to update parents, but\n * it's constantly fast. Insert degrades for reversed (yet LIMIT X magically\n * fixes that) but it's OK for append.\n *\n * Note: SQL operations are idempotent (using `on conflict do nothing` and\n * `changes() > 0`), but this is no longer required here since we use\n * {@link BaseSqliteStorage.getExistingTimestamps} to filter out duplicates\n * before insertion, which we need for quota checks anyway.\n *\n * TODO: Remove idempotency (`on conflict do nothing` and `changes() > 0`) since\n * duplicates are now filtered before insertion.\n */\nconst insertTimestamp = (deps) => (ownerId, timestamp, level, strategy) => {\n    const [h1, h2] = fingerprintToSqliteFingerprint(timestampBytesToFingerprint(timestamp));\n    let queries = [];\n    switch (strategy) {\n        case \"append\":\n            queries = [\n                level === 1\n                    ? sql.prepared `\n                insert into evolu_timestamp\n                  (ownerId, l, t, h1, h2, c)\n                values\n                  (${ownerId}, 1, ${timestamp}, ${h1}, ${h2}, 1)\n                on conflict do nothing;\n              `\n                    : sql.prepared `\n                with\n                  fc(b, cl, pt, nt, ih1, ih2, ic) as (\n                    select\n                      0,\n                      (\n                        select max(l)\n                        from evolu_timestamp\n                        where ownerId = ${ownerId}\n                      ),\n                      zeroblob(0),\n                      null,\n                      0,\n                      0,\n                      0\n                    union all\n                    select\n                      not b,\n                      iif(b, iif(nt is null, cl - 1, cl), cl),\n                      iif(b, ifnull(nt, pt), pt),\n                      iif(\n                        b,\n                        null,\n                        (\n                          select t\n                          from evolu_timestamp\n                          where\n                            ownerId = ${ownerId}\n                            and l = cl\n                            and t > pt\n                            and t < ${timestamp}\n                          order by t\n                          limit 1\n                        )\n                      ),\n                      iif(\n                        b and cl < ${level} and nt is not null,\n                        (\n                          select (ih1 | h1) - (ih1 & h1)\n                          from evolu_timestamp\n                          where ownerId = ${ownerId} and t = nt\n                        ),\n                        ih1\n                      ),\n                      iif(\n                        b and cl < ${level} and nt is not null,\n                        (\n                          select (ih2 | h2) - (ih2 & h2)\n                          from evolu_timestamp\n                          where ownerId = ${ownerId} and t = nt\n                        ),\n                        ih2\n                      ),\n                      iif(\n                        b and cl < ${level} and nt is not null,\n                        (\n                          select ic + c\n                          from evolu_timestamp\n                          where ownerId = ${ownerId} and t = nt\n                        ),\n                        ic\n                      )\n                    from fc\n                    where cl > 0\n                  )\n                insert into evolu_timestamp (ownerId, t, l, h1, h2, c)\n                select\n                  ${ownerId},\n                  ${timestamp},\n                  ${level},\n                  (${h1} | ih1) - (${h1} & ih1),\n                  (${h2} | ih2) - (${h2} & ih2),\n                  ic + 1\n                from fc\n                order by cl asc\n                limit 1\n                on conflict do nothing;\n              `,\n            ];\n            break;\n        case \"prepend\":\n            queries = [\n                sql.prepared `\n            insert into evolu_timestamp\n              (ownerId, l, t, h1, h2, c)\n            values\n              (${ownerId}, ${level}, ${timestamp}, ${h1}, ${h2}, 1)\n            on conflict do nothing;\n          `,\n                sql.prepared `\n            with\n              ml(ml) as (\n                select max(l)\n                from evolu_timestamp\n                where ownerId = ${ownerId}\n              ),\n              fp(b, cl, pt, nt, h1, h2, c) as (\n                select\n                  0,\n                  (select ml from ml),\n                  null,\n                  null,\n                  null,\n                  null,\n                  null\n                union all\n                select\n                  not b,\n                  iif(b, cl - 1, cl),\n                  iif(\n                    b,\n                    iif(nt is not null and (pt is null or nt < pt), nt, pt),\n                    pt\n                  ),\n                  iif(\n                    b,\n                    null,\n                    (\n                      select t\n                      from evolu_timestamp\n                      where ownerId = ${ownerId} and l = cl and t > ${timestamp}\n                      order by t\n                      limit 1\n                    )\n                  ),\n                  iif(\n                    b and nt is not null and (pt is null or nt < pt),\n                    (\n                      select h1\n                      from evolu_timestamp\n                      where ownerId = ${ownerId} and t = nt\n                    ),\n                    null\n                  ),\n                  iif(\n                    b and nt is not null and (pt is null or nt < pt),\n                    (\n                      select h2\n                      from evolu_timestamp\n                      where ownerId = ${ownerId} and t = nt\n                    ),\n                    null\n                  ),\n                  iif(\n                    b and nt is not null and (pt is null or nt < pt),\n                    (\n                      select c\n                      from evolu_timestamp\n                      where ownerId = ${ownerId} and t = nt\n                    ),\n                    null\n                  )\n                from fp\n                where cl > ${level}\n              ),\n              u(t, h1, h2) as (\n                select\n                  pt,\n                  (${h1} | h1) - (${h1} & h1),\n                  (${h2} | h2) - (${h2} & h2)\n                from fp\n                where h1 is not null and pt is not null\n                order by pt\n                -- Check skiplistMaxLevel docs.\n                limit 10\n              )\n            update evolu_timestamp\n            set\n              h1 = u.h1,\n              h2 = u.h2,\n              c = c + 1\n            from u\n            where\n              changes() > 0\n              and ownerId = ${ownerId}\n              and evolu_timestamp.t = u.t;\n          `,\n            ];\n            break;\n        case \"insert\":\n            queries =\n                level === 1\n                    ? [\n                        sql.prepared `\n                  insert into evolu_timestamp\n                    (ownerId, l, t, h1, h2, c)\n                  values\n                    (${ownerId}, 1, ${timestamp}, ${h1}, ${h2}, 1)\n                  on conflict do nothing;\n                `,\n                        // DEV: Check whether a boolean flag is faster.\n                        sql.prepared `\n                  with\n                    p(l, t, h1, h2) as (\n                      select\n                        (\n                          select max(l) + 1\n                          from evolu_timestamp\n                          where ownerId = ${ownerId}\n                        ),\n                        null,\n                        null,\n                        null\n                      union all\n                      select\n                        p.l - 1,\n                        ifnull(\n                          (\n                            select t\n                            from evolu_timestamp\n                            where\n                              ownerId = ${ownerId}\n                              and l = p.l - 1\n                              and t > ${timestamp}\n                              and (p.t is null or p.t > t)\n                            order by t\n                            limit 1\n                          ),\n                          p.t\n                        ),\n                        (\n                          select h1\n                          from evolu_timestamp\n                          where\n                            ownerId = ${ownerId}\n                            and l = p.l - 1\n                            and t > ${timestamp}\n                            and (p.t is null or p.t > t)\n                          order by t\n                          limit 1\n                        ),\n                        (\n                          select h2\n                          from evolu_timestamp\n                          where\n                            ownerId = ${ownerId}\n                            and l = p.l - 1\n                            and t > ${timestamp}\n                            and (p.t is null or p.t > t)\n                          order by t\n                          limit 1\n                        )\n                      from p\n                      where p.l > 2\n                      -- Check skiplistMaxLevel docs.\n                      limit 10\n                    ),\n                    u(t, h1, h2) as (\n                      select\n                        t,\n                        (${h1} | h1) - (${h1} & h1),\n                        (${h2} | h2) - (${h2} & h2)\n                      from p\n                      where h1 is not null\n                    )\n                  update evolu_timestamp\n                  set\n                    h1 = u.h1,\n                    h2 = u.h2,\n                    c = c + 1\n                  from u\n                  where\n                    changes() > 0\n                    and ownerId = ${ownerId}\n                    and evolu_timestamp.t = u.t;\n                `,\n                    ]\n                    : [\n                        sql.prepared `\n                  insert into evolu_timestamp (ownerId, t, l)\n                  values (${ownerId}, ${timestamp}, ${level})\n                  on conflict do nothing;\n                `,\n                        sql.prepared `\n                  with\n                    c0(b, cl, pt, nt, h1, h2, c) as (\n                      select\n                        0,\n                        (\n                          select max(l)\n                          from evolu_timestamp\n                          where ownerId = ${ownerId}\n                        ),\n                        0,\n                        null,\n                        null,\n                        null,\n                        null\n                      union all\n                      select\n                        not b,\n                        iif(b, iif(nt is null, cl - 1, cl), cl),\n                        iif(b, ifnull(nt, pt), pt),\n                        iif(\n                          b,\n                          null,\n                          (\n                            select t\n                            from evolu_timestamp\n                            where\n                              ownerId = ${ownerId}\n                              and l = cl\n                              and t > pt\n                              and t < ${timestamp}\n                            order by t\n                            limit 1\n                          )\n                        ),\n                        iif(\n                          b and cl < ${level} and nt is not null,\n                          (\n                            select h1\n                            from evolu_timestamp\n                            where ownerId = ${ownerId} and t = nt\n                          ),\n                          null\n                        ),\n                        iif(\n                          b and cl < ${level} and nt is not null,\n                          (\n                            select h2\n                            from evolu_timestamp\n                            where ownerId = ${ownerId} and t = nt\n                          ),\n                          null\n                        ),\n                        iif(\n                          b and cl < ${level} and nt is not null,\n                          (\n                            select c\n                            from evolu_timestamp\n                            where ownerId = ${ownerId} and t = nt\n                          ),\n                          null\n                        )\n                      from c0\n                      where cl > 0\n                    ),\n                    c1(l, t, h1, h2, c) as (\n                      select\n                        ${level},\n                        ${timestamp},\n                        ${h1},\n                        ${h2},\n                        1\n                      union all\n                      select cl, pt, h1, h2, c\n                      from c0\n                      where h1 is not null\n                    ),\n                    c2(rn, l, t, h1, h2, c) as (\n                      select row_number() over (order by l), l, t, h1, h2, c\n                      from c1\n                    ),\n                    c3(rn, l, t, h1, h2, c) as (\n                      select rn, l, t, h1, h2, c from c2 where rn = 1\n                      union all\n                      select\n                        c3.rn + 1,\n                        c2.l,\n                        c2.t,\n                        (c2.h1 | c3.h1) - (c2.h1 & c3.h1),\n                        (c2.h2 | c3.h2) - (c2.h2 & c3.h2),\n                        c2.c + c3.c\n                      from\n                        c3\n                        join c2 on c2.rn = c3.rn + 1\n                    ),\n                    c4(l, t, h1, h2, c, rn) as (\n                      select l, t, h1, h2, c, max(rn)\n                      from c3\n                      group by l\n                    ),\n                    -- DEV: Check whether a boolean flag is faster.\n                    n(l, t, h1, h2, c) as (\n                      select\n                        (\n                          select max(l) + 1\n                          from evolu_timestamp\n                          where ownerId = ${ownerId}\n                        ),\n                        null,\n                        null,\n                        null,\n                        null\n                      union all\n                      select\n                        n.l - 1,\n                        ifnull(\n                          (\n                            select t\n                            from evolu_timestamp\n                            where\n                              ownerId = ${ownerId}\n                              and l = n.l - 1\n                              and t > ${timestamp}\n                              and (n.t is null or t < n.t)\n                            order by t\n                            limit 1\n                          ),\n                          n.t\n                        ),\n                        (\n                          select h1\n                          from evolu_timestamp\n                          where\n                            ownerId = ${ownerId}\n                            and l = n.l - 1\n                            and t > ${timestamp}\n                            and (n.t is null or t < n.t)\n                          order by t\n                          limit 1\n                        ),\n                        (\n                          select h2\n                          from evolu_timestamp\n                          where\n                            ownerId = ${ownerId}\n                            and l = n.l - 1\n                            and t > ${timestamp}\n                            and (n.t is null or t < n.t)\n                          order by t\n                          limit 1\n                        ),\n                        (\n                          select c\n                          from evolu_timestamp\n                          where\n                            ownerId = ${ownerId}\n                            and l = n.l - 1\n                            and t > ${timestamp}\n                            and (n.t is null or t < n.t)\n                          order by t\n                          limit 1\n                        )\n                      from n\n                      where l - 1 > (select min(l) from c4)\n                    ),\n                    u(ut, uh1, uh2, uc) as (\n                      select t, h1, h2, c from c4 where t = ${timestamp}\n                      union all\n                      select\n                        max(t),\n                        iif(\n                          l > ${level},\n                          (${h1} | h1) - (${h1} & h1),\n                          (\n                            select (c4.h1 | n.h1) - (c4.h1 & n.h1)\n                            from c4\n                            where\n                              c4.l = (select max(l) from c4 where c4.l < n.l)\n                          )\n                        ),\n                        iif(\n                          l > ${level},\n                          (${h2} | h2) - (${h2} & h2),\n                          (\n                            select (c4.h2 | n.h2) - (c4.h2 & n.h2)\n                            from c4\n                            where\n                              c4.l = (select max(l) from c4 where c4.l < n.l)\n                          )\n                        ),\n                        iif(\n                          l > ${level},\n                          c + 1,\n                          (\n                            select n.c - c4.c\n                            from c4\n                            where\n                              c4.l = (select max(l) from c4 where c4.l < n.l)\n                          )\n                        )\n                      from n\n                      group by t\n                      -- Check skiplistMaxLevel docs.\n                      limit 10\n                    )\n                  update evolu_timestamp\n                  set\n                    h1 = uh1,\n                    h2 = uh2,\n                    c = uc\n                  from u\n                  where changes() > 0 and ownerId = ${ownerId} and t = ut;\n                `,\n                    ];\n            break;\n    }\n    for (const query of queries) {\n        const result = deps.sqlite.exec(query);\n        if (!result.ok)\n            return result;\n    }\n    return ok();\n};\nexport const timestampBytesToFingerprint = (timestamp) => {\n    const hash = sha256(timestamp).slice(0, fingerprintSize);\n    return hash;\n};\n/**\n * Generates a random skiplist level in the range [1, skiplistMaxLevel].\n * Probabilistic approach avoids the need for explicit tree balancing.\n */\nconst randomSkiplistLevel = (deps) => {\n    let level = 1;\n    while (deps.random.next() <= skiplistProbability &&\n        level < skiplistMaxLevel) {\n        level += 1;\n    }\n    return PositiveInt.orThrow(level);\n};\n/**\n * Probability used for generating Skiplist levels.\n *\n * 0.5 is little faster for the first 30k.\n */\nconst skiplistProbability = 0.25;\n/**\n * The SQLite has weird behaviour when we have to limit CTEs even when we don't\n * actually limit anything; otherwise, it would not work. But without it, SQLite\n * insert and prepend is slow. The 10 is the maximum allowed number, which\n * \"fixes\" SQLite.\n *\n * Because we are using {@link skiplistProbability} 0.25, it's OK even for\n * millions of rows.\n */\nconst skiplistMaxLevel = 10;\nconst fingerprintToSqliteFingerprint = (fingerprint) => {\n    let part1 = BigInt(0);\n    let part2 = BigInt(0);\n    for (let i = 0; i < 6; i++) {\n        part1 = (part1 << BigInt(8)) | BigInt(fingerprint[i]);\n    }\n    for (let i = 6; i < 12; i++) {\n        part2 = (part2 << BigInt(8)) | BigInt(fingerprint[i]);\n    }\n    return [part1.toString(), part2.toString()];\n};\nconst sqliteFingerprintToFingerprint = ([part1String, part2String,]) => {\n    let part1 = BigInt(part1String);\n    let part2 = BigInt(part2String);\n    const hash = new Uint8Array(12);\n    for (let i = 5; i >= 0; i--) {\n        hash[i] = Number(part1 & BigInt(0xff));\n        part1 >>= BigInt(8);\n    }\n    for (let i = 11; i >= 6; i--) {\n        hash[i] = Number(part2 & BigInt(0xff));\n        part2 >>= BigInt(8);\n    }\n    return hash;\n};\nconst getSize = (deps) => (ownerId) => {\n    const result = deps.sqlite.exec(sql.prepared `\n      with\n        ml(ml) as (\n          select max(l)\n          from evolu_timestamp\n          where ownerId = ${ownerId}\n        ),\n        sc(l, pt, c) as (\n          select (select ml + 1 from ml), zeroblob(0), 0\n          union all\n          select\n            sc.l - 1,\n            ifnull(\n              (\n                select max(t)\n                from evolu_timestamp as m\n                where ownerId = ${ownerId} and m.l = sc.l - 1 and m.t > sc.pt\n              ),\n              sc.pt\n            ),\n            ifnull(\n              (\n                select sum(m.c)\n                from evolu_timestamp as m\n                where ownerId = ${ownerId} and m.l = sc.l - 1 and m.t > sc.pt\n              ),\n              0\n            )\n          from sc\n          where sc.l > 1\n        )\n      select sum(c) as size\n      from sc;\n    `);\n    if (!result.ok)\n        return result;\n    return ok(result.value.rows[0].size);\n};\nconst findLowerBound = (deps) => (ownerId, begin, end, upperBound) => {\n    assertBeginEnd(begin, end);\n    if (end === 0 || begin === end || upperBound === InfiniteUpperBound) {\n        return ok(end);\n    }\n    const result = deps.sqlite.exec(sql.prepared `\n      select t\n      from evolu_timestamp\n      where ownerId = ${ownerId} and t >= ${upperBound}\n      order by t\n      limit 1;\n    `);\n    if (!result.ok)\n        return result;\n    if (result.value.rows.length === 0) {\n        return ok(end);\n    }\n    const count = getTimestampCount(deps)(ownerId, result.value.rows[0].t);\n    if (!count.ok)\n        return count;\n    // `decrement` converts a count to an index.\n    return ok(NonNegativeInt.orThrow(decrement(count.value)));\n};\nconst getTimestampCount = (deps) => (ownerId, timestamp) => {\n    const result = deps.sqlite.exec(sql.prepared `\n      with\n        ml(ml) as (\n          select max(l) from evolu_timestamp where ownerId = ${ownerId}\n        ),\n        sc(l, pt, tc) as (\n          select ml + 1, zeroblob(0), 0 from ml\n          union all\n          select\n            sc.l - 1,\n            ifnull(\n              (\n                select max(t)\n                from evolu_timestamp\n                where\n                  ownerId = ${ownerId}\n                  and l = sc.l - 1\n                  and t <= ${timestamp}\n                  and t > sc.pt\n                order by t\n              ),\n              sc.pt\n            ),\n            ifnull(\n              (\n                select sum(c)\n                from evolu_timestamp\n                where\n                  ownerId = ${ownerId}\n                  and l = sc.l - 1\n                  and t <= ${timestamp}\n                  and t > sc.pt\n              ),\n              0\n            )\n          from sc\n          where sc.l > 1 and sc.pt != ${timestamp}\n        )\n      select sum(tc) as count\n      from sc;\n    `);\n    if (!result.ok)\n        return result;\n    return ok(result.value.rows[0].count);\n};\n/**\n * TODO: We reuse {@link fingerprintRanges}, which returns upper bound, which we\n * don't need, so fingerprintRanges should have a parameter for that.\n */\nconst fingerprint = (deps) => (ownerId, begin, end) => {\n    // There is no need to fingerprint an empty range.\n    if (end - begin === 0) {\n        return ok(zeroFingerprint);\n    }\n    if (begin === 0) {\n        const result = fingerprintRanges(deps)(ownerId, [end]);\n        if (!result.ok)\n            return result;\n        return ok(result.value[0].fingerprint);\n    }\n    // We should have a param to skip the first result.\n    const result = fingerprintRanges(deps)(ownerId, [begin, end]);\n    if (!result.ok)\n        return result;\n    return ok(result.value[1].fingerprint);\n};\n/**\n * First, check this: https://logperiodic.com/rbsr.html#tree-friendly-functions\n *\n * We are a little smarter. We leverage continuous ranges to have half of\n * traversals. 16 instead of 32. And we compute all of them in a single SQL\n * select. If only we could get rid of those subqueries. Then, it would be\n * perfect. Btw, reading h1, h2, c in the second step would be slighly faster.\n */\nconst fingerprintRanges = (deps) => (ownerId, buckets, upperBound = InfiniteUpperBound) => {\n    const bucketsJson = JSON.stringify(buckets);\n    const result = deps.sqlite.exec(sql.prepared `\n      with\n        ml(ml) as (\n          select max(l) from evolu_timestamp where ownerId = ${ownerId}\n        ),\n        c0(c) as (select value as c from json_each(${bucketsJson})),\n        c1(c, b, nt, nc, nh1, nh2, ft, tt, dl, ic, h1, h2) as (\n          select\n            c,\n            1,\n            null,\n            null,\n            null,\n            null,\n            zeroblob(0),\n            X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',\n            ml,\n            0,\n            0,\n            0\n          from\n            c0,\n            ml\n          union all\n          select\n            c,\n            not b,\n            iif(\n              b,\n              (\n                select t\n                from evolu_timestamp\n                where l = dl and t > ft and t < tt and ownerId = ${ownerId}\n                order by t\n                limit 1\n              ),\n              null\n            ),\n            iif(\n              b,\n              (\n                select c\n                from evolu_timestamp\n                where l = dl and t > ft and t < tt and ownerId = ${ownerId}\n                order by t\n                limit 1\n              ),\n              null\n            ),\n            iif(\n              b,\n              (\n                select h1\n                from evolu_timestamp\n                where l = dl and t > ft and t < tt and ownerId = ${ownerId}\n                order by t\n                limit 1\n              ),\n              null\n            ),\n            iif(\n              b,\n              (\n                select h2\n                from evolu_timestamp\n                where l = dl and t > ft and t < tt and ownerId = ${ownerId}\n                order by t\n                limit 1\n              ),\n              null\n            ),\n            iif(b, ft, iif(ic + nc <= c, nt, ft)),\n            iif(b, tt, iif(ic + nc <= c, tt, ifnull(nt, tt))),\n            iif(b, dl, iif(ic + nc <= c, dl, dl - 1)),\n            iif(b, ic, iif(ic + nc <= c, ic + nc, ic)),\n            iif(b, h1, iif(ic + nc <= c, ${x(\"h1\", \"nh1\")}, h1)),\n            iif(b, h2, iif(ic + nc <= c, ${x(\"h2\", \"nh2\")}, h2))\n          from c1\n          where iif(b, 1, ic != c)\n        ),\n        c2(h1, h2, t, rn) as (\n          select\n            h1,\n            h2,\n            (\n              select min(t)\n              from evolu_timestamp\n              where t > ft and ownerId = ${ownerId}\n            ),\n            row_number() over (order by c)\n          from c1\n          where c = ic and b = 1\n        ),\n        c3(oh1, oh2, b, rn, h1, h2) as (\n          select h1, h2, t, rn, h1, h2 from c2 where rn = 1\n          union all\n          select\n            c2.h1,\n            c2.h2,\n            t,\n            c2.rn,\n            ${x(\"c3.oh1\", \"c2.h1\")},\n            ${x(\"c3.oh2\", \"c2.h2\")}\n          from\n            c2\n            join c3 on c2.rn = c3.rn + 1\n        )\n      select b, cast(h1 as text) as h1, cast(h2 as text) as h2\n      from c3;\n    `);\n    if (!result.ok)\n        return result;\n    const fingerprintRanges = result.value.rows.map((row, i, arr) => ({\n        type: RangeType.Fingerprint,\n        upperBound: i === arr.length - 1 ? upperBound : row.b,\n        fingerprint: sqliteFingerprintToFingerprint([\n            row.h1,\n            row.h2,\n        ]),\n    }));\n    return ok(fingerprintRanges);\n};\n// XOR in SQLite\nconst x = (a, b) => sql.raw(`(${a} | ${b}) - (${a} & ${b})`);\nexport const getTimestampByIndex = (deps) => (ownerId, index) => {\n    const result = deps.sqlite.exec(sql.prepared `\n      with\n        fi(b, cl, ic, pt, mt, nt, nc) as (\n          select\n            0,\n            (\n              select max(l)\n              from evolu_timestamp\n              where ownerId = ${ownerId}\n            ),\n            0,\n            zeroblob(0),\n            X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',\n            null,\n            0\n          union all\n          select\n            not b,\n            iif(\n              b,\n              iif(nt is null or nt > mt or ic + nc > ${index + 1}, cl - 1, cl),\n              cl\n            ),\n            iif(\n              b,\n              iif(nt is null or nt > mt or ic + nc > ${index + 1}, ic, ic + nc),\n              ic\n            ),\n            iif(\n              b,\n              iif(nt is null or nt > mt or ic + nc > ${index + 1}, pt, nt),\n              pt\n            ),\n            iif(\n              b,\n              iif(\n                nt is null or nt > mt or ic + nc > ${index + 1},\n                iif(nt is not null and nt < mt, nt, mt),\n                mt\n              ),\n              mt\n            ),\n            iif(\n              b,\n              null,\n              (\n                select t\n                from evolu_timestamp\n                where ownerId = ${ownerId} and l = cl and t > pt\n                order by t\n                limit 1\n              )\n            ),\n            iif(\n              b,\n              null,\n              (\n                select c\n                from evolu_timestamp\n                where ownerId = ${ownerId} and l = cl and t > pt\n                order by t\n                limit 1\n              )\n            )\n          from fi\n          where ic != ${index + 1}\n        )\n      select pt\n      from fi\n      where ic == ${index + 1};\n    `);\n    if (!result.ok)\n        return result;\n    return ok(result.value.rows[0].pt);\n};\n/** Retrieves usage information for an owner from the evolu_usage table. */\nexport const getOwnerUsage = (deps) => (ownerIdBytes, initialTimestamp) => {\n    const result = deps.sqlite.exec(sql `\n      select storedBytes, firstTimestamp, lastTimestamp\n      from evolu_usage\n      where ownerId = ${ownerIdBytes};\n    `);\n    if (!result.ok)\n        return result;\n    if (!isNonEmptyReadonlyArray(result.value.rows)) {\n        return ok({\n            storedBytes: null,\n            firstTimestamp: initialTimestamp,\n            lastTimestamp: initialTimestamp,\n        });\n    }\n    const row = firstInArray(result.value.rows);\n    assert(row.firstTimestamp, \"not null\");\n    assert(row.lastTimestamp, \"not null\");\n    return ok({\n        storedBytes: row.storedBytes,\n        firstTimestamp: row.firstTimestamp,\n        lastTimestamp: row.lastTimestamp,\n    });\n};\n/**\n * Updates timestamp bounds in evolu_usage table.\n *\n * Used by both relay and client to maintain firstTimestamp/lastTimestamp after\n * processing messages.\n */\nexport const updateOwnerUsage = (deps) => (ownerIdBytes, storedBytes, firstTimestamp, lastTimestamp) => {\n    const result = deps.sqlite.exec(sql `\n      insert into evolu_usage\n        (\"ownerId\", \"storedBytes\", \"firstTimestamp\", \"lastTimestamp\")\n      values\n        (${ownerIdBytes}, ${storedBytes}, ${firstTimestamp}, ${lastTimestamp})\n      on conflict (ownerId) do update\n        set\n          storedBytes = ${storedBytes},\n          firstTimestamp = ${firstTimestamp},\n          lastTimestamp = ${lastTimestamp};\n    `);\n    if (!result.ok)\n        return result;\n    return ok();\n};\n", "/**\n * Evolu Protocol\n *\n * Evolu Protocol is a local-first, end-to-end encrypted binary synchronization\n * protocol optimized for minimal size and maximum speed. It enables data sync\n * between a client and a relay. In the future, direct peer-to-peer (P2P) sync\n * between clients will be possible without a relay.\n *\n * Relays don't need to sync with each otherclients using those relays will\n * sync them eventually. If a relay is offline (e.g., for maintenance), it will\n * sync automatically later via client sync logic. For relay backup using\n * SQLite, see https://sqlite.org/rsync.html (uses a similar algorithm to Evolu\n * RBSR).\n *\n * Evolu Protocol is designed for SQLite but can be extended to any database. It\n * implements [Range-Based Set\n * Reconciliation](https://arxiv.org/abs/2212.13567). To learn how RBSR works,\n * check [Negentropy](https://logperiodic.com/rbsr.html). Evolu Protocol is\n * similar to Negentropy but uses different encoding and also provides data\n * transfer, ownership, real-time broadcasting, request-response semantics, and\n * error handling.\n *\n * ### Message structure\n *\n * | Field                          | Notes                     |\n * | :----------------------------- | :------------------------ |\n * | **Header**                     |                           |\n * | - {@link protocolVersion}      |                           |\n * | - {@link OwnerId}              | {@link Owner}             |\n * | - messageType                  | {@link MessageType}       |\n * | **Request (messageType=0)**    |                           |\n * | - hasWriteKey                  | 0 = no, 1 = yes           |\n * | - {@link OwnerWriteKey}        | If hasWriteKey = 1        |\n * | - subscriptionFlag             | {@link SubscriptionFlags} |\n * | **Response (messageType=1)**   |                           |\n * | - {@link ProtocolErrorCode}    |                           |\n * | **Broadcast (messageType=2)**  |                           |\n * | - (no additional fields)       |                           |\n * | **Messages**                   |                           |\n * | - {@link NonNegativeInt}       | A number of messages.     |\n * | - {@link EncryptedCrdtMessage} |                           |\n * | **Ranges**                     |                           |\n * | - {@link NonNegativeInt}       | Number of ranges.         |\n * | - {@link Range}                |                           |\n *\n * ### WriteKey validation\n *\n * The initiator sends a hasWriteKey flag and optionally a WriteKey. The\n * WriteKey is required when sending messages as a secure token proving the\n * initiator can write changes. It's ok to not send a WriteKey if the initiator\n * is only syncing (read-only) and not sending messages. The non-initiator\n * validates the WriteKey immediately after parsing the initiator header, before\n * processing any messages or ranges.\n *\n * ### Synchronization\n *\n * - **Messages**: Sends {@link EncryptedCrdtMessage}s in either direction.\n * - **Ranges**: Determines messages to sync. Usage varies by transporte.g., sent\n *   only on WebSocket connection open or with every fetch request.\n *\n * Synchronization involves an initiator and a non-initiator. The **initiator**\n * is typically a client, and the **non-initiator** is typically a relay. Each\n * side processes the received message and responds with a new `ProtocolMessage`\n * if further sync is needed or possible, continuing until both sides are\n * synchronized.\n *\n * The **non-initiator always responds** to provide sync completion feedback,\n * even with empty messages containing only the header and no error. This allows\n * the initiator to detect when synchronization is complete.\n *\n * Both **Messages** and **Ranges** are optional, allowing each side to send,\n * sync, or only subscribe data as needed.\n *\n * When the initiator sends data, the {@link OwnerWriteKey} is required as a\n * secure token proving the initiator can write changes. The non-initiator\n * responds without a {@link OwnerWriteKey}, since the initiators request\n * already signals it wants data. If the non-initiator detects an issue, it\n * sends an error code via the `Error` field in the header back to the\n * initiator. In relay-to-relay or P2P sync, both sides may require the\n * {@link OwnerWriteKey} depending on who is the initiator.\n *\n * ### Protocol errors\n *\n * The protocol uses error codes in the header to signal issues:\n *\n * - {@link ProtocolWriteKeyError}: The provided WriteKey is invalid or missing.\n * - {@link ProtocolWriteError}: A serious relay-side write failure occurred.\n * - {@link ProtocolQuotaError}: Storage or billing quota exceeded.\n * - {@link ProtocolSyncError}: A serious relay-side synchronization failure\n *   occurred.\n * - {@link ProtocolVersionError}: Protocol version mismatch.\n * - {@link ProtocolInvalidDataError}: The message is malformed or corrupted.\n *\n * All protocol errors except `ProtocolInvalidDataError` include the `OwnerId`\n * to allow clients to associate errors with the correct owner.\n *\n * ### Message size limit\n *\n * The protocol enforces a strict maximum size for all messages, defined by\n * {@link ProtocolMessageMaxSize}. This ensures every {@link ProtocolMessage} is\n * less than or equal to this limit, enabling stateless transports, simplified\n * relay implementation, and predictable memory usage. When all messages don't\n * fit within the limit, the protocol automatically continues synchronization in\n * subsequent rounds using range-based reconciliation.\n *\n * Database mutations are limited to 640KB, which is smaller than the protocol\n * message limit to ensure efficient sync with\n * {@link defaultProtocolMessageRangesMaxSize}.\n *\n * ### Why Binary?\n *\n * The protocol avoids JSON because:\n *\n * - Encrypted data doesnt compress well, unlike plain JSON.\n * - Message size must be controlled during creation.\n * - Sequential byte reading is faster than parsing and avoids conversions.\n *\n * It uses structure-aware encoding, significantly outperforming generic binary\n * serialization formats with the following optimizations:\n *\n * - **NonNegativeInt:** Up to 33% smaller than MessagePack.\n * - **DateIso:** Up to 75% smaller.\n * - **Timestamp Encoding:** Delta encoding for milliseconds and run-length\n *   encoding (RLE) for counters and NodeIds.\n * - **Small Integers (0 to 19):** Reduces size by 1 byte per integer.\n *\n * To avoid reinventing serialization where its unnecessarylike for JSON and\n * certain numbersthe Evolu Protocol relies on MessagePack.\n *\n * ### Versioning\n *\n * Evolu Protocol uses explicit versioning to ensure compatibility between\n * clients and relays (or peers). Each protocol message begins with a version\n * number and an `ownerId` in its header.\n *\n * **How version negotiation works:**\n *\n * - The initiator (usually a client) sends a `ProtocolMessage` that includes its\n *   protocol version and the `ownerId`.\n * - The non-initiator (usually a relay or peer) checks the version.\n *\n *   - If the versions match, synchronization proceeds as normal.\n *   - If the versions do not match, the non-initiator responds with a message\n *       containing **its own protocol version and the same `ownerId`**.\n * - The initiator can then detect the version mismatch for that specific owner\n *   and handle it appropriately (e.g., prompt for an update or halt sync).\n *\n * Version negotiation is per-owner, allowing Evolu Protocol to evolve safely\n * over time and provide clear feedback about version mismatches.\n *\n * ### Credible exit\n *\n * The protocol specification is intentionally non-configurable to ensure\n * universal compatibility. This design allows applications (users) to switch\n * between any compliant relay without negotiation or compatibility checks\n * beyond version matching. Relays are generic infrastructure that any\n * application can use interchangeably making exit from any single provider\n * technically feasible and economically viable.\n *\n * @module\n */\n/**\n * TODO:\n *\n * - The client-relay naming convention in functions like\n *   `applyProtocolMessageAsClient` and `applyProtocolMessageAsRelay` is not\n *   ideal. In the future, clients will be able to sync directly with each other\n *   (P2P), making the current naming misleading. Consider using\n *   initiator/non-initiator terminology instead, and consolidate into a single\n *   `applyProtocolMessage` function with conditional arguments to reduce code\n *   duplication.\n * - Replace try-catch with Result + new Error (to preserve stacktraces). Measure\n *   Result overhead, it should be super small.\n * - Allow clients to broadcast messages that are not persisted by relays. This\n *   would enable real-time ephemeral data (like cursor positions, typing\n *   indicators) to be forwarded by relays without storage overhead.\n */\nimport { Packr } from \"msgpackr\";\nimport { isNonEmptyReadonlyArray } from \"../Array.js\";\nimport { assert } from \"../Assert.js\";\nimport { bytesToHex, bytesToUtf8, createBuffer, hexToBytes, utf8ToBytes, } from \"../Buffer.js\";\nimport { createPadmePadding, } from \"../Crypto.js\";\nimport { eqArrayNumber } from \"../Eq.js\";\nimport { computeBalancedBuckets } from \"../Number.js\";\nimport { createRecord, objectToEntries } from \"../Object.js\";\nimport { err, ok } from \"../Result.js\";\nimport { Base64Url, base64UrlToUint8Array, between, DateIso, Id, idBytesToId, idBytesTypeValueLength, idToIdBytes, Int, Json, jsonToJsonValue, NonNegativeInt, Number, PositiveInt, uint8ArrayToBase64Url, } from \"../Type.js\";\nimport { ownerIdToOwnerIdBytes, ownerWriteKeyLength, } from \"./Owner.js\";\nimport { DbChange, fingerprintSize, InfiniteUpperBound, RangeType, } from \"./Storage.js\";\nimport { Counter, eqTimestamp, Millis, timestampBytesLength, timestampBytesToTimestamp, timestampToTimestampBytes, } from \"./Timestamp.js\";\n/**\n * Evolu uses MessagePack for numbers and JSONs.\n *\n * - `variableMapSize: true` - More compact maps, ~5-10% slower encoding\n * - `useRecords: false` - Standard MessagePack without extensions\n */\nconst packr = new Packr({ variableMapSize: true, useRecords: false });\nconst minProtocolMessageMaxSize = 1_000_000;\nconst maxProtocolMessageMaxSize = 100_000_000;\n/**\n * Protocol message maximum size.\n *\n * Defines the upper limit for how large a single protocol message can be.\n * Implementations must enforce a maximum size between 1MB and 100MB to ensure\n * compatibility across all Evolu implementations (the maximum size of mutation\n * change is hardcoded and enforced hence the maximum size can't be smaller).\n *\n * Larger maximum sizes can be configured by relays to reduce roundtrips. For\n * example, a dedicated relay with ample resources could configure a 100MB\n * maximum to minimize roundtrips for large syncs.\n *\n * Only relays can safely configure larger sizes, as clients will handle them.\n * Increasing this value on the client side would break compatibility with\n * relays that enforce smaller limits.\n */\nexport const ProtocolMessageMaxSize = between(minProtocolMessageMaxSize, maxProtocolMessageMaxSize)(Int);\n/**\n * Default {@link ProtocolMessageMaxSize} (1MB).\n *\n * The standard size used across Evolu implementations. Relays with more\n * resources can configure larger sizes to reduce roundtrips.\n */\nexport const defaultProtocolMessageMaxSize = minProtocolMessageMaxSize;\n/**\n * Protocol message ranges maximum size.\n *\n * Defines the upper limit for how large the ranges section of a protocol\n * message can be. Implementations must enforce a maximum size between 3KB and\n * 100KB to ensure compatibility.\n *\n * The upper bound is set to ensure ranges fit within the default 1MB\n * {@link defaultProtocolMessageMaxSize}, maintaining compatibility between all\n * clients and relays.\n */\nexport const ProtocolMessageRangesMaxSize = between(3_000, 100_000)(Int);\n/**\n * Default {@link ProtocolMessageRangesMaxSize} (30KB).\n *\n * The standard size used across Evolu implementations. Relays with more\n * resources can configure larger sizes to reduce roundtrips.\n */\nexport const defaultProtocolMessageRangesMaxSize = 30_000;\n/** Evolu Protocol version. */\nexport const protocolVersion = NonNegativeInt.orThrow(1);\nexport const MessageType = {\n    /** Request message from initiator (client) to non-initiator (relay). */\n    Request: 0,\n    /** Response message from non-initiator (relay) to initiator (client). */\n    Response: 1,\n    /** Broadcast message from non-initiator (relay) to subscribed clients. */\n    Broadcast: 2,\n};\nexport const SubscriptionFlags = {\n    /** No subscription changes for this owner. */\n    None: 0,\n    /** Subscribe to updates for this owner. */\n    Subscribe: 1,\n    /** Unsubscribe from updates for this owner. */\n    Unsubscribe: 2,\n};\nexport const ProtocolErrorCode = {\n    NoError: 0,\n    /** A code for {@link ProtocolWriteKeyError}. */\n    WriteKeyError: 1,\n    /** A code for {@link ProtocolWriteError}. */\n    WriteError: 2,\n    /** A code for {@link ProtocolQuotaError}. */\n    QuotaError: 3,\n    /** A code for {@link ProtocolSyncError}. */\n    SyncError: 4,\n};\n/**\n * Creates a {@link ProtocolMessage} from CRDT messages.\n *\n * If the message size would exceed {@link defaultProtocolMessageMaxSize}, the\n * protocol ensures all messages will be sent in the next round(s) even over\n * unidirectional and stateless transports.\n */\nexport const createProtocolMessageFromCrdtMessages = (deps) => (owner, messages, maxSize) => {\n    const buffer = createProtocolMessageBuffer(owner.id, {\n        messageType: MessageType.Request,\n        totalMaxSize: maxSize ?? defaultProtocolMessageMaxSize,\n        writeKey: owner.writeKey,\n    });\n    let notAllMessagesSent = false;\n    for (const message of messages) {\n        const change = encodeAndEncryptDbChange(deps)(message, owner.encryptionKey);\n        const encryptedCrdtMessage = { timestamp: message.timestamp, change };\n        if (buffer.canAddMessage(encryptedCrdtMessage)) {\n            buffer.addMessage(encryptedCrdtMessage);\n        }\n        else {\n            notAllMessagesSent = true;\n            break;\n        }\n    }\n    if (notAllMessagesSent) {\n        /**\n         * DEV: If not all messages fit due to size limits, we trigger a sync\n         * continuation by appending a Range with a random fingerprint. This\n         * ensures the receiver always responds with ranges, prompting another\n         * sync round.\n         *\n         * The ideal approach would be to send three ranges (skip, fingerprint,\n         * skip) where the fingerprint of unsent messages would act as narrow sync\n         * probe. I think we can send `zeroFingerprint` which can be interpreted\n         * as an indication that the other side should reply with\n         * {@link TimestampsRange}, so no need to restart syncing.\n         *\n         * For now, using a random fingerprint avoids extra complexity and is good\n         * enough for this case.\n         */\n        const randomFingerprint = deps.randomBytes.create(fingerprintSize);\n        // There is always a space for Fingerprint with InfiniteUpperBound.\n        buffer.addRange({\n            type: RangeType.Fingerprint,\n            upperBound: InfiniteUpperBound,\n            fingerprint: randomFingerprint,\n        });\n    }\n    return buffer.unwrap();\n};\n/** Creates a {@link ProtocolMessage} for sync. */\nexport const createProtocolMessageForSync = (deps) => (ownerId, subscriptionFlag) => {\n    const buffer = createProtocolMessageBuffer(ownerId, {\n        messageType: MessageType.Request,\n        subscriptionFlag: subscriptionFlag ?? SubscriptionFlags.None,\n    });\n    const ownerIdBytes = ownerIdToOwnerIdBytes(ownerId);\n    const size = deps.storage.getSize(ownerIdBytes);\n    // Errors are handled by the storage.\n    if (size == null)\n        return null;\n    splitRange(deps)(ownerIdBytes, NonNegativeInt.orThrow(0), size, InfiniteUpperBound, buffer);\n    return buffer.unwrap();\n};\nexport const createProtocolMessageForUnsubscribe = (ownerId) => createProtocolMessageBuffer(ownerId, {\n    messageType: MessageType.Request,\n    subscriptionFlag: SubscriptionFlags.Unsubscribe,\n}).unwrap();\nexport const createProtocolMessageBuffer = (ownerId, options) => {\n    const { totalMaxSize = defaultProtocolMessageMaxSize, rangesMaxSize = defaultProtocolMessageRangesMaxSize, version = protocolVersion, } = options;\n    const buffers = {\n        header: createBuffer(),\n        messages: {\n            timestamps: createTimestampsBuffer(),\n            dbChanges: createBuffer(),\n        },\n        ranges: {\n            timestamps: createTimestampsBuffer(),\n            types: createBuffer(),\n            payloads: createBuffer(),\n        },\n    };\n    encodeNonNegativeInt(buffers.header, version);\n    buffers.header.extend(ownerIdToOwnerIdBytes(ownerId));\n    buffers.header.extend([options.messageType]);\n    if (options.messageType === MessageType.Request) {\n        if (!options.writeKey) {\n            buffers.header.extend([0]);\n        }\n        else {\n            buffers.header.extend([1]);\n            buffers.header.extend(options.writeKey);\n        }\n        const subscriptionFlag = options.subscriptionFlag ?? SubscriptionFlags.None;\n        buffers.header.extend([subscriptionFlag]);\n    }\n    else if (options.messageType === MessageType.Response) {\n        buffers.header.extend([options.errorCode]);\n    }\n    let isLastRangeInfinite = false;\n    const isWithinSizeLimits = () => getSize() <= totalMaxSize;\n    const getSize = () => PositiveInt.orThrow(getHeaderAndMessagesSize() + getRangesSize());\n    const getHeaderAndMessagesSize = () => buffers.header.getLength() +\n        buffers.messages.timestamps.getLength() +\n        buffers.messages.dbChanges.getLength();\n    const getRangesSize = () => buffers.ranges.timestamps.getCount() > 0\n        ? buffers.ranges.timestamps.getLength() +\n            buffers.ranges.types.getLength() +\n            buffers.ranges.payloads.getLength() +\n            safeMargins.remainingRange\n        : 0;\n    /**\n     * We calculated worst-case sizes as closely as possible and added a small\n     * safety margin, since computing exact worst cases is difficult due to\n     * variable-length, run-length, and delta encoding.\n     *\n     * Runtime assertions (`assert`) are used to guarantee that size limits are\n     * never exceeded. If a limit is exceeded, the assertion will fail at the\n     * precise location, making it easy to identify and fix the issue.\n     *\n     * While it would be possible to avoid the safety margin by snapshotting\n     * buffer states and rolling back changes, this would likely impact\n     * performance. If someone has time and wants to experiment with this\n     * approach, contributions are welcome.\n     */\n    const safeMargins = {\n        remainingRange: fingerprintSize + 10, // bytes: range type + possible increased count varint\n        timestamp: 30, // bytes: max millis + max count + NodeId\n        dbChangeLength: 8, // bytes: maximum encoded DbChange length varint\n        splitRange: 800, // bytes: worst case is around 650 bytes\n        timestampsRange: 50, // bytes: range type + its upperBound + possible increased count varint\n    };\n    const addMessageSafeMargin = safeMargins.timestamp +\n        safeMargins.dbChangeLength +\n        safeMargins.remainingRange;\n    return {\n        canAddMessage: (message) => getSize() + addMessageSafeMargin + message.change.length <= totalMaxSize,\n        addMessage: (message) => {\n            buffers.messages.timestamps.add(message.timestamp);\n            encodeLength(buffers.messages.dbChanges, message.change);\n            buffers.messages.dbChanges.extend(message.change);\n            assert(isWithinSizeLimits(), \"the message is too big\");\n        },\n        canSplitRange: () => {\n            return getRangesSize() + safeMargins.splitRange <= rangesMaxSize;\n        },\n        canAddTimestampsRangeAndMessage: (timestamps, message) => {\n            const rangesNewSize = getRangesSize() + timestamps.getLength() + safeMargins.timestampsRange;\n            return (rangesNewSize <= rangesMaxSize &&\n                (message\n                    ? getHeaderAndMessagesSize() +\n                        rangesNewSize +\n                        addMessageSafeMargin +\n                        message.change.length <=\n                        totalMaxSize\n                    : true));\n        },\n        addRange: (range) => {\n            assert(options.messageType !== MessageType.Broadcast, \"Cannot add a range into broadcast message\");\n            assert(!isLastRangeInfinite, \"Cannot add a range after an InfiniteUpperBound range\");\n            isLastRangeInfinite = range.upperBound === InfiniteUpperBound;\n            /**\n             * We don't have to encode InfiniteUpperBound timestamp since it's always\n             * the last because ranges cover the whole universe. For partial sync, we\n             * use SkipRange.\n             */\n            if (range.upperBound !== InfiniteUpperBound)\n                buffers.ranges.timestamps.add(timestampBytesToTimestamp(range.upperBound));\n            else {\n                buffers.ranges.timestamps.addInfinite();\n            }\n            encodeNonNegativeInt(buffers.ranges.types, NonNegativeInt.orThrow(range.type));\n            switch (range.type) {\n                case RangeType.Skip:\n                    break;\n                case RangeType.Fingerprint:\n                    buffers.ranges.payloads.extend(range.fingerprint);\n                    break;\n                case RangeType.Timestamps: {\n                    range.timestamps.append(buffers.ranges.payloads);\n                    break;\n                }\n            }\n            assert(isWithinSizeLimits(), `the range ${range.type} is too big`);\n        },\n        unwrap: () => {\n            if (buffers.ranges.timestamps.getCount() > 0) {\n                assert(isLastRangeInfinite, \"The last range's upperBound must be InfiniteUpperBound\");\n            }\n            buffers.messages.timestamps.append(buffers.header);\n            buffers.header.extend(buffers.messages.dbChanges.unwrap());\n            if (buffers.ranges.timestamps.getCount() > 0) {\n                buffers.ranges.timestamps.append(buffers.header);\n                buffers.header.extend(buffers.ranges.types.unwrap());\n                buffers.header.extend(buffers.ranges.payloads.unwrap());\n            }\n            return buffers.header.unwrap();\n        },\n        getSize,\n    };\n};\nexport const createTimestampsBuffer = () => {\n    let count = NonNegativeInt.orThrow(0);\n    const countBuffer = createBuffer();\n    const syncCount = () => {\n        countBuffer.reset();\n        encodeNonNegativeInt(countBuffer, count);\n    };\n    syncCount();\n    const millisBuffer = createBuffer();\n    let previousMillis = 0;\n    const counterEncoder = createRunLengthEncoder((buffer, value) => {\n        encodeNonNegativeInt(buffer, value);\n    });\n    const nodeIdEncoder = createRunLengthEncoder((buffer, value) => {\n        encodeNodeId(buffer, value);\n    });\n    return {\n        add: (timestamp) => {\n            const delta = timestamp.millis - previousMillis;\n            assert(NonNegativeInt.is(delta), \"The delta must be NonNegativeInt\");\n            count++;\n            syncCount();\n            previousMillis = timestamp.millis;\n            encodeNonNegativeInt(millisBuffer, delta);\n            counterEncoder.add(timestamp.counter);\n            nodeIdEncoder.add(timestamp.nodeId);\n        },\n        addInfinite: () => {\n            count++;\n            syncCount();\n        },\n        getCount: () => count,\n        getLength: () => countBuffer.getLength() +\n            millisBuffer.getLength() +\n            counterEncoder.getLength() +\n            nodeIdEncoder.getLength(),\n        append: (buffer) => {\n            buffer.extend(countBuffer.unwrap());\n            buffer.extend(millisBuffer.unwrap());\n            buffer.extend(counterEncoder.unwrap());\n            buffer.extend(nodeIdEncoder.unwrap());\n        },\n    };\n};\nconst createRunLengthEncoder = (encodeValue) => {\n    const buffer = createBuffer();\n    let previousLength = NonNegativeInt.orThrow(0);\n    let previousValue = null;\n    let runLength = NonNegativeInt.orThrow(0);\n    return {\n        add: (value) => {\n            if (value === previousValue) {\n                runLength++;\n                buffer.truncate(previousLength);\n            }\n            else {\n                previousValue = value;\n                runLength = NonNegativeInt.orThrow(1);\n            }\n            previousLength = buffer.getLength();\n            encodeValue(buffer, value);\n            encodeNonNegativeInt(buffer, runLength);\n        },\n        getLength: () => buffer.getLength(),\n        unwrap: () => buffer.unwrap(),\n    };\n};\nexport const applyProtocolMessageAsClient = (deps) => async (inputMessage, options = {}) => {\n    try {\n        const input = createBuffer(inputMessage);\n        const [requestedVersion, ownerId] = decodeVersionAndOwner(input);\n        const version = options.version ?? protocolVersion;\n        if (requestedVersion !== version) {\n            return err({\n                type: \"ProtocolVersionError\",\n                version: requestedVersion,\n                isInitiator: version < requestedVersion,\n                ownerId,\n            });\n        }\n        const messageType = input.shift();\n        assert(messageType === MessageType.Response ||\n            messageType === MessageType.Broadcast, \"Invalid MessageType\");\n        if (messageType === MessageType.Response) {\n            const errorCode = input.shift();\n            if (errorCode !== ProtocolErrorCode.NoError) {\n                switch (errorCode) {\n                    case ProtocolErrorCode.WriteKeyError:\n                        return err({\n                            type: \"ProtocolWriteKeyError\",\n                            ownerId,\n                        });\n                    case ProtocolErrorCode.WriteError:\n                        return err({\n                            type: \"ProtocolWriteError\",\n                            ownerId,\n                        });\n                    case ProtocolErrorCode.QuotaError:\n                        return err({\n                            type: \"ProtocolQuotaError\",\n                            ownerId,\n                        });\n                    case ProtocolErrorCode.SyncError:\n                        return err({\n                            type: \"ProtocolSyncError\",\n                            ownerId,\n                        });\n                    default:\n                        throw new ProtocolDecodeError(`Invalid ProtocolErrorCode: ${errorCode}`);\n                }\n            }\n        }\n        const messages = decodeMessages(input);\n        const ownerIdBytes = ownerIdToOwnerIdBytes(ownerId);\n        if (isNonEmptyReadonlyArray(messages)) {\n            const result = await deps.storage.writeMessages(ownerIdBytes, messages);\n            // Errors are handled by the Storage. Here we just stop syncing.\n            if (!result.ok)\n                return ok({ type: \"no-response\" });\n        }\n        // Now: No writeKey, no sync.\n        // TODO: Allow to sync SharedReadonlyOwner\n        // Without local changes, writeKey will not be required.\n        // With local changes, writeKey will be required and if not provided,\n        // the sync will stop.\n        const writeKey = options.getWriteKey?.(ownerId);\n        if (writeKey == null) {\n            return ok({ type: \"no-response\" });\n        }\n        if (messageType === MessageType.Broadcast) {\n            return ok({ type: \"broadcast\" });\n        }\n        const ranges = decodeRanges(input);\n        if (!isNonEmptyReadonlyArray(ranges)) {\n            return ok({ type: \"no-response\" });\n        }\n        const output = createProtocolMessageBuffer(ownerId, {\n            messageType: MessageType.Request,\n            writeKey,\n            rangesMaxSize: options.rangesMaxSize,\n        });\n        const result = sync(deps)(ranges, output, ownerIdBytes);\n        // Client sync error (handled via Storage) or no changes.\n        if (!result.ok || !result.value) {\n            return ok({ type: \"no-response\" });\n        }\n        return ok({ type: \"response\", message: output.unwrap() });\n    }\n    catch (error) {\n        return err({\n            type: \"ProtocolInvalidDataError\",\n            data: inputMessage,\n            error,\n        });\n    }\n};\nexport const applyProtocolMessageAsRelay = (deps) => async (inputMessage, options = {}, \n/** For tests only. */\nversion = protocolVersion) => {\n    try {\n        const input = createBuffer(inputMessage);\n        const [requestedVersion, ownerId] = decodeVersionAndOwner(input);\n        const ownerIdBytes = ownerIdToOwnerIdBytes(ownerId);\n        if (requestedVersion !== version) {\n            // Non-initiator responds with its version and ownerId.\n            const output = createBuffer();\n            encodeNonNegativeInt(output, version);\n            output.extend(ownerIdBytes);\n            return ok({\n                type: \"response\",\n                message: output.unwrap(),\n            });\n        }\n        const messageType = input.shift();\n        assert(messageType === MessageType.Request, \"Invalid MessageType\");\n        const hasWriteKey = input.shift();\n        let writeKey;\n        if (hasWriteKey === 1) {\n            writeKey = input.shiftN(ownerWriteKeyLength);\n        }\n        const subscriptionFlag = input.shift();\n        switch (subscriptionFlag) {\n            case SubscriptionFlags.Subscribe:\n                options.subscribe?.(ownerId);\n                break;\n            case SubscriptionFlags.Unsubscribe:\n                options.unsubscribe?.(ownerId);\n                break;\n            case SubscriptionFlags.None:\n                break;\n        }\n        if (writeKey) {\n            const isValid = deps.storage.validateWriteKey(ownerIdBytes, writeKey);\n            if (!isValid) {\n                return ok({\n                    type: \"response\",\n                    message: createProtocolMessageBuffer(ownerId, {\n                        messageType: MessageType.Response,\n                        errorCode: ProtocolErrorCode.WriteKeyError,\n                    }).unwrap(),\n                });\n            }\n        }\n        const messages = decodeMessages(input);\n        if (isNonEmptyReadonlyArray(messages)) {\n            if (!writeKey) {\n                return ok({\n                    type: \"response\",\n                    message: createProtocolMessageBuffer(ownerId, {\n                        messageType: MessageType.Response,\n                        errorCode: ProtocolErrorCode.WriteKeyError,\n                    }).unwrap(),\n                });\n            }\n            const result = await deps.storage.writeMessages(ownerIdBytes, messages);\n            if (!result.ok) {\n                const errorCode = result.error.type === \"StorageWriteError\"\n                    ? ProtocolErrorCode.WriteError\n                    : ProtocolErrorCode.QuotaError;\n                const message = createProtocolMessageBuffer(ownerId, {\n                    messageType: MessageType.Response,\n                    errorCode,\n                }).unwrap();\n                return ok({ type: \"response\", message });\n            }\n            /**\n             * Broadcast messages to all subscribed owners for real-time\n             * synchronization between clients.\n             *\n             * Messages are only broadcasted after successful write to ensure\n             * devices that can still sync aren't affected by quota errors, and to\n             * prevent using a half-working relay service (broadcasting without\n             * persistence).\n             *\n             * When a relay's database is deleted or clients migrate to a new relay\n             * (without data migration), clients will sync their data to the relay,\n             * and the relay will broadcast those messages to other connected\n             * clients. Those clients may receive messages they already have, but\n             * this is safe because Evolu sync is idempotent. As the relay becomes\n             * more synchronized with clients over time, fewer duplicate messages\n             * will be broadcasted.\n             */\n            if (options.broadcast) {\n                const broadcastBuffer = createProtocolMessageBuffer(ownerId, {\n                    messageType: MessageType.Broadcast,\n                    totalMaxSize: options.totalMaxSize,\n                    rangesMaxSize: options.rangesMaxSize,\n                    version,\n                });\n                for (const message of messages) {\n                    broadcastBuffer.addMessage(message);\n                }\n                options.broadcast(ownerId, broadcastBuffer.unwrap());\n            }\n        }\n        const ranges = decodeRanges(input);\n        const output = createProtocolMessageBuffer(ownerId, {\n            messageType: MessageType.Response,\n            errorCode: ProtocolErrorCode.NoError,\n            totalMaxSize: options.totalMaxSize,\n            rangesMaxSize: options.rangesMaxSize,\n        });\n        // Non-initiators always respond to provide sync completion feedback,\n        // even when there's nothing to sync.\n        if (!isNonEmptyReadonlyArray(ranges)) {\n            return ok({ type: \"response\", message: output.unwrap() });\n        }\n        const result = sync(deps)(ranges, output, ownerIdBytes);\n        const message = result.ok\n            ? output.unwrap()\n            : createProtocolMessageBuffer(ownerId, {\n                messageType: MessageType.Response,\n                errorCode: result.error,\n            }).unwrap();\n        // Non-initiators always respond to provide sync completion feedback,\n        return ok({ type: \"response\", message });\n    }\n    catch (error) {\n        return err({\n            type: \"ProtocolInvalidDataError\",\n            data: inputMessage,\n            error,\n        });\n    }\n};\nconst decodeVersionAndOwner = (input) => {\n    // This structure must never change across protocol versions. The version\n    // and owner ID must always be the first two fields in every protocol message\n    // to enable version negotiation and owner identification before any other\n    // processing occurs.\n    const version = decodeNonNegativeInt(input);\n    const ownerId = decodeId(input);\n    return [version, ownerId];\n};\n/**\n * Error thrown for internal protocol validation failures, such as invalid data\n * or type errors.\n */\nclass ProtocolDecodeError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = this.constructor.name;\n        Error.captureStackTrace(this, this.constructor);\n    }\n}\nconst decodeMessages = (buffer) => {\n    const timestamps = decodeTimestamps(buffer);\n    const messages = [];\n    for (const timestamp of timestamps) {\n        const changeLength = decodeLength(buffer);\n        const change = buffer.shiftN(changeLength);\n        messages.push({ timestamp, change });\n    }\n    return messages;\n};\nconst sync = (deps) => (ranges, output, ownerIdBytes) => {\n    const outputInitialSize = output.getSize();\n    const storageSize = deps.storage.getSize(ownerIdBytes);\n    if (storageSize == null)\n        return err(ProtocolErrorCode.SyncError);\n    let prevUpperBound = null;\n    let prevIndex = NonNegativeInt.orThrow(0);\n    let skip = false;\n    let nonSkipRangeAdded = false;\n    const skipRange = (range) => {\n        // The last range, if any non skip was added, must have InfiniteUpperBound.\n        if (nonSkipRangeAdded && range.upperBound === InfiniteUpperBound) {\n            output.addRange({\n                type: RangeType.Skip,\n                upperBound: InfiniteUpperBound,\n            });\n        }\n        else {\n            skip = true;\n        }\n    };\n    const coalesceSkipsBeforeAdd = () => {\n        // Set to true because we are going to add a non skip range.\n        nonSkipRangeAdded = true;\n        if (skip) {\n            skip = false;\n            assert(prevUpperBound != null, \"prevUpperBound is null\");\n            // There is always a space for a skip range before adding.\n            output.addRange({\n                type: RangeType.Skip,\n                upperBound: prevUpperBound,\n            });\n        }\n    };\n    // When we don't have a space...\n    const addFingerprintForRemainingRange = (begin) => {\n        const fingerprint = deps.storage.fingerprint(ownerIdBytes, begin, storageSize);\n        if (!fingerprint)\n            return false;\n        // There is always a space for a ramaining range.\n        output.addRange({\n            type: RangeType.Fingerprint,\n            upperBound: InfiniteUpperBound,\n            fingerprint,\n        });\n        return true;\n    };\n    for (const range of ranges) {\n        const currentUpperBound = range.upperBound;\n        const lower = prevIndex;\n        let upper = deps.storage.findLowerBound(ownerIdBytes, prevIndex, storageSize, currentUpperBound);\n        if (upper == null)\n            return err(ProtocolErrorCode.SyncError);\n        switch (range.type) {\n            case RangeType.Skip: {\n                skipRange(range);\n                break;\n            }\n            case RangeType.Fingerprint: {\n                const ourFingerprint = deps.storage.fingerprint(ownerIdBytes, lower, upper);\n                if (ourFingerprint == null)\n                    return err(ProtocolErrorCode.SyncError);\n                if (eqArrayNumber(range.fingerprint, ourFingerprint)) {\n                    skipRange(range);\n                }\n                else {\n                    if (output.canSplitRange()) {\n                        coalesceSkipsBeforeAdd();\n                        splitRange(deps)(ownerIdBytes, lower, upper, currentUpperBound, output);\n                    }\n                    else {\n                        return addFingerprintForRemainingRange(upper)\n                            ? ok(true)\n                            : err(ProtocolErrorCode.SyncError);\n                    }\n                }\n                break;\n            }\n            case RangeType.Timestamps: {\n                let endBound = currentUpperBound;\n                const timestampsWeNeed = new Map(range.timestamps.map((t) => [t.join(), true]));\n                const ourTimestamps = createTimestampsBuffer();\n                let cantReadDbChange = false;\n                let exceeded = false;\n                deps.storage.iterate(ownerIdBytes, lower, upper, (timestamp, index) => {\n                    const timestampString = timestamp.join();\n                    const timestampBinary = timestampBytesToTimestamp(timestamp);\n                    let message = null;\n                    if (timestampsWeNeed.has(timestampString)) {\n                        timestampsWeNeed.delete(timestampString);\n                    }\n                    else {\n                        const dbChange = deps.storage.readDbChange(ownerIdBytes, timestamp);\n                        if (dbChange == null) {\n                            cantReadDbChange = true;\n                            return false;\n                        }\n                        message = {\n                            timestamp: timestampBinary,\n                            change: dbChange,\n                        };\n                    }\n                    if (!output.canAddTimestampsRangeAndMessage(ourTimestamps, message)) {\n                        exceeded = true;\n                        endBound = timestamp;\n                        upper = index;\n                        return false;\n                    }\n                    ourTimestamps.add(timestampBinary);\n                    if (message)\n                        output.addMessage(message);\n                    return true;\n                });\n                if (cantReadDbChange) {\n                    return err(ProtocolErrorCode.SyncError);\n                }\n                const addRange = () => {\n                    coalesceSkipsBeforeAdd();\n                    output.addRange({\n                        type: RangeType.Timestamps,\n                        upperBound: endBound,\n                        timestamps: ourTimestamps,\n                    });\n                };\n                if (exceeded) {\n                    addRange();\n                    if (!addFingerprintForRemainingRange(upper)) {\n                        return err(ProtocolErrorCode.SyncError);\n                    }\n                    return ok(true);\n                }\n                // If we need something, we have to respond with our timestamps.\n                if (timestampsWeNeed.size > 0) {\n                    addRange();\n                }\n                else {\n                    skipRange(range);\n                }\n                break;\n            }\n        }\n        prevIndex = upper;\n        prevUpperBound = currentUpperBound;\n    }\n    // If all ranges were skipped, there are no changes and sync is complete.\n    const hasChange = output.getSize() > outputInitialSize;\n    return ok(hasChange);\n};\nconst splitRange = (deps) => (ownerId, lower, upper, upperBound, buffer) => {\n    const itemCount = NonNegativeInt.orThrow(upper - lower);\n    const buckets = computeBalancedBuckets(itemCount);\n    if (!buckets.ok) {\n        const range = {\n            type: RangeType.Timestamps,\n            upperBound,\n            timestamps: createTimestampsBuffer(),\n        };\n        deps.storage.iterate(ownerId, NonNegativeInt.orThrow(0), itemCount, (timestamp) => {\n            range.timestamps.add(timestampBytesToTimestamp(timestamp));\n            return true;\n        });\n        buffer.addRange(range);\n        return;\n    }\n    // Check Storage.ts `fingerprint` and `fingerprintRanges` docs.\n    const fingerprintRangesBuckets = lower === 0\n        ? buckets.value\n        : [\n            lower,\n            ...buckets.value.map((b) => NonNegativeInt.orThrow(b + lower)),\n        ];\n    const fingerprintRanges = deps.storage.fingerprintRanges(ownerId, fingerprintRangesBuckets, upperBound);\n    // Errors are handled by the storage.\n    if (fingerprintRanges == null)\n        return;\n    const rangesToUse = lower > 0 ? fingerprintRanges.slice(1) : fingerprintRanges;\n    for (const range of rangesToUse) {\n        buffer.addRange(range);\n    }\n};\nconst decodeRanges = (buffer) => {\n    if (buffer.getLength() === 0)\n        return [];\n    const rangesCount = decodeNonNegativeInt(buffer);\n    if (rangesCount === 0)\n        return [];\n    const timestampsCount = NonNegativeInt.orThrow(rangesCount - 1);\n    const timestamps = decodeTimestamps(buffer, timestampsCount);\n    const rangeTypes = [];\n    for (let i = 0; i < rangesCount; i++) {\n        const rangeType = decodeNonNegativeInt(buffer);\n        switch (rangeType) {\n            case RangeType.Fingerprint:\n            case RangeType.Skip:\n            case RangeType.Timestamps:\n                rangeTypes.push(rangeType);\n                break;\n            default:\n                throw new ProtocolDecodeError(`Invalid RangeType: ${rangeType}`);\n        }\n    }\n    const ranges = [];\n    for (let i = 0; i < rangesCount; i++) {\n        const upperBound = i < timestampsCount\n            ? timestampToTimestampBytes(timestamps[i])\n            : InfiniteUpperBound;\n        const rangeType = rangeTypes[i];\n        switch (rangeType) {\n            case RangeType.Skip:\n                ranges.push({ type: RangeType.Skip, upperBound });\n                break;\n            case RangeType.Fingerprint: {\n                const fingerprint = buffer.shiftN(fingerprintSize);\n                ranges.push({\n                    type: RangeType.Fingerprint,\n                    upperBound,\n                    fingerprint,\n                });\n                break;\n            }\n            case RangeType.Timestamps: {\n                const timestamps = decodeTimestamps(buffer).map(timestampToTimestampBytes);\n                ranges.push({\n                    type: RangeType.Timestamps,\n                    upperBound,\n                    timestamps,\n                });\n                break;\n            }\n        }\n    }\n    return ranges;\n};\n/** Decodes an array of sorted timestamps with delta-encoded millis. */\nconst decodeTimestamps = (buffer, length) => {\n    length ??= decodeNonNegativeInt(buffer);\n    let previousMillis = 0;\n    const millises = [];\n    for (let i = 0; i < length; i++) {\n        const deltaMillis = decodeNonNegativeInt(buffer);\n        const millis = Millis.from(previousMillis + deltaMillis);\n        if (!millis.ok)\n            throw new ProtocolDecodeError(millis.error.type);\n        millises.push(millis.value);\n        previousMillis = millis.value;\n    }\n    const counters = [];\n    let counterIndex = 0;\n    while (counterIndex < length) {\n        const counter = Counter.from(decodeNonNegativeInt(buffer));\n        if (!counter.ok)\n            throw new ProtocolDecodeError(counter.error.type);\n        const runLength = decodeNonNegativeInt(buffer);\n        for (let i = 0; i < runLength; i++) {\n            counters.push(counter.value);\n            counterIndex++;\n        }\n    }\n    const nodeIds = [];\n    let nodeIdIndex = 0;\n    while (nodeIdIndex < length) {\n        const nodeId = decodeNodeId(buffer);\n        const runLength = decodeNonNegativeInt(buffer);\n        for (let i = 0; i < runLength; i++) {\n            nodeIds.push(nodeId);\n            nodeIdIndex++;\n        }\n    }\n    const timestamps = [];\n    for (let i = 0; i < length; i++) {\n        timestamps.push({\n            millis: millises[i],\n            counter: counters[i],\n            nodeId: nodeIds[i],\n        });\n    }\n    return timestamps;\n};\nconst decodeId = (buffer) => {\n    const bytes = buffer.shiftN(idBytesTypeValueLength);\n    return idBytesToId(bytes);\n};\n/**\n * Evolu uses MessagePack to handle all number variants except for\n * NonNegativeInt. For NonNegativeInt, Evolu provides more efficient encoding.\n */\nexport const encodeNumber = (buffer, number) => {\n    buffer.extend(packr.pack(number));\n};\nexport const decodeNumber = (buffer) => {\n    let number;\n    let end;\n    packr.unpackMultiple(buffer.unwrap(), (n, _, e) => {\n        number = n;\n        end = e;\n        return false;\n    });\n    const endResult = NonNegativeInt.fromUnknown(end);\n    if (!endResult.ok)\n        throw new ProtocolDecodeError(endResult.error.type);\n    const numberResult = Number.fromUnknown(number);\n    if (!numberResult.ok)\n        throw new ProtocolDecodeError(numberResult.error.type);\n    buffer.shiftN(endResult.value);\n    return numberResult.value;\n};\n/**\n * Encodes an array of boolean flags into a single byte.\n *\n * Each element in the array corresponds to a bit (0-7). Array can have 0-8\n * elements.\n *\n * ### Example\n *\n * ```ts\n * encodeFlags(buffer, [true, false, true]); // Encodes bits 0, 1, 2\n * ```\n */\nexport const encodeFlags = (buffer, flags) => {\n    let byte = 0;\n    for (let i = 0; i < flags.length && i < 8; i++) {\n        if (flags[i]) {\n            byte |= 1 << i;\n        }\n    }\n    buffer.extend([byte]);\n};\n/**\n * Decodes a byte into an array of boolean flags.\n *\n * ### Example\n *\n * ```ts\n * const flags = decodeFlags(buffer, 3); // Decode 3 flags\n * ```\n */\nexport const decodeFlags = (buffer, count) => {\n    const byte = buffer.shift();\n    const flags = [];\n    for (let i = 0; i < count && i < 8; i++) {\n        flags.push((byte & (1 << i)) !== 0);\n    }\n    return flags;\n};\n/**\n * Encodes and encrypts a {@link DbChange} using the provided owner's encryption\n * key. Returns an encrypted binary representation as {@link EncryptedDbChange}.\n *\n * The format includes the protocol version for backward compatibility and the\n * timestamp for tamper-proof verification that the timestamp matches the change\n * data.\n */\nexport const encodeAndEncryptDbChange = (deps) => (message, key) => {\n    const buffer = createBuffer();\n    encodeNonNegativeInt(buffer, protocolVersion);\n    // Encode the timestamp to prevent tampering (e.g., a malicious relay\n    // assigning this EncryptedDbChange to a different EncryptedCrdtMessage)\n    buffer.extend(timestampToTimestampBytes(message.timestamp));\n    encodeFlags(buffer, [\n        message.change.isInsert,\n        message.change.isDelete != null,\n        message.change.isDelete ?? false,\n    ]);\n    encodeString(buffer, message.change.table);\n    buffer.extend(idToIdBytes(message.change.id));\n    const entries = objectToEntries(message.change.values);\n    encodeLength(buffer, entries);\n    for (const [column, value] of entries) {\n        encodeString(buffer, column);\n        encodeSqliteValue(buffer, value);\n    }\n    // Add PADM padding (ignored during decoding)\n    buffer.extend(createPadmePadding(buffer.getLength()));\n    const { nonce, ciphertext } = deps.symmetricCrypto.encrypt(buffer.unwrap(), key);\n    buffer.reset();\n    buffer.extend(nonce);\n    encodeLength(buffer, ciphertext);\n    buffer.extend(ciphertext);\n    return buffer.unwrap();\n};\n/**\n * Decrypts and decodes an {@link EncryptedCrdtMessage} using the provided\n * owner's encryption key. Verifies that the embedded timestamp matches the\n * expected timestamp to ensure message integrity.\n */\nexport const decryptAndDecodeDbChange = (deps) => (message, key) => {\n    try {\n        const buffer = createBuffer(message.change);\n        const nonce = buffer.shiftN(deps.symmetricCrypto.nonceLength);\n        const ciphertext = buffer.shiftN(decodeLength(buffer));\n        const plaintextBytes = deps.symmetricCrypto.decrypt(ciphertext, key, nonce);\n        if (!plaintextBytes.ok)\n            return plaintextBytes;\n        buffer.reset();\n        buffer.extend(plaintextBytes.value);\n        // Decode version (for future compatibility, not need yet)\n        decodeNonNegativeInt(buffer);\n        const timestamp = timestampBytesToTimestamp(buffer.shiftN(timestampBytesLength));\n        if (!eqTimestamp(timestamp, message.timestamp)) {\n            return err({\n                type: \"ProtocolTimestampMismatchError\",\n                expected: message.timestamp,\n                timestamp,\n            });\n        }\n        const flags = decodeFlags(buffer, PositiveInt.orThrow(3));\n        const table = decodeString(buffer);\n        const id = decodeId(buffer);\n        const length = decodeLength(buffer);\n        const values = createRecord();\n        for (let i = 0; i < length; i++) {\n            const column = decodeString(buffer);\n            const value = decodeSqliteValue(buffer);\n            values[column] = value;\n        }\n        const dbChange = DbChange.orThrow({\n            table,\n            id,\n            values,\n            isInsert: flags[0],\n            isDelete: flags[1] ? flags[2] : null,\n        });\n        return ok(dbChange);\n    }\n    catch (error) {\n        return err({\n            type: \"ProtocolInvalidDataError\",\n            data: message.change,\n            error,\n        });\n    }\n};\n/**\n * Encodes a non-negative integer into a variable-length integer format. It's\n * more efficient than encoding via {@link encodeNumber}.\n *\n * https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nexport const encodeNonNegativeInt = (buffer, int) => {\n    if (int === 0) {\n        buffer.extend([0]);\n        return;\n    }\n    let remaining = BigInt(int);\n    const bytes = [];\n    while (remaining !== 0n) {\n        const byte = globalThis.Number(remaining & 127n);\n        bytes.push(byte);\n        remaining >>= 7n;\n    }\n    for (let i = 0; i < bytes.length - 1; i++) {\n        bytes[i] |= 128;\n    }\n    buffer.extend(bytes);\n};\n/**\n * Decodes a non-negative integer from a variable-length integer format.\n *\n * https://en.wikipedia.org/wiki/Variable-length_quantity\n */\nexport const decodeNonNegativeInt = (buffer) => {\n    let result = 0n;\n    let shift = 0n;\n    let byte;\n    // 8 is the smallest required count\n    for (let byteCount = 0; byteCount < 8; byteCount++) {\n        byte = buffer.shift();\n        result |= BigInt(byte & 127) << shift;\n        if ((byte & 128) === 0)\n            break;\n        shift += 7n;\n    }\n    const int = NonNegativeInt.from(globalThis.Number(result));\n    if (!int.ok)\n        throw new ProtocolDecodeError(int.error.type);\n    return int.value;\n};\nexport const encodeLength = (buffer, value) => {\n    encodeNonNegativeInt(buffer, NonNegativeInt.orThrow(value.length));\n};\nexport const decodeLength = decodeNonNegativeInt;\nexport const encodeString = (buffer, value) => {\n    const bytes = utf8ToBytes(value);\n    encodeLength(buffer, bytes);\n    buffer.extend(bytes);\n};\nexport const decodeString = (buffer) => {\n    const length = decodeLength(buffer);\n    const bytes = buffer.shiftN(length);\n    return bytesToUtf8(bytes);\n};\nexport const encodeNodeId = (buffer, nodeId) => {\n    buffer.extend(hexToBytes(nodeId));\n};\nexport const decodeNodeId = (buffer) => {\n    const bytes = buffer.shiftN(NonNegativeInt.orThrow(8));\n    return bytesToHex(bytes);\n};\n// Small ints are encoded into ProtocolValueType, saving one byte per int.\nconst isSmallInt = (value) => value >= 0 && value < 20;\nexport const ProtocolValueType = {\n    // 0-19 small ints\n    // SQLite types\n    String: NonNegativeInt.orThrow(20),\n    Number: NonNegativeInt.orThrow(21),\n    Null: NonNegativeInt.orThrow(22),\n    Bytes: NonNegativeInt.orThrow(23),\n    // We can add more types for other DBs or anything else later.\n    // Optimized types\n    NonNegativeInt: NonNegativeInt.orThrow(30),\n    // String optimizations\n    EmptyString: NonNegativeInt.orThrow(31), // 1 byte vs 2 bytes (50% reduction)\n    Base64Url: NonNegativeInt.orThrow(32),\n    Id: NonNegativeInt.orThrow(33),\n    Json: NonNegativeInt.orThrow(34),\n    // new Date().toISOString()   - 24 bytes\n    // encoded with fixed length  - 8 bytes\n    // encode as NonNegativeInt   - 6 bytes (additional 25% reduction)\n    DateIsoWithNonNegativeTime: NonNegativeInt.orThrow(35),\n    DateIsoWithNegativeTime: NonNegativeInt.orThrow(36), // 9 bytes\n    // TODO: Operations (from 40)\n    // Increment, Decrement, Patch, whatever.\n};\nexport const encodeSqliteValue = (buffer, value) => {\n    if (value === null) {\n        encodeNonNegativeInt(buffer, ProtocolValueType.Null);\n        return;\n    }\n    switch (typeof value) {\n        case \"string\": {\n            if (value === \"\") {\n                encodeNonNegativeInt(buffer, ProtocolValueType.EmptyString);\n                return;\n            }\n            const dateIso = DateIso.fromParent(value);\n            if (dateIso.ok) {\n                const time = new Date(dateIso.value).getTime();\n                if (NonNegativeInt.is(time)) {\n                    encodeNonNegativeInt(buffer, ProtocolValueType.DateIsoWithNonNegativeTime);\n                    encodeNonNegativeInt(buffer, time);\n                }\n                else {\n                    encodeNonNegativeInt(buffer, ProtocolValueType.DateIsoWithNegativeTime);\n                    encodeNumber(buffer, time);\n                }\n                return;\n            }\n            const id = Id.fromParent(value);\n            if (id.ok) {\n                encodeNonNegativeInt(buffer, ProtocolValueType.Id);\n                buffer.extend(idToIdBytes(id.value));\n                return;\n            }\n            const json = Json.fromParent(value);\n            // Only encode as Json if it survives JSON.parse/JSON.stringify round-trip.\n            // Some valid JSON strings like \"-0E0\" get normalized to \"0\" during parsing,\n            // which would cause data corruption if we don't verify round-trip safety.\n            if (json.ok && JSON.stringify(jsonToJsonValue(json.value)) === value) {\n                const jsonBytes = packr.pack(jsonToJsonValue(json.value));\n                encodeNonNegativeInt(buffer, ProtocolValueType.Json);\n                encodeLength(buffer, jsonBytes);\n                buffer.extend(jsonBytes);\n                return;\n            }\n            const base64Url = Base64Url.fromParent(value);\n            if (base64Url.ok) {\n                encodeNonNegativeInt(buffer, ProtocolValueType.Base64Url);\n                const bytes = base64UrlToUint8Array(base64Url.value);\n                encodeLength(buffer, bytes);\n                buffer.extend(bytes);\n                return;\n            }\n            encodeNonNegativeInt(buffer, ProtocolValueType.String);\n            encodeString(buffer, value);\n            return;\n        }\n        case \"number\": {\n            if (NonNegativeInt.is(value)) {\n                if (isSmallInt(value)) {\n                    encodeNonNegativeInt(buffer, value);\n                    return;\n                }\n                encodeNonNegativeInt(buffer, ProtocolValueType.NonNegativeInt);\n                encodeNonNegativeInt(buffer, value);\n                return;\n            }\n            encodeNonNegativeInt(buffer, ProtocolValueType.Number);\n            encodeNumber(buffer, value);\n            return;\n        }\n    }\n    encodeNonNegativeInt(buffer, ProtocolValueType.Bytes);\n    encodeLength(buffer, value);\n    buffer.extend(value);\n};\nexport const decodeSqliteValue = (buffer) => {\n    const type = decodeNonNegativeInt(buffer);\n    if (isSmallInt(type)) {\n        return type;\n    }\n    switch (type) {\n        case ProtocolValueType.String:\n            return decodeString(buffer);\n        case ProtocolValueType.Number:\n            return decodeNumber(buffer);\n        case ProtocolValueType.Null:\n            return null;\n        case ProtocolValueType.Bytes: {\n            const length = decodeLength(buffer);\n            return buffer.shiftN(length);\n        }\n        case ProtocolValueType.Id:\n            return decodeId(buffer);\n        case ProtocolValueType.NonNegativeInt:\n            return decodeNonNegativeInt(buffer);\n        case ProtocolValueType.Json: {\n            const length = decodeLength(buffer);\n            const bytes = buffer.shiftN(length);\n            return JSON.stringify(packr.unpack(bytes));\n        }\n        case ProtocolValueType.DateIsoWithNonNegativeTime:\n        case ProtocolValueType.DateIsoWithNegativeTime: {\n            const time = type === ProtocolValueType.DateIsoWithNonNegativeTime\n                ? decodeNonNegativeInt(buffer)\n                : decodeNumber(buffer);\n            const dateIso = DateIso.fromParent(new Date(time).toISOString());\n            if (!dateIso.ok)\n                throw new ProtocolDecodeError(dateIso.error.type);\n            return dateIso.value;\n        }\n        case ProtocolValueType.EmptyString:\n            return \"\";\n        case ProtocolValueType.Base64Url: {\n            const length = decodeLength(buffer);\n            const bytes = buffer.shiftN(length);\n            return uint8ArrayToBase64Url(bytes);\n        }\n        default:\n            throw new ProtocolDecodeError(\"invalid ProtocolValueType\");\n    }\n};\n/**\n * Decodes a ProtocolMessage into a readable JSON object for debugging.\n *\n * Note: This is a stub for future implementation. It should use:\n *\n * - DecodeVersionAndOwner\n * - DecodeError or decodeWriteKeys (depending on context)\n * - DecodeMessages\n * - DecodeRanges\n *\n * If you want to help, please contribute to this function.\n */\nexport const decodeProtocolMessageToJson = (_protocolMessage, _isInitiator) => {\n    // TODO: Implement using\n    // - decodeVersionAndOwner\n    // -- decodeError or decodeWriteKeys (should be refactored out),\n    // -- decodeMessages, and decodeRanges.\n    // This is a stub for PRs and community contributions.\n    throw new Error(\"decodeProtocolMessageToJson is not implemented yet.\");\n};\n", "import { bytesToHex, hexToBytes } from \"../Buffer.js\";\nimport { createRandomBytes } from \"../Crypto.js\";\nimport { createRecord, isPlainObject, objectToEntries, } from \"../Object.js\";\nimport { ok } from \"../Result.js\";\nimport { eqSqliteValue, explainSqliteQueryPlan, } from \"../Sqlite.js\";\nimport { createId, String } from \"../Type.js\";\n/**\n * Evolu serializes {@link SqliteQuery} into a string to be easily used as a key\n * and for comparison.\n */\nexport const serializeQuery = (query) => {\n    const params = query.parameters.map((v) => v instanceof Uint8Array\n        ? [\"b\", bytesToHex(v)]\n        : [\"j\", v]);\n    const options = query.options\n        ? objectToEntries(query.options).toSorted(([a], [b]) => a.localeCompare(b))\n        : [];\n    return JSON.stringify([query.sql, params, options]);\n};\nexport const deserializeQuery = (query) => {\n    const [sql, paramsArr, optionsArr] = JSON.parse(query);\n    const parameters = paramsArr.map(([type, value]) => type === \"b\" ? hexToBytes(value) : value);\n    const options = optionsArr.length\n        ? Object.fromEntries(optionsArr)\n        : undefined;\n    return {\n        sql,\n        parameters,\n        ...(options !== undefined && { options }),\n    };\n};\n// To preserve identity.\nexport const emptyRows = [];\nexport const createSubscribedQueries = (rowsStore) => {\n    const subscribedQueryMap = new Map();\n    const subscribedQueries = {\n        subscribe: (query) => (listener) => {\n            subscribedQueryMap.set(query, (subscribedQueryMap.get(query) ?? 0) + 1);\n            const unsubscribe = rowsStore.subscribe(listener);\n            return () => {\n                const count = subscribedQueryMap.get(query);\n                if (count != null && count > 1) {\n                    subscribedQueryMap.set(query, count - 1);\n                }\n                else {\n                    subscribedQueryMap.delete(query);\n                }\n                unsubscribe();\n            };\n        },\n        get: () => [...subscribedQueryMap.keys()],\n        has: (query) => subscribedQueryMap.has(query),\n    };\n    return subscribedQueries;\n};\nexport const createGetQueryRowsCache = () => {\n    const tabQueryRowsCacheMap = new Map();\n    return (tabId) => {\n        let cache = tabQueryRowsCacheMap.get(tabId);\n        if (!cache) {\n            let queryRowsCache = new Map();\n            cache = {\n                set: (queriesRows) => {\n                    queryRowsCache = new Map([...queryRowsCache, ...queriesRows]);\n                },\n                get: () => queryRowsCache,\n            };\n            tabQueryRowsCacheMap.set(tabId, cache);\n        }\n        return cache;\n    };\n};\nexport const loadQueries = (deps) => (tabId, queries) => {\n    const queriesRows = [];\n    for (const query of queries) {\n        const sqlQuery = deserializeQuery(query);\n        const result = deps.sqlite.exec(sqlQuery);\n        if (!result.ok)\n            return result;\n        queriesRows.push([query, result.value.rows]);\n        if (sqlQuery.options?.logExplainQueryPlan) {\n            explainSqliteQueryPlan(deps)(sqlQuery);\n        }\n    }\n    const queryRowsCache = deps.getQueryRowsCache(tabId);\n    const previousState = queryRowsCache.get();\n    queryRowsCache.set(queriesRows);\n    const currentState = queryRowsCache.get();\n    const queryPatchesArray = queries.map((query) => ({\n        query,\n        patches: makePatches(previousState.get(query), currentState.get(query) ?? emptyRows),\n    }));\n    return ok(queryPatchesArray);\n};\n/**\n * We detect only changes in the whole result and in-place edits. In the future,\n * we will add more heuristics. We will probably not implement the Myers diff\n * algorithm because it's faster to rerender all than to compute many detailed\n * patches. We will only implement logic a developer would implement manually,\n * if necessary.\n */\nexport const makePatches = (previousRows, nextRows) => {\n    if (previousRows === undefined)\n        return [{ op: \"replaceAll\", value: nextRows }];\n    // TODO: Detect prepend and append, it's cheap.\n    if (previousRows.length !== nextRows.length) {\n        return [{ op: \"replaceAll\", value: nextRows }];\n    }\n    const length = previousRows.length;\n    const replaceAtPatches = [];\n    for (let i = 0; i < length; i++) {\n        const previousRow = previousRows[i];\n        const nextRow = nextRows[i];\n        // We expect the same shape for both rows.\n        for (const key in previousRow)\n            if (!eqSqliteValue(previousRow[key], nextRow[key])) {\n                replaceAtPatches.push({ op: \"replaceAt\", value: nextRow, index: i });\n                break;\n            }\n    }\n    if (length > 0 && replaceAtPatches.length === length) {\n        return [{ op: \"replaceAll\", value: nextRows }];\n    }\n    return replaceAtPatches;\n};\nexport const applyPatches = (patches, current) => patches.reduce((next, patch) => {\n    switch (patch.op) {\n        case \"replaceAll\":\n            return parseSqliteJsonArray(patch.value);\n        case \"replaceAt\": {\n            const parsedRow = parseSqliteJsonArray([patch.value])[0];\n            return next.toSpliced(patch.index, 1, parsedRow);\n        }\n    }\n}, current);\n/**\n * A unique identifier prepended to JSON-encoded strings. This allows safe\n * detection and parsing of only those columns that require JSON.parse.\n *\n * The identifier is a cryptographically random Evolu Id, ensuring uniqueness\n * and preventing malicious actors from inserting fake data that could be\n * misinterpreted as JSON by the application.\n *\n * Note: The same queries created by different browser tabs will have different\n * identifiers and thus be considered different and cached separately. This is\n * usually not a big deal, but if needed, the DB cache can be optimized by\n * passing the kyselyJsonIdentifier into the DB worker during initialization,\n * allowing queries to be grouped and recognized across tabs or sessions.\n *\n * See: https://github.com/kysely-org/kysely/issues/1372#issuecomment-2702773948\n */\nexport const kyselyJsonIdentifier = createId({\n    randomBytes: createRandomBytes(),\n});\nexport const parseSqliteJsonArray = (arr) => {\n    const result = new Array(arr.length);\n    for (let i = 0; i < arr.length; ++i) {\n        result[i] = parse(arr[i]);\n    }\n    return result;\n};\nconst parse = (obj) => {\n    if (String.is(obj) && obj.startsWith(kyselyJsonIdentifier)) {\n        return JSON.parse(obj.slice(kyselyJsonIdentifier.length));\n    }\n    if (Array.isArray(obj)) {\n        return parseSqliteJsonArray(obj);\n    }\n    if (isPlainObject(obj)) {\n        return parseObject(obj);\n    }\n    return obj;\n};\nconst parseObject = (obj) => {\n    const result = createRecord();\n    for (const key in obj) {\n        result[key] = parse(obj[key]);\n    }\n    return result;\n};\n", "import { err, ok } from \"./Result.js\";\nimport { PositiveInt } from \"./Type.js\";\n/**\n * Creates {@link Resources}.\n *\n * This tracks which consumers are using which resources and maintains reference\n * counts to know when it's safe to dispose resources. Resources are created\n * on-demand and disposed with a configurable delay to avoid churn.\n *\n * ### Example Usage\n *\n * ```ts\n * // WebSocket connections\n * interface WebSocketConfig {\n *   readonly url: WebSocketUrl;\n * }\n *\n * type WebSocketUrl = string & Brand<\"WebSocketUrl\">;\n * type UserId = string & Brand<\"UserId\">;\n *\n * const webSockets = createResources<\n *   WebSocket,\n *   WebSocketUrl,\n *   WebSocketConfig,\n *   User,\n *   UserId\n * >({\n *   createResource: (config) => new WebSocket(config.url),\n *   getResourceKey: (config) => config.url,\n *   getConsumerId: (user) => user.id,\n *   disposalDelay: 1000,\n * });\n *\n * // Add users to WebSocket connections\n * webSockets.addConsumer(user1, [\n *   { url: \"ws://server1.com\" as WebSocketUrl },\n *   { url: \"ws://server2.com\" as WebSocketUrl },\n * ]);\n * webSockets.addConsumer(user2, [\n *   { url: \"ws://server1.com\" as WebSocketUrl },\n * ]);\n *\n * // Remove users - server1 stays alive (user2 still using it)\n * webSockets.removeConsumer(user1, [\n *   { url: \"ws://server1.com\" as WebSocketUrl },\n *   { url: \"ws://server2.com\" as WebSocketUrl },\n * ]);\n *\n * // server2 gets disposed after delay, server1 stays alive\n * ```\n */\nexport const createResources = (config) => {\n    let isDisposed = false;\n    const resourcesMap = new Map();\n    const consumerCounts = new Map();\n    const consumers = new Map();\n    const disposalTimeouts = new Map();\n    const disposalDelay = config.disposalDelay ?? 100;\n    const ensureResource = (resourceConfig) => {\n        const key = config.getResourceKey(resourceConfig);\n        const timeout = disposalTimeouts.get(key);\n        if (timeout) {\n            clearTimeout(timeout);\n            disposalTimeouts.delete(key);\n        }\n        if (!resourcesMap.has(key)) {\n            const resource = config.createResource(resourceConfig);\n            resourcesMap.set(key, resource);\n        }\n    };\n    const scheduleDisposal = (key) => {\n        const timeout = setTimeout(() => {\n            const resource = resourcesMap.get(key);\n            if (resource) {\n                resource[Symbol.dispose]();\n                resourcesMap.delete(key);\n            }\n            disposalTimeouts.delete(key);\n        }, disposalDelay);\n        disposalTimeouts.set(key, timeout);\n    };\n    const resources = {\n        addConsumer: (consumer, resourceConfigs) => {\n            if (isDisposed)\n                return;\n            const consumerId = config.getConsumerId(consumer);\n            // Store consumer (last added consumer for this ID)\n            consumers.set(consumerId, consumer);\n            for (const resourceConfig of resourceConfigs) {\n                ensureResource(resourceConfig);\n                const resourceKey = config.getResourceKey(resourceConfig);\n                let counts = consumerCounts.get(resourceKey);\n                if (!counts) {\n                    counts = new Map();\n                    consumerCounts.set(resourceKey, counts);\n                }\n                const currentCount = counts.get(consumerId) ?? 0;\n                const newCount = currentCount + 1;\n                counts.set(consumerId, PositiveInt.orThrow(newCount));\n                // Call onConsumerAdded callback only when consumer is added for the first time (0 -> 1)\n                if (currentCount === 0 && config.onConsumerAdded) {\n                    const resource = resourcesMap.get(resourceKey);\n                    if (resource) {\n                        config.onConsumerAdded(consumer, resource, resourceKey);\n                    }\n                }\n            }\n        },\n        removeConsumer: (consumer, resourceConfigs) => {\n            if (isDisposed)\n                return ok();\n            const consumerId = config.getConsumerId(consumer);\n            for (const resourceConfig of resourceConfigs) {\n                const key = config.getResourceKey(resourceConfig);\n                const counts = consumerCounts.get(key);\n                if (!counts) {\n                    return err({ type: \"ResourceNotFoundError\", resourceKey: key });\n                }\n                const currentCount = counts.get(consumerId);\n                if (currentCount == null) {\n                    return err({\n                        type: \"ConsumerNotFoundError\",\n                        consumerId: consumerId,\n                        resourceKey: key,\n                    });\n                }\n                if (currentCount === 1) {\n                    counts.delete(consumerId);\n                    // Call onConsumerRemoved callback only when consumer is completely removed (1 -> 0)\n                    if (config.onConsumerRemoved) {\n                        const resource = resourcesMap.get(key);\n                        if (resource) {\n                            config.onConsumerRemoved(consumer, resource, key);\n                        }\n                    }\n                    if (counts.size === 0) {\n                        consumerCounts.delete(key);\n                        scheduleDisposal(key);\n                    }\n                }\n                else {\n                    counts.set(consumerId, PositiveInt.orThrow(currentCount - 1));\n                }\n            }\n            if (!resources.hasConsumerAnyResource(consumer)) {\n                consumers.delete(consumerId);\n            }\n            return ok();\n        },\n        getResource: (key) => {\n            if (isDisposed)\n                return null;\n            return resourcesMap.get(key) ?? null;\n        },\n        getConsumersForResource: (key) => {\n            if (isDisposed)\n                return [];\n            const counts = consumerCounts.get(key);\n            return counts ? Array.from(counts.keys()) : [];\n        },\n        hasConsumerAnyResource: (consumer) => {\n            if (isDisposed)\n                return false;\n            const consumerId = config.getConsumerId(consumer);\n            // If slow, can be optimized with reverse index\n            return Array.from(consumerCounts.values()).some((counts) => counts.has(consumerId));\n        },\n        getConsumer: (consumerId) => {\n            if (isDisposed)\n                return null;\n            const consumer = consumers.get(consumerId);\n            if (!consumer)\n                return null;\n            // Only return consumer if it's currently using any resources\n            if (!resources.hasConsumerAnyResource(consumer)) {\n                return null;\n            }\n            return consumer;\n        },\n        [Symbol.dispose]: () => {\n            if (isDisposed)\n                return;\n            isDisposed = true;\n            for (const timeout of disposalTimeouts.values()) {\n                clearTimeout(timeout);\n            }\n            disposalTimeouts.clear();\n            for (const resource of resourcesMap.values()) {\n                resource[Symbol.dispose]();\n            }\n            resourcesMap.clear();\n            consumerCounts.clear();\n            consumers.clear();\n        },\n    };\n    return resources;\n};\n", "import { assert } from \"./Assert.js\";\nimport { DateIso, NonNegativeInt } from \"./Type.js\";\n/**\n * Creates a {@link Time} using Date.now().\n *\n * If the system clock is misconfigured (out of allowed range), the application\n * will fail with an assertion error. This is intentional - there's no\n * reasonable fallback when the system clock is fundamentally wrong.\n */\nexport const createTime = () => {\n    const time = {\n        now: () => {\n            const iso = time.nowIso();\n            return new globalThis.Date(iso).getTime();\n        },\n        nowIso: () => {\n            const iso = new globalThis.Date().toISOString();\n            assert(DateIso.is(iso), \"System clock returned invalid ISO date\");\n            return iso;\n        },\n    };\n    return time;\n};\n/**\n * Creates a {@link Time} that returns a monotonically increasing number based on\n * a queueMicrotask.\n */\nexport const createTestTime = () => {\n    let now = 0;\n    const time = {\n        now: () => {\n            const current = now;\n            queueMicrotask(() => {\n                now++;\n            });\n            return current;\n        },\n        nowIso: () => DateIso.orThrow(new globalThis.Date(time.now()).toISOString()),\n    };\n    return time;\n};\n/**\n * Converts a duration to milliseconds.\n *\n * Accepts either a {@link DurationString} (e.g., \"5m\", \"1h 30m\") or milliseconds\n * as {@link NonNegativeInt}.\n *\n * ### Example\n *\n * ```ts\n * durationToNonNegativeInt(\"0ms\"); // 0 \n * durationToNonNegativeInt(\"500ms\"); // 500 \n * durationToNonNegativeInt(\"30s\"); // 30000 \n * durationToNonNegativeInt(\"5m\"); // 300000 \n * durationToNonNegativeInt(\"12h\"); // 43200000 \n * durationToNonNegativeInt(\"7d\"); // 604800000 \n * durationToNonNegativeInt(\"2h 45m\"); // 9900000 \n * durationToNonNegativeInt(5000); // 5000  (already milliseconds)\n * ```\n */\nexport const durationToNonNegativeInt = (duration) => {\n    // If it's already a NonNegativeInt (milliseconds), return as-is\n    if (typeof duration === \"number\") {\n        return duration;\n    }\n    // Parse duration string without regex to avoid ReDoS vulnerabilities\n    const units = {\n        ms: 1,\n        s: 1000,\n        m: 60000,\n        h: 3600000,\n        d: 86400000, // 24 * 60 * 60 * 1000\n    };\n    let total = 0;\n    let i = 0;\n    while (i < duration.length) {\n        // Skip whitespace\n        while (i < duration.length && duration[i] === \" \") {\n            i++;\n        }\n        if (i >= duration.length)\n            break;\n        // Parse number\n        let numStr = \"\";\n        while (i < duration.length && duration[i] >= \"0\" && duration[i] <= \"9\") {\n            numStr += duration[i];\n            i++;\n        }\n        if (numStr === \"\")\n            break;\n        // Parse unit (ms or single char s/m/h/d)\n        let unit = \"\";\n        if (i < duration.length) {\n            if (duration[i] === \"m\" &&\n                i + 1 < duration.length &&\n                duration[i + 1] === \"s\") {\n                unit = \"ms\";\n                i += 2;\n            }\n            else if (duration[i] === \"s\" ||\n                duration[i] === \"m\" ||\n                duration[i] === \"h\" ||\n                duration[i] === \"d\") {\n                unit = duration[i];\n                i++;\n            }\n        }\n        if (unit === \"\")\n            break;\n        const value = parseInt(numStr, 10);\n        total += value * units[unit];\n    }\n    return NonNegativeInt.orThrow(total);\n};\n", "import { isNonEmptyArray, shiftArray } from \"./Array.js\";\nimport { err, ok } from \"./Result.js\";\nimport { durationToNonNegativeInt } from \"./Time.js\";\nimport { NonNegativeInt, PositiveInt } from \"./Type.js\";\n/** Narrower check to detect AbortError objects at runtime. */\nconst isAbortError = (error) => typeof error === \"object\" &&\n    error !== null &&\n    error.type === \"AbortError\";\n// For React Native\nif (typeof AbortSignal.any !== \"function\") {\n    AbortSignal.any = function (signals) {\n        const controller = new AbortController();\n        const onAbort = (event) => {\n            controller.abort(event.target.reason);\n            cleanup();\n        };\n        const cleanup = () => {\n            for (const s of signals)\n                s.removeEventListener(\"abort\", onAbort);\n        };\n        for (const s of signals) {\n            if (s.aborted) {\n                controller.abort(s.reason);\n                return controller.signal;\n            }\n            s.addEventListener(\"abort\", onAbort);\n        }\n        return controller.signal;\n    };\n}\n/**\n * Combines user signal from context with an internal signal.\n *\n * If the context has a signal, combines both signals using AbortSignal.any().\n * Otherwise, returns just the internal signal.\n */\nconst combineSignal = (context, internalSignal) => context?.signal\n    ? AbortSignal.any([context.signal, internalSignal])\n    : internalSignal;\n/**\n * Converts async function returning {@link Result} to a {@link Task}.\n *\n * ### Example\n *\n * ```ts\n * interface FetchError {\n *   readonly type: \"FetchError\";\n *   readonly error: unknown;\n * }\n *\n * // Task version of fetch with proper error handling and cancellation support.\n * const fetch = (url: string) =>\n *   toTask((context) =>\n *     tryAsync(\n *       () => globalThis.fetch(url, { signal: context?.signal ?? null }),\n *       (error): FetchError => ({ type: \"FetchError\", error }),\n *     ),\n *   );\n *\n * // `satisfies` shows the expected type signature.\n * fetch satisfies (url: string) => Task<Response, FetchError>;\n *\n * const result1 = await fetch(\"https://api.example.com/data\")();\n * result1 satisfies Result<Response, FetchError>;\n *\n * // With AbortController\n * const controller = new AbortController();\n * const result2 = await fetch(\"https://api.example.com/data\")(controller);\n * result2 satisfies Result<Response, FetchError | AbortError>;\n * ```\n */\nexport const toTask = (fn) => \n// Note: Not using async to avoid Promise wrapper overhead in fast path\n((context) => {\n    const signal = context?.signal;\n    // Fast path when no signal  return promise directly\n    if (!signal) {\n        // Preserve future context fields (e.g., tracing) even without a signal\n        return fn(context);\n    }\n    if (signal.aborted) {\n        return Promise.resolve(err({ type: \"AbortError\", reason: signal.reason }));\n    }\n    // Use Promise.withResolvers for clean abort handling and cleanup\n    const { promise: abortPromise, resolve: resolveAbort } = Promise.withResolvers();\n    const handleAbort = () => {\n        resolveAbort(err({ type: \"AbortError\", reason: signal.reason }));\n    };\n    signal.addEventListener(\"abort\", handleAbort, { once: true });\n    // No finally: we expect no throws in normal flow; Result path removes listener.\n    // Unexpected throws indicate a bug and are allowed to crash (no recovery here).\n    return Promise.race([\n        abortPromise,\n        fn(context).then((result) => {\n            signal.removeEventListener(\"abort\", handleAbort);\n            return result;\n        }),\n    ]);\n});\n// For React Native\nif (typeof AbortSignal.timeout !== \"function\") {\n    AbortSignal.timeout = function (ms) {\n        const controller = new AbortController();\n        const id = setTimeout(() => {\n            controller.abort();\n        }, ms);\n        // clear timeout if aborted early\n        controller.signal.addEventListener(\"abort\", () => {\n            clearTimeout(id);\n        });\n        return controller.signal;\n    };\n}\n/**\n * Creates a {@link Task} that waits for the specified duration.\n *\n * ### Example\n *\n * ```ts\n * const result1 = await wait(\"10ms\")();\n * result1 satisfies Result<void, never>;\n *\n * // With AbortController\n * const controller = new AbortController();\n * const result2 = await wait(\"10ms\")(controller);\n * result2 satisfies Result<void, AbortError>;\n * ```\n */\nexport const wait = (duration) => toTask((context) => new Promise((resolve) => {\n    const ms = durationToNonNegativeInt(duration);\n    const timeoutSignal = AbortSignal.timeout(ms);\n    const signal = combineSignal(context, timeoutSignal);\n    // Listen for abort - either from timeout completion or external abort\n    signal.addEventListener(\"abort\", () => {\n        resolve(ok());\n    }, { once: true });\n}));\n/**\n * Adds timeout behavior to a {@link Task}.\n *\n * ### Example\n *\n * ```ts\n * interface FetchError {\n *   readonly type: \"FetchError\";\n *   readonly error: unknown;\n * }\n *\n * // Task version of fetch with proper error handling and cancellation support.\n * const fetch = (url: string) =>\n *   toTask((context) =>\n *     tryAsync(\n *       () => globalThis.fetch(url, { signal: context?.signal ?? null }),\n *       (error): FetchError => ({ type: \"FetchError\", error }),\n *     ),\n *   );\n *\n * // `satisfies` shows the expected type signature.\n * fetch satisfies (url: string) => Task<Response, FetchError>;\n *\n * const fetchWithTimeout = (url: string) => timeout(\"2m\", fetch(url));\n *\n * const result1 = await fetchWithTimeout(\"https://api.example.com/data\")();\n * result1 satisfies Result<Response, FetchError | TimeoutError>;\n *\n * // With AbortController\n * const controller = new AbortController();\n * const result2 = await fetchWithTimeout(\"https://api.example.com/data\")(\n *   controller,\n * );\n * result2 satisfies Result<\n *   Response,\n *   FetchError | TimeoutError | AbortError\n * >;\n * ```\n */\nexport const timeout = (duration, task) => toTask(async (context) => {\n    const timeoutMs = durationToNonNegativeInt(duration);\n    const timeoutSignal = AbortSignal.timeout(timeoutMs);\n    const signal = combineSignal(context, timeoutSignal);\n    const result = await task({ signal });\n    if (timeoutSignal.aborted) {\n        return err({ type: \"TimeoutError\", timeoutMs });\n    }\n    return result;\n});\n/**\n * Adds retry logic with exponential backoff and jitter to a {@link Task}.\n *\n * ### Example\n *\n * ```ts\n * interface FetchError {\n *   readonly type: \"FetchError\";\n *   readonly error: unknown;\n * }\n *\n * // Task version of fetch with proper error handling and cancellation support.\n * const fetch = (url: string) =>\n *   toTask((context) =>\n *     tryAsync(\n *       () => globalThis.fetch(url, { signal: context?.signal ?? null }),\n *       (error): FetchError => ({ type: \"FetchError\", error }),\n *     ),\n *   );\n *\n * // `satisfies` shows the expected type signature.\n * fetch satisfies (url: string) => Task<Response, FetchError>;\n *\n * const fetchWithRetry = (url: string) =>\n *   retry({ retries: PositiveInt.orThrow(3) }, fetch(url));\n *\n * const result1 = await fetchWithRetry(\"https://api.example.com/data\")();\n * result1 satisfies Result<Response, FetchError | RetryError<FetchError>>;\n *\n * // With AbortController\n * const controller = new AbortController();\n * const result2 = await fetchWithRetry(\"https://api.example.com/data\")(\n *   controller,\n * );\n * result2 satisfies Result<\n *   Response,\n *   FetchError | RetryError<FetchError> | AbortError\n * >;\n * ```\n */\nexport const retry = ({ retries, initialDelay = \"1s\", maxDelay = \"30s\", factor = 2, jitter = 0.5, retryable = (error) => !isAbortError(error), onRetry, }, task) => toTask(async (context) => {\n    const initialDelayMs = durationToNonNegativeInt(initialDelay);\n    const maxDelayMs = durationToNonNegativeInt(maxDelay);\n    const maxRetries = PositiveInt.orThrow(retries);\n    let attempt = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (true) {\n        const result = await task(context);\n        if (result.ok) {\n            return result;\n        }\n        // Never retry on AbortError; propagate it directly\n        if (isAbortError(result.error)) {\n            return err(result.error);\n        }\n        attempt += 1;\n        if (attempt > maxRetries || !retryable(result.error)) {\n            return err({\n                type: \"RetryError\",\n                cause: result.error,\n                attempts: attempt,\n            });\n        }\n        // Calculate delay with exponential backoff\n        const exponentialDelay = initialDelayMs * Math.pow(factor, attempt - 1);\n        const cappedDelay = Math.min(exponentialDelay, maxDelayMs);\n        // Apply jitter to prevent thundering herd problem\n        const randomFactor = 1 - jitter + Math.random() * jitter * 2;\n        const delay = Math.floor(cappedDelay * randomFactor);\n        if (onRetry) {\n            onRetry(result.error, attempt, delay);\n        }\n        // Wait before retry\n        {\n            const result = await wait(NonNegativeInt.orThrow(delay))(context);\n            if (!result.ok) {\n                // If delay was aborted, return AbortError (will be handled by toTask)\n                return result;\n            }\n        }\n    }\n});\n/**\n * Creates a semaphore that limits concurrent async Tasks to the specified\n * count.\n *\n * A semaphore controls access to a resource by maintaining a count of available\n * permits. Tasks acquire a permit before executing and release it when\n * complete.\n *\n * For mutual exclusion (exactly one Task at a time), consider using\n * {@link createMutex} instead.\n *\n * ### Example\n *\n * ```ts\n * // Allow maximum 3 concurrent Tasks\n * const semaphore = createSemaphore(PositiveInt.orThrow(3));\n *\n * let currentConcurrent = 0;\n * const events: Array<string> = [];\n *\n * const fetchData = (id: number) =>\n *   toTask<number, never>(async (context) => {\n *     currentConcurrent++;\n *     events.push(`start ${id} (concurrent: ${currentConcurrent})`);\n *\n *     await wait(\"10ms\")(context);\n *\n *     currentConcurrent--;\n *     events.push(`end ${id} (concurrent: ${currentConcurrent})`);\n *     return ok(id * 10);\n *   });\n *\n * // These will execute with at most 3 running concurrently\n * const results = await Promise.all([\n *   semaphore.withPermit(fetchData(1))(),\n *   semaphore.withPermit(fetchData(2))(),\n *   semaphore.withPermit(fetchData(3))(),\n *   semaphore.withPermit(fetchData(4))(), // waits for one above to complete\n *   semaphore.withPermit(fetchData(5))(), // waits for permit\n * ]);\n *\n * expect(results.map(getOrThrow)).toEqual([10, 20, 30, 40, 50]);\n * expect(events).toMatchInlineSnapshot(`\n *   [\n *     \"start 1 (concurrent: 1)\",\n *     \"start 2 (concurrent: 2)\",\n *     \"start 3 (concurrent: 3)\",\n *     \"end 1 (concurrent: 2)\",\n *     \"start 4 (concurrent: 3)\",\n *     \"end 2 (concurrent: 2)\",\n *     \"start 5 (concurrent: 3)\",\n *     \"end 3 (concurrent: 2)\",\n *     \"end 4 (concurrent: 1)\",\n *     \"end 5 (concurrent: 0)\",\n *   ]\n * `);\n * ```\n */\nexport const createSemaphore = (maxConcurrent) => {\n    let isDisposed = false;\n    let availablePermits = maxConcurrent;\n    const waitingQueue = [];\n    const semaphoreController = new AbortController();\n    const acquire = () => {\n        if (availablePermits > 0) {\n            availablePermits--;\n            return Promise.resolve();\n        }\n        return new Promise((resolve) => {\n            waitingQueue.push(resolve);\n        });\n    };\n    const release = () => {\n        if (isNonEmptyArray(waitingQueue)) {\n            shiftArray(waitingQueue)();\n        }\n        else {\n            availablePermits++;\n        }\n    };\n    return {\n        withPermit: (task) => toTask(async (context) => {\n            await acquire();\n            // Check if semaphore was disposed while waiting\n            if (isDisposed) {\n                return err({\n                    type: \"AbortError\",\n                    reason: \"Semaphore disposed\",\n                });\n            }\n            const signal = combineSignal(context, semaphoreController.signal);\n            const result = await task({ signal });\n            release();\n            return result;\n        }),\n        [Symbol.dispose]: () => {\n            if (isDisposed)\n                return;\n            isDisposed = true;\n            // Cancel all running and waiting tasks\n            semaphoreController.abort(\"Semaphore disposed\");\n            // Release all waiting tasks so they can continue and check isDisposed\n            while (isNonEmptyArray(waitingQueue)) {\n                shiftArray(waitingQueue)();\n            }\n        },\n    };\n};\n/**\n * Creates a new mutex for ensuring mutual exclusion.\n *\n * A mutex is a {@link createSemaphore} with exactly one permit, ensuring that\n * only one Task can execute at a time.\n *\n * ### Example\n *\n * ```ts\n * const mutex = createMutex();\n *\n * const updateTask = (id: number) =>\n *   toTask((context) =>\n *     tryAsync(\n *       () => updateSharedResource(id, context),\n *       (error): UpdateError => ({ type: \"UpdateError\", error }),\n *     ),\n *   );\n *\n * // These Tasks will execute one at a time\n * const results = await Promise.all([\n *   mutex.withLock(updateTask(1))(),\n *   mutex.withLock(updateTask(2))(),\n *   mutex.withLock(updateTask(3))(),\n * ]);\n * ```\n */\nexport const createMutex = () => {\n    const mutex = createSemaphore(PositiveInt.orThrow(1));\n    return {\n        withLock: mutex.withPermit,\n        [Symbol.dispose]: mutex[Symbol.dispose],\n    };\n};\n/**\n * Schedule a task to run after all interactions (animations, gestures,\n * navigation) have completed.\n *\n * This uses `requestIdleCallback` when available, otherwise falls back to\n * `setTimeout(0)` for cross-platform compatibility.\n *\n * ### Example\n *\n * ```ts\n * const processDataTask: Task<void, ProcessError> = toTask(async () => {\n *   // Heavy processing work\n *   return ok();\n * });\n *\n * // Schedule the task to run when idle\n * void requestIdleTask(processDataTask)();\n * ```\n */\nexport const requestIdleTask = (task) => toTask(async (context) => new Promise((resolve) => {\n    idleCallback(() => {\n        void task(context).then(resolve);\n    });\n}));\nconst idleCallback = typeof globalThis.requestIdleCallback === \"function\"\n    ? globalThis.requestIdleCallback\n    : (callback) => setTimeout(callback, 0);\n/**\n * Type guard to check if a {@link MaybeAsync} value is async (a promise).\n *\n * This function narrows the type of a {@link MaybeAsync} value, allowing you to\n * conditionally `await` only when necessary.\n *\n * ### Example\n *\n * ```ts\n * const getData = (id: string): MaybeAsync<Data> => {\n *   const cached = cache.get(id);\n *   if (cached) return cached; // Sync path\n *   return fetchData(id); // Async path\n * };\n *\n * const result = getData(id);\n * const data = isAsync(result) ? await result : result;\n * // No microtask overhead when cached!\n * ```\n */\nexport const isAsync = (value) => \n// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\ntypeof value?.then === \"function\";\n// TODO: Add tracing support\n// - Extend TaskContext with optional tracing field\n// - Add traced(name, task) helper that wraps Task execution\n// - Collect span data (name, timing, parent-child relationships, status)\n// - Support OpenTelemetry export format with proper traceId/spanId generation\n// - Automatic parent-child span relationships through context propagation\n", "import { appendToArray, firstInArray, isNonEmptyReadonlyArray, } from \"../Array.js\";\nimport { assertNonEmptyReadonlyArray } from \"../Assert.js\";\nimport { createTransferableError } from \"../Error.js\";\nimport { constFalse, constTrue } from \"../Function.js\";\nimport { createRecord, getProperty, objectToEntries } from \"../Object.js\";\nimport { createResources } from \"../Resources.js\";\nimport { err, ok } from \"../Result.js\";\nimport { booleanToSqliteBoolean, sql, SqliteBoolean, sqliteBooleanToBoolean, } from \"../Sqlite.js\";\nimport { createMutex } from \"../Task.js\";\nimport { idBytesToId, idToIdBytes, } from \"../Type.js\";\nimport { ownerIdBytesToOwnerId, ownerIdToOwnerIdBytes, } from \"./Owner.js\";\nimport { applyProtocolMessageAsClient, createProtocolMessageForSync, createProtocolMessageForUnsubscribe, createProtocolMessageFromCrdtMessages, decryptAndDecodeDbChange, encodeAndEncryptDbChange, SubscriptionFlags, } from \"./Protocol.js\";\nimport { systemColumns } from \"./Schema.js\";\nimport { createBaseSqliteStorage, DbChange, getOwnerUsage, getTimestampInsertStrategy, updateOwnerUsage, } from \"./Storage.js\";\nimport { createInitialTimestamp, receiveTimestamp, sendTimestamp, timestampBytesToTimestamp, timestampToDateIso, timestampToTimestampBytes, } from \"./Timestamp.js\";\nexport const createSync = (deps) => (config) => {\n    let isDisposed = false;\n    /** Returns owner data only if actively assigned to at least one transport. */\n    const getSyncOwner = (ownerId) => {\n        if (isDisposed)\n            return null;\n        return resources.getConsumer(ownerId);\n    };\n    const storageResult = createClientStorage({\n        ...deps,\n        getSyncOwner,\n    })(config);\n    if (!storageResult.ok)\n        return storageResult;\n    const storage = storageResult.value;\n    const createResource = (transport) => {\n        const transportKey = createTransportKey(transport);\n        deps.console.log(\"[sync]\", \"createWebSocket\", {\n            transportKey,\n            url: transport.url,\n        });\n        return deps.createWebSocket(transport.url, {\n            binaryType: \"arraybuffer\",\n            onOpen: () => {\n                if (isDisposed)\n                    return;\n                const webSocket = resources.getResource(transportKey);\n                if (!webSocket)\n                    return;\n                const ownerIds = resources.getConsumersForResource(transportKey);\n                deps.console.log(\"[sync]\", \"onOpen\", { transportKey, ownerIds });\n                for (const ownerId of ownerIds) {\n                    const message = createProtocolMessageForSync({ storage })(ownerId, SubscriptionFlags.Subscribe);\n                    if (!message)\n                        continue;\n                    deps.console.log(\"[sync]\", \"send\", { message });\n                    webSocket.send(message);\n                }\n            },\n            onClose: (event) => {\n                deps.console.log(\"[sync]\", \"onClose\", {\n                    transportKey,\n                    code: event.code,\n                    reason: event.reason,\n                    wasClean: event.wasClean,\n                });\n            },\n            onError: (error) => {\n                deps.console.warn(\"[sync]\", \"onError\", { transportKey, error });\n            },\n            onMessage: (data) => {\n                // Only handle ArrayBuffer data for sync messages\n                if (isDisposed || !(data instanceof ArrayBuffer))\n                    return;\n                const webSocket = resources.getResource(transportKey);\n                if (!webSocket)\n                    return;\n                const input = new Uint8Array(data);\n                deps.console.log(\"[sync]\", \"onMessage\", {\n                    transportKey,\n                    message: input,\n                });\n                applyProtocolMessageAsClient({ storage })(input, {\n                    // No write key, no sync (for a case when an owner was unused).\n                    getWriteKey: (ownerId) => getSyncOwner(ownerId)?.writeKey ?? null,\n                })\n                    .then((message) => {\n                    if (!message.ok) {\n                        config.onError(message.error);\n                        return;\n                    }\n                    switch (message.value.type) {\n                        case \"response\":\n                            webSocket.send(message.value.message);\n                            break;\n                        case \"no-response\":\n                            // Sync complete, no response needed\n                            break;\n                        case \"broadcast\":\n                            // This was a broadcast message, don't affect sync counter\n                            break;\n                    }\n                })\n                    .catch((error) => {\n                    config.onError(createTransferableError(error));\n                });\n            },\n        });\n    };\n    const resources = createResources({\n        createResource,\n        getResourceKey: createTransportKey,\n        getConsumerId: (owner) => owner.id,\n        disposalDelay: config.disposalDelayMs ?? 100,\n        onConsumerAdded: (owner, webSocket) => {\n            deps.console.log(\"[sync]\", \"onConsumerAdded\", {\n                ownerId: owner.id,\n                isOpen: webSocket.isOpen(),\n            });\n            // The onOpen handler will sync it.\n            if (!webSocket.isOpen())\n                return;\n            const message = createProtocolMessageForSync({ storage })(owner.id, SubscriptionFlags.Subscribe);\n            if (message)\n                webSocket.send(message);\n        },\n        onConsumerRemoved: (owner, webSocket) => {\n            deps.console.log(\"[sync]\", \"onConsumerRemoved\", {\n                ownerId: owner.id,\n                isOpen: webSocket.isOpen(),\n            });\n            const message = createProtocolMessageForUnsubscribe(owner.id);\n            webSocket.send(message);\n        },\n    });\n    const sync = {\n        useOwner: (use, owner) => {\n            if (isDisposed) {\n                deps.console.warn(\"[sync]\", \"useOwner called on disposed Sync instance\", { owner });\n                return;\n            }\n            deps.console.log(\"[sync]\", \"useOwner\", { use, owner });\n            const transports = owner.transports ?? config.transports;\n            if (use) {\n                resources.addConsumer(owner, transports);\n            }\n            else {\n                const result = resources.removeConsumer(owner, transports);\n                if (!result.ok) {\n                    deps.console.warn(\"[sync]\", \"Failed to remove consumer\", {\n                        transports,\n                        ownerId: owner.id,\n                        error: result.error,\n                    });\n                }\n            }\n        },\n        applyChanges: (changes) => {\n            deps.console.log(\"[sync]\", \"applyChanges\", { changes });\n            let clockTimestamp = deps.clock.get();\n            const ownerMessages = new Map();\n            for (const change of changes) {\n                const nextTimestamp = sendTimestamp(deps)(clockTimestamp);\n                if (!nextTimestamp.ok)\n                    return nextTimestamp;\n                clockTimestamp = nextTimestamp.value;\n                const { ownerId = config.appOwner.id, ...dbChange } = change;\n                const message = {\n                    timestamp: clockTimestamp,\n                    change: dbChange,\n                };\n                const messages = ownerMessages.get(ownerId);\n                if (messages)\n                    messages.push(message);\n                else\n                    ownerMessages.set(ownerId, [message]);\n            }\n            for (const [ownerId, messages] of ownerMessages) {\n                const result = applyMessages({ ...deps, storage })(ownerId, messages);\n                if (!result.ok)\n                    return result;\n                const owner = getSyncOwner(ownerId);\n                if (!owner?.writeKey)\n                    continue;\n                const message = createProtocolMessageFromCrdtMessages(deps)({\n                    id: owner.id,\n                    encryptionKey: owner.encryptionKey,\n                    writeKey: owner.writeKey,\n                }, messages);\n                const transports = owner.transports ?? config.transports;\n                // Send message to all transports for this owner\n                for (const transport of transports) {\n                    const transportKey = createTransportKey(transport);\n                    const webSocket = resources.getResource(transportKey);\n                    if (!webSocket)\n                        continue;\n                    if (webSocket.isOpen()) {\n                        deps.console.log(\"[sync]\", \"send\", { transportKey, message });\n                        webSocket.send(message);\n                    }\n                }\n            }\n            return deps.clock.save(clockTimestamp);\n        },\n        [Symbol.dispose]: () => {\n            if (isDisposed)\n                return;\n            isDisposed = true;\n            resources[Symbol.dispose]();\n        },\n    };\n    return ok(sync);\n};\nexport const createClock = (deps) => (initialTimestamp = createInitialTimestamp(deps)) => {\n    let currentTimestamp = initialTimestamp;\n    return {\n        get: () => currentTimestamp,\n        save: (timestamp) => {\n            currentTimestamp = timestamp;\n            const result = deps.sqlite.exec(sql.prepared `\n          update evolu_config\n          set \"clock\" = ${timestampToTimestampBytes(timestamp)};\n        `);\n            if (!result.ok)\n                return result;\n            return ok();\n        },\n    };\n};\nconst createClientStorage = (deps) => (config) => {\n    const sqliteStorageBase = createBaseSqliteStorage(deps)({\n        onStorageError: config.onError,\n        isOwnerWithinQuota: constTrue, // Clients don't have quota limits\n    });\n    // TODO: Mutex per OwnerId\n    const mutex = createMutex();\n    const storage = {\n        ...sqliteStorageBase,\n        // Not implemented yet.\n        validateWriteKey: constFalse,\n        setWriteKey: constFalse,\n        writeMessages: async (ownerIdBytes, encryptedMessages) => {\n            const ownerId = ownerIdBytesToOwnerId(ownerIdBytes);\n            // Everything is sync now, but we will need async crypto in the future.\n            const result = await mutex.withLock(async () => {\n                const owner = deps.getSyncOwner(ownerId);\n                // Owner can be removed during syncing.\n                // `ok(true)` means success, we just skipped the write.\n                if (!owner)\n                    return ok(true);\n                // TODO: Add quota checking for collaborative scenarios.\n                // When receiving messages from other owners via relay broadcast,\n                // check if this owner is within quota before accepting the data.\n                // This prevents an owner from exceeding storage limits when receiving\n                // data shared by other collaborators.\n                const messages = [];\n                for (const message of encryptedMessages) {\n                    const change = decryptAndDecodeDbChange(deps)(message, owner.encryptionKey);\n                    if (!change.ok)\n                        return change;\n                    messages.push({\n                        timestamp: message.timestamp,\n                        change: change.value,\n                    });\n                }\n                const transaction = deps.sqlite.transaction(() => {\n                    let clockTimestamp = deps.clock.get();\n                    for (const message of messages) {\n                        const nextTimestamp = receiveTimestamp(deps)(clockTimestamp, message.timestamp);\n                        if (!nextTimestamp.ok)\n                            return nextTimestamp;\n                        clockTimestamp = nextTimestamp.value;\n                    }\n                    if (isNonEmptyReadonlyArray(messages)) {\n                        const result = applyMessages({ ...deps, storage })(owner.id, messages);\n                        if (!result.ok)\n                            return result;\n                    }\n                    return deps.clock.save(clockTimestamp);\n                });\n                if (!transaction.ok)\n                    return transaction;\n                return ok(true);\n            })();\n            if (!result.ok) {\n                if (result.error.type !== \"AbortError\") {\n                    config.onError(result.error);\n                }\n                return err({ type: \"StorageWriteError\", ownerId });\n            }\n            config.onReceive();\n            return ok();\n        },\n        readDbChange: (ownerId, timestamp) => {\n            const owner = deps.getSyncOwner(ownerIdBytesToOwnerId(ownerId));\n            // Owner can be removed to stop syncing.\n            if (!owner)\n                return null;\n            const result = deps.sqlite.exec(sql `\n          select \"table\", \"id\", \"column\", \"value\"\n          from evolu_history\n          where \"ownerId\" = ${ownerId} and \"timestamp\" = ${timestamp}\n          union all\n          select \"table\", \"id\", \"column\", \"value\"\n          from evolu_message_quarantine\n          where \"ownerId\" = ${ownerId} and \"timestamp\" = ${timestamp};\n        `);\n            if (!result.ok) {\n                config.onError(result.error);\n                return null;\n            }\n            const { rows } = result.value;\n            assertNonEmptyReadonlyArray(rows, \"Every timestamp must have rows\");\n            const firstRow = firstInArray(rows);\n            const values = createRecord();\n            let isInsert = false;\n            let isDelete = null;\n            for (const r of rows) {\n                switch (r.column) {\n                    case \"createdAt\":\n                        isInsert = true;\n                        break;\n                    case \"updatedAt\":\n                        isInsert = false;\n                        break;\n                    case \"isDeleted\":\n                        if (SqliteBoolean.is(r.value)) {\n                            isDelete = sqliteBooleanToBoolean(r.value);\n                        }\n                        break;\n                    default:\n                        values[r.column] = r.value;\n                }\n            }\n            const message = {\n                timestamp: timestampBytesToTimestamp(timestamp),\n                change: DbChange.orThrow({\n                    table: firstRow.table,\n                    id: idBytesToId(firstRow.id),\n                    values,\n                    isInsert,\n                    isDelete,\n                }),\n            };\n            return encodeAndEncryptDbChange(deps)(message, owner.encryptionKey);\n        },\n    };\n    return ok(storage);\n};\n/** Creates a unique identifier for a {@link OwnerTransport}. */\nconst createTransportKey = (transport) => {\n    return `${transport.type}:${transport.url}`;\n};\nconst dbChangeToColumns = (change, now) => {\n    let values = objectToEntries(change.values);\n    // SystemColumns are not encoded in change.values.\n    values = appendToArray(values, [\n        change.isInsert ? \"createdAt\" : \"updatedAt\",\n        now,\n    ]);\n    if (change.isDelete != null) {\n        values = appendToArray(values, [\n            \"isDeleted\",\n            booleanToSqliteBoolean(change.isDelete),\n        ]);\n    }\n    return values;\n};\nexport const applyLocalOnlyChange = (deps) => (change) => {\n    if (change.isDelete) {\n        const result = deps.sqlite.exec(sql `\n        delete from ${sql.identifier(change.table)}\n        where id = ${change.id};\n      `);\n        if (!result.ok)\n            return result;\n    }\n    else {\n        const ownerId = deps.appOwner.id;\n        const columns = dbChangeToColumns(change, deps.time.nowIso());\n        for (const [column, value] of columns) {\n            const result = deps.sqlite.exec(sql.prepared `\n          insert into ${sql.identifier(change.table)}\n            (\"ownerId\", \"id\", ${sql.identifier(column)})\n          values (${ownerId}, ${change.id}, ${value})\n          on conflict (\"ownerId\", \"id\") do update\n            set ${sql.identifier(column)} = ${value};\n        `);\n            if (!result.ok)\n                return result;\n        }\n    }\n    return ok();\n};\nconst applyMessages = (deps) => (ownerId, messages) => {\n    const ownerIdBytes = ownerIdToOwnerIdBytes(ownerId);\n    const usage = getOwnerUsage(deps)(ownerIdBytes, timestampToTimestampBytes(firstInArray(messages).timestamp));\n    if (!usage.ok)\n        return usage;\n    let { firstTimestamp, lastTimestamp } = usage.value;\n    for (const { timestamp, change } of messages) {\n        const columns = dbChangeToColumns(change, timestampToDateIso(timestamp));\n        const idBytes = idToIdBytes(change.id);\n        const timestampBytes = timestampToTimestampBytes(timestamp);\n        for (const [column, value] of columns) {\n            if (validateColumnValue(deps)(change.table, column, value)) {\n                const result = applyColumnChange(deps)(ownerIdBytes, ownerId, change.table, idBytes, change.id, column, value, timestampBytes);\n                if (!result.ok)\n                    return result;\n            }\n            else {\n                const result = deps.sqlite.exec(sql.prepared `\n            insert into evolu_message_quarantine\n              (\"ownerId\", \"timestamp\", \"table\", \"id\", \"column\", \"value\")\n            values\n              (\n                ${ownerIdBytes},\n                ${timestampBytes},\n                ${change.table},\n                ${idBytes},\n                ${column},\n                ${value}\n              )\n            on conflict do nothing;\n          `);\n                if (!result.ok)\n                    return result;\n            }\n        }\n        let strategy;\n        [strategy, firstTimestamp, lastTimestamp] = getTimestampInsertStrategy(timestampBytes, firstTimestamp, lastTimestamp);\n        const result = deps.storage.insertTimestamp(ownerIdBytes, timestampBytes, strategy);\n        if (!result.ok)\n            return result;\n    }\n    /**\n     * TODO: Implement proper storedBytes tracking for client using received and\n     * sent encrypted message sizes.\n     */\n    return updateOwnerUsage(deps)(ownerIdBytes, 1, // Placeholder until proper tracking implemented\n    firstTimestamp, lastTimestamp);\n};\n/**\n * System columns that can appear in sync messages. Excludes `ownerId` because\n * it's handled separately (stored per-row, not per-column in messages).\n */\nconst systemColumnsWithoutOwnerId = systemColumns.difference(new Set([\"ownerId\"]));\nconst validateColumnValue = (deps) => (table, column, _value) => {\n    const schemaColumns = getProperty(deps.dbSchema.tables, table);\n    return (schemaColumns != null &&\n        (systemColumnsWithoutOwnerId.has(column) || schemaColumns.has(column)));\n};\nconst applyColumnChange = (deps) => (ownerIdBytes, ownerId, table, idBytes, id, column, value, timestampBytes) => {\n    const result = deps.sqlite.exec(sql.prepared `\n      with\n        existingTimestamp as (\n          select 1\n          from evolu_history\n          where\n            \"ownerId\" = ${ownerIdBytes}\n            and \"table\" = ${table}\n            and \"id\" = ${idBytes}\n            and \"column\" = ${column}\n            and \"timestamp\" >= ${timestampBytes}\n          limit 1\n        )\n      insert into ${sql.identifier(table)}\n        (\"ownerId\", \"id\", ${sql.identifier(column)})\n      select ${ownerId}, ${id}, ${value}\n      where not exists (select 1 from existingTimestamp)\n      on conflict (\"ownerId\", \"id\") do update\n        set ${sql.identifier(column)} = ${value}\n        where not exists (select 1 from existingTimestamp);\n    `);\n    if (!result.ok)\n        return result;\n    {\n        const result = deps.sqlite.exec(sql.prepared `\n        insert into evolu_history\n          (\"ownerId\", \"table\", \"id\", \"column\", \"value\", \"timestamp\")\n        values\n          (\n            ${ownerIdBytes},\n            ${table},\n            ${idBytes},\n            ${column},\n            ${value},\n            ${timestampBytes}\n          )\n        on conflict do nothing;\n      `);\n        if (!result.ok)\n            return result;\n    }\n    return ok();\n};\n/**\n * Attempts to apply quarantined messages that may now be valid after a schema\n * update. Messages are quarantined when they reference tables or columns that\n * don't exist in the current schema (e.g., from a newer app version).\n */\nexport const tryApplyQuarantinedMessages = (deps) => () => {\n    const rows = deps.sqlite.exec(sql `\n      select \"ownerId\", \"timestamp\", \"table\", \"id\", \"column\", \"value\"\n      from evolu_message_quarantine;\n    `);\n    if (!rows.ok)\n        return rows;\n    for (const row of rows.value.rows) {\n        if (!validateColumnValue(deps)(row.table, row.column, row.value))\n            continue;\n        const result = applyColumnChange(deps)(row.ownerId, ownerIdBytesToOwnerId(row.ownerId), row.table, row.id, idBytesToId(row.id), row.column, row.value, row.timestamp);\n        if (!result.ok)\n            return result;\n        {\n            const result = deps.sqlite.exec(sql `\n          delete from evolu_message_quarantine\n          where\n            \"ownerId\" = ${row.ownerId}\n            and \"timestamp\" = ${row.timestamp}\n            and \"table\" = ${row.table}\n            and \"id\" = ${row.id}\n            and \"column\" = ${row.column};\n        `);\n            if (!result.ok)\n                return result;\n        }\n    }\n    return ok();\n};\nexport const initialSyncState = { type: \"SyncStateInitial\" };\n", "import { firstInArray, isNonEmptyArray, } from \"../Array.js\";\nimport { assertNonEmptyReadonlyArray } from \"../Assert.js\";\nimport { createSymmetricCrypto, } from \"../Crypto.js\";\nimport { ok } from \"../Result.js\";\nimport { createSqlite, sql, } from \"../Sqlite.js\";\nimport { SimpleName } from \"../Type.js\";\nimport { createInitializedWorkerWithHandlers, } from \"../Worker.js\";\nimport { createAppOwner, createOwnerSecret, mnemonicToOwnerSecret, } from \"./Owner.js\";\nimport { protocolVersion } from \"./Protocol.js\";\nimport { createGetQueryRowsCache, loadQueries, } from \"./Query.js\";\nimport { ensureDbSchema, getDbSchema, } from \"./Schema.js\";\nimport { createBaseSqliteStorageTables } from \"./Storage.js\";\nimport { applyLocalOnlyChange, createClock, createSync, tryApplyQuarantinedMessages, } from \"./Sync.js\";\nimport { timestampBytesToTimestamp, timestampToTimestampBytes, } from \"./Timestamp.js\";\nexport const defaultDbConfig = {\n    name: SimpleName.orThrow(\"Evolu\"),\n    transports: [{ type: \"WebSocket\", url: \"wss://free.evoluhq.com\" }],\n    maxDrift: 5 * 60 * 1000,\n    enableLogging: false,\n};\nexport const createDbWorkerForPlatform = (platformDeps) => createInitializedWorkerWithHandlers({\n    init: async (initMessage, postMessage) => {\n        platformDeps.console.enabled = initMessage.config.enableLogging ?? false;\n        const deps = await createDbWorkerDeps(platformDeps, initMessage, postMessage);\n        if (!deps.ok) {\n            postMessage({ type: \"onError\", error: deps.error });\n            return null;\n        }\n        return deps.value;\n    },\n    handlers,\n});\nconst createDbWorkerDeps = async (platformDeps, initMessage, postMessage) => {\n    const sqlite = await createSqlite(platformDeps)(initMessage.config.name, {\n        memory: initMessage.config.inMemory ?? false,\n        encryptionKey: initMessage.config.encryptionKey ?? undefined,\n    });\n    if (!sqlite.ok)\n        return sqlite;\n    const deps = { ...platformDeps, sqlite: sqlite.value };\n    return deps.sqlite.transaction(() => {\n        const dbSchema = getDbSchema(deps)();\n        if (!dbSchema.ok)\n            return dbSchema;\n        const dbIsInitialized = \"evolu_version\" in dbSchema.value.tables;\n        let appOwner;\n        let clock;\n        if (dbIsInitialized) {\n            const currentVersion = deps.sqlite.exec(sql `select protocolVersion from evolu_version limit 1;`);\n            if (!currentVersion.ok)\n                return currentVersion;\n            const configResult = deps.sqlite.exec(sql `\n        select\n          clock,\n          appOwnerId,\n          appOwnerEncryptionKey,\n          appOwnerWriteKey,\n          appOwnerMnemonic\n        from evolu_config\n        limit 1;\n      `);\n            if (!configResult.ok)\n                return configResult;\n            assertNonEmptyReadonlyArray(configResult.value.rows);\n            const config = firstInArray(configResult.value.rows);\n            appOwner = {\n                type: \"AppOwner\",\n                id: config.appOwnerId,\n                encryptionKey: config.appOwnerEncryptionKey,\n                writeKey: config.appOwnerWriteKey,\n                mnemonic: config.appOwnerMnemonic,\n            };\n            clock = createClock(deps)(timestampBytesToTimestamp(config.clock));\n        }\n        else {\n            appOwner =\n                initMessage.config.externalAppOwner ??\n                    createAppOwner(createOwnerSecret(platformDeps));\n            clock = createClock(deps)();\n            const result = initializeDb(deps)(appOwner, clock.get());\n            if (!result.ok)\n                return result;\n        }\n        {\n            const result = ensureDbSchema(deps)(initMessage.dbSchema, dbSchema.value);\n            if (!result.ok)\n                return result;\n        }\n        {\n            const result = ensureMessageQuarantineTable(deps);\n            if (!result.ok)\n                return result;\n        }\n        const sync = createSync({\n            ...deps,\n            clock,\n            symmetricCrypto: createSymmetricCrypto(platformDeps),\n            timestampConfig: initMessage.config,\n            dbSchema: initMessage.dbSchema,\n        })({\n            appOwner,\n            transports: initMessage.config.transports,\n            onError: (error) => {\n                postMessage({ type: \"onError\", error });\n            },\n            onReceive: () => {\n                postMessage({ type: \"refreshQueries\" });\n            },\n        });\n        if (!sync.ok)\n            return sync;\n        {\n            const result = tryApplyQuarantinedMessages({\n                ...deps,\n                dbSchema: initMessage.dbSchema,\n            })();\n            if (!result.ok)\n                return result;\n        }\n        sync.value.useOwner(true, appOwner);\n        return ok({\n            ...deps,\n            getQueryRowsCache: createGetQueryRowsCache(),\n            postMessage,\n            sync: sync.value,\n            appOwner,\n        });\n    });\n};\nconst initializeDb = (deps) => (initialAppOwner, initialClock) => {\n    for (const query of [\n        // Never change structure to ensure all versions can read it.\n        sql `\n        create table evolu_version (\n          \"protocolVersion\" integer not null\n        )\n        strict;\n      `,\n        sql `\n        insert into evolu_version (\"protocolVersion\")\n        values (${protocolVersion});\n      `,\n        sql `\n        create table evolu_config (\n          \"clock\" blob not null,\n          \"appOwnerId\" text not null,\n          \"appOwnerEncryptionKey\" blob not null,\n          \"appOwnerWriteKey\" blob not null,\n          \"appOwnerMnemonic\" text\n        )\n        strict;\n      `,\n        sql `\n        insert into evolu_config\n          (\n            \"clock\",\n            \"appOwnerId\",\n            \"appOwnerEncryptionKey\",\n            \"appOwnerWriteKey\",\n            \"appOwnerMnemonic\"\n          )\n        values\n          (\n            ${timestampToTimestampBytes(initialClock)},\n            ${initialAppOwner.id},\n            ${initialAppOwner.encryptionKey},\n            ${initialAppOwner.writeKey},\n            ${initialAppOwner.mnemonic ?? null}\n          );\n      `,\n        /**\n         * The History table stores all values per ownerId, timestamp, table, id,\n         * and column for conflict-free merging using last-write-win CRDT.\n         * Denormalizes Timestamp and DbChange for covering index performance.\n         * Time travel is available when last-write-win isn't desired. Future\n         * optimization will store history more efficiently.\n         */\n        sql `\n        create table evolu_history (\n          \"ownerId\" blob not null,\n          \"table\" text not null,\n          \"id\" blob not null,\n          \"column\" text not null,\n          \"timestamp\" blob not null,\n          \"value\" any\n        )\n        strict;\n      `,\n        // Index for reading database changes by owner and timestamp.\n        sql `\n        create index evolu_history_ownerId_timestamp on evolu_history (\n          \"ownerId\",\n          \"timestamp\"\n        );\n      `,\n        sql `\n        create unique index evolu_history_ownerId_table_id_column_timestampDesc on evolu_history (\n          \"ownerId\",\n          \"table\",\n          \"id\",\n          \"column\",\n          \"timestamp\" desc\n        );\n      `,\n    ]) {\n        const result = deps.sqlite.exec(query);\n        if (!result.ok)\n            return result;\n    }\n    const result = createBaseSqliteStorageTables(deps);\n    if (!result.ok)\n        return result;\n    return ok();\n};\n/**\n * Ensures the quarantine table exists for storing messages with unknown schema.\n *\n * When a device receives sync messages containing tables or columns that don't\n * exist in its current schema (e.g., from a newer app version), those messages\n * are stored here instead of being discarded. This enables forward\n * compatibility:\n *\n * 1. Unknown data is preserved and can be applied when the app is updated\n * 2. Messages are still propagated to other devices that may understand them\n * 3. Partial messages work - known columns go to app tables, unknown to quarantine\n *\n * The `union all` query in `readDbChange` combines `evolu_history` and this\n * table, ensuring all data (known and unknown) is included when syncing to\n * other devices.\n */\nconst ensureMessageQuarantineTable = (deps) => {\n    const result = deps.sqlite.exec(sql `\n    create table if not exists evolu_message_quarantine (\n      \"ownerId\" blob not null,\n      \"timestamp\" blob not null,\n      \"table\" text not null,\n      \"id\" blob not null,\n      \"column\" text not null,\n      \"value\" any,\n      primary key (\"ownerId\", \"timestamp\", \"table\", \"id\", \"column\")\n    )\n    strict;\n  `);\n    if (!result.ok)\n        return result;\n    return ok();\n};\nconst handlers = {\n    getAppOwner: (deps) => () => {\n        deps.postMessage({\n            type: \"onGetAppOwner\",\n            appOwner: deps.appOwner,\n        });\n    },\n    mutate: (deps) => (message) => {\n        const mutate = deps.sqlite.transaction(() => {\n            const syncChanges = [];\n            for (const change of message.changes) {\n                const isLocalOnlyChange = change.table.startsWith(\"_\");\n                if (isLocalOnlyChange) {\n                    const result = applyLocalOnlyChange(deps)(change);\n                    if (!result.ok)\n                        return result;\n                }\n                else {\n                    syncChanges.push(change);\n                }\n            }\n            if (isNonEmptyArray(syncChanges)) {\n                const result = deps.sync.applyChanges(syncChanges);\n                if (!result.ok)\n                    return result;\n            }\n            // Read writes before commit to update UI ASAP\n            const queryPatches = loadQueries(deps)(message.tabId, message.subscribedQueries);\n            if (!queryPatches.ok)\n                return queryPatches;\n            // Update the tab that performed the mutation.\n            deps.postMessage({\n                type: \"onQueryPatches\",\n                tabId: message.tabId,\n                queryPatches: queryPatches.value,\n                onCompleteIds: message.onCompleteIds,\n            });\n            // Notify other tabs to refresh their queries.\n            deps.postMessage({ type: \"refreshQueries\", tabId: message.tabId });\n            return ok();\n        });\n        if (!mutate.ok) {\n            deps.postMessage({ type: \"onError\", error: mutate.error });\n            return;\n        }\n    },\n    query: (deps) => (message) => {\n        const queryPatches = loadQueries(deps)(message.tabId, message.queries);\n        if (!queryPatches.ok) {\n            deps.postMessage({ type: \"onError\", error: queryPatches.error });\n            return;\n        }\n        deps.postMessage({\n            type: \"onQueryPatches\",\n            tabId: message.tabId,\n            queryPatches: queryPatches.value,\n            onCompleteIds: [],\n        });\n    },\n    reset: (deps) => (message) => {\n        const result = deps.sqlite.transaction(() => {\n            const dbSchema = getDbSchema(deps)();\n            if (!dbSchema.ok)\n                return dbSchema;\n            for (const tableName in dbSchema.value.tables) {\n                /**\n                 * The dropped table is completely removed from the database schema and\n                 * the disk file. The table can not be recovered. All indices and\n                 * triggers associated with the table are also deleted.\n                 * https://sqlite.org/lang_droptable.html\n                 */\n                const result = deps.sqlite.exec(sql `\n          drop table ${sql.identifier(tableName)};\n        `);\n                if (!result.ok)\n                    return result;\n            }\n            if (message.restore) {\n                const result = ensureDbSchema(deps)(message.restore.dbSchema);\n                if (!result.ok)\n                    return result;\n                const secret = mnemonicToOwnerSecret(message.restore.mnemonic);\n                const appOwner = createAppOwner(secret);\n                const clock = createClock(deps)();\n                return initializeDb(deps)(appOwner, clock.get());\n            }\n            return ok();\n        });\n        if (!result.ok) {\n            deps.postMessage({ type: \"onError\", error: result.error });\n            return;\n        }\n        deps.postMessage({\n            type: \"onReset\",\n            onCompleteId: message.onCompleteId,\n            reload: message.reload,\n        });\n    },\n    ensureDbSchema: (deps) => (message) => {\n        const result = deps.sqlite.transaction(() => ensureDbSchema(deps)(message.dbSchema));\n        if (!result.ok) {\n            deps.postMessage({ type: \"onError\", error: result.error });\n            return;\n        }\n    },\n    export: (deps) => (message) => {\n        const file = deps.sqlite.export();\n        if (!file.ok) {\n            deps.postMessage({ type: \"onError\", error: file.error });\n            return;\n        }\n        deps.postMessage({\n            type: \"onExport\",\n            onCompleteId: message.onCompleteId,\n            file: file.value,\n        });\n    },\n    useOwner: (deps) => (message) => {\n        deps.sync.useOwner(message.use, message.owner);\n    },\n};\n", "import { pack } from \"msgpackr\";\nimport { dedupeArray, isNonEmptyArray, isNonEmptyReadonlyArray, } from \"../Array.js\";\nimport { assert, assertNonEmptyReadonlyArray } from \"../Assert.js\";\nimport { createCallbacks } from \"../Callbacks.js\";\nimport { eqArrayNumber } from \"../Eq.js\";\nimport { exhaustiveCheck } from \"../Function.js\";\nimport { createInstances } from \"../Instances.js\";\nimport { err, ok } from \"../Result.js\";\nimport { isSqlMutation, SqliteBoolean, sqliteBooleanToBoolean, } from \"../Sqlite.js\";\nimport { createStore } from \"../Store.js\";\nimport { createId, } from \"../Type.js\";\nimport { defaultDbConfig } from \"./Db.js\";\nimport { applyPatches, createSubscribedQueries, emptyRows, serializeQuery, } from \"./Query.js\";\nimport { evoluSchemaToDbSchema, insertable, kysely, updateable, upsertable, } from \"./Schema.js\";\nimport { DbChange } from \"./Storage.js\";\nimport { initialSyncState } from \"./Sync.js\";\nconst evoluInstances = createInstances();\n/**\n * Unique identifier for the current browser tab or app instance, lazily\n * initialized on first use to distinguish between multiple tabs.\n */\nlet tabId = null;\n/**\n * Creates an {@link Evolu} instance for a platform configured with the specified\n * {@link EvoluSchema} and optional {@link EvoluConfig} providing a typed\n * interface for querying, mutating, and syncing your application's data.\n *\n * ### Example\n *\n * ```ts\n * const TodoId = id(\"Todo\");\n * type TodoId = InferType<typeof TodoId>;\n *\n * const TodoCategoryId = id(\"TodoCategory\");\n * type TodoCategoryId = InferType<typeof TodoCategoryId>;\n *\n * const NonEmptyString50 = maxLength(50, NonEmptyString);\n * type NonEmptyString50 = InferType<typeof NonEmptyString50>;\n *\n * const Schema = {\n *   todo: {\n *     id: TodoId,\n *     title: NonEmptyString1000,\n *     isCompleted: nullOr(SqliteBoolean),\n *     categoryId: nullOr(TodoCategoryId),\n *   },\n *   todoCategory: {\n *     id: TodoCategoryId,\n *     name: NonEmptyString50,\n *   },\n * };\n *\n * const evolu = createEvolu(evoluReactDeps)(Schema);\n * ```\n *\n * ### Instance Caching\n *\n * `createEvolu` caches instances using {@link Instances} by {@link EvoluConfig}\n * name to enable hot reloading and prevent database corruption from multiple\n * connections. For testing, use unique instance names to ensure proper\n * isolation.\n */\nexport const createEvolu = (deps) => (schema, config) => evoluInstances.ensure(config?.name ?? defaultDbConfig.name, () => createEvoluInstance(deps)(schema, config), (evolu) => {\n    // Hot reloading. Note that indexes are intentionally omitted.\n    evolu.ensureSchema(schema);\n});\nconst createEvoluInstance = (deps) => (schema, config) => {\n    deps.console.enabled = config?.enableLogging ?? false;\n    const { indexes, reloadUrl = \"/\", ...partialDbConfig } = config ?? {};\n    const dbConfig = { ...defaultDbConfig, ...partialDbConfig };\n    deps.console.log(\"[evolu]\", \"createEvoluInstance\", {\n        name: dbConfig.name,\n    });\n    const errorStore = createStore(null);\n    const rowsStore = createStore(new Map());\n    const { promise: appOwner, resolve: resolveAppOwner } = Promise.withResolvers();\n    if (config?.externalAppOwner) {\n        resolveAppOwner(config.externalAppOwner);\n    }\n    // TODO: Update it for the owner-api\n    const _syncStore = createStore(initialSyncState);\n    const subscribedQueries = createSubscribedQueries(rowsStore);\n    const loadingPromises = createLoadingPromises(subscribedQueries);\n    const onCompleteCallbacks = createCallbacks(deps);\n    const exportCallbacks = createCallbacks(deps);\n    const dbWorker = deps.createDbWorker(dbConfig.name);\n    const getTabId = () => {\n        tabId ??= createId(deps);\n        return tabId;\n    };\n    // Worker responses are delivered to all tabs. Each case must handle this\n    // properly (e.g., AppOwner promise resolves only once, tabId filtering).\n    dbWorker.onMessage((message) => {\n        switch (message.type) {\n            case \"onError\": {\n                errorStore.set(message.error);\n                break;\n            }\n            case \"onGetAppOwner\": {\n                resolveAppOwner(message.appOwner);\n                break;\n            }\n            case \"onQueryPatches\": {\n                if (message.tabId !== getTabId())\n                    return;\n                const state = rowsStore.get();\n                const nextState = new Map([\n                    ...state,\n                    ...message.queryPatches.map(({ query, patches }) => [\n                        query,\n                        applyPatches(patches, state.get(query) ?? emptyRows),\n                    ]),\n                ]);\n                for (const { query } of message.queryPatches) {\n                    loadingPromises.resolve(query, nextState.get(query) ?? emptyRows);\n                }\n                if (deps.flushSync && message.onCompleteIds.length > 0) {\n                    deps.flushSync(() => {\n                        rowsStore.set(nextState);\n                    });\n                }\n                else {\n                    rowsStore.set(nextState);\n                }\n                for (const id of message.onCompleteIds) {\n                    onCompleteCallbacks.execute(id);\n                }\n                break;\n            }\n            case \"refreshQueries\": {\n                if (message.tabId && message.tabId === getTabId())\n                    return;\n                const loadingPromisesQueries = loadingPromises.getQueries();\n                loadingPromises.releaseUnsubscribedOnMutation();\n                const queries = dedupeArray([\n                    ...loadingPromisesQueries,\n                    ...subscribedQueries.get(),\n                ]);\n                if (isNonEmptyReadonlyArray(queries)) {\n                    dbWorker.postMessage({ type: \"query\", tabId: getTabId(), queries });\n                }\n                break;\n            }\n            case \"onReset\": {\n                if (message.reload) {\n                    deps.reloadApp(reloadUrl);\n                }\n                else {\n                    onCompleteCallbacks.execute(message.onCompleteId);\n                }\n                break;\n            }\n            case \"onExport\": {\n                exportCallbacks.execute(message.onCompleteId, message.file);\n                break;\n            }\n            default:\n                exhaustiveCheck(message);\n        }\n    });\n    const dbSchema = evoluSchemaToDbSchema(schema, indexes);\n    const mutationTypesCache = new Map();\n    // Lazy create mutation Types like this: `insertable(Schema.todo)`\n    const getMutationType = (table, kind) => {\n        let types = mutationTypesCache.get(kind);\n        if (!types) {\n            types = new Map();\n            mutationTypesCache.set(kind, types);\n        }\n        let type = types.get(table);\n        if (!type) {\n            type = { insert: insertable, update: updateable, upsert: upsertable }[kind](schema[table]);\n            types.set(table, type);\n        }\n        return type;\n    };\n    dbWorker.postMessage({ type: \"init\", config: dbConfig, dbSchema });\n    // We can't use `init` to get AppOwner because `init` runs only once per n tabs.\n    dbWorker.postMessage({ type: \"getAppOwner\" });\n    const loadQueryMicrotaskQueue = [];\n    const mutateMicrotaskQueue = [];\n    const useOwnerMicrotaskQueue = [];\n    const createMutation = (kind) => (table, props, options) => {\n        const result = getMutationType(table, kind).fromUnknown(props);\n        const id = kind === \"insert\"\n            ? createId(deps)\n            : props.id;\n        if (options?.onlyValidate !== true) {\n            if (!result.ok) {\n                // Mark the transaction as invalid by pushing null\n                mutateMicrotaskQueue.push([null, undefined]);\n            }\n            else {\n                const { id: _, isDeleted, ...values } = result.value;\n                const dbChange = {\n                    table,\n                    id,\n                    values,\n                    isInsert: kind === \"insert\" || kind === \"upsert\",\n                    isDelete: SqliteBoolean.is(isDeleted)\n                        ? sqliteBooleanToBoolean(isDeleted)\n                        : null,\n                };\n                assert(DbChange.is(dbChange), `Invalid DbChange for table '${table}': Please check schema type errors.`);\n                mutateMicrotaskQueue.push([\n                    { ...dbChange, ownerId: options?.ownerId },\n                    options?.onComplete,\n                ]);\n            }\n            if (mutateMicrotaskQueue.length === 1) {\n                queueMicrotask(processMutationQueue);\n            }\n        }\n        if (result.ok)\n            return ok({ id });\n        return err(result.error);\n    };\n    const processMutationQueue = () => {\n        const changes = [];\n        const onCompletes = [];\n        for (const [change, onComplete] of mutateMicrotaskQueue) {\n            if (change !== null)\n                changes.push(change);\n            if (onComplete)\n                onCompletes.push(onComplete);\n        }\n        const queueLength = mutateMicrotaskQueue.length;\n        mutateMicrotaskQueue.length = 0;\n        // Don't process any mutations if there was a validation error.\n        // All mutations within a queue run as a single transaction.\n        if (changes.length !== queueLength) {\n            return;\n        }\n        const onCompleteIds = onCompletes.map(onCompleteCallbacks.register);\n        loadingPromises.releaseUnsubscribedOnMutation();\n        if (!isNonEmptyArray(changes))\n            return;\n        dbWorker.postMessage({\n            type: \"mutate\",\n            tabId: getTabId(),\n            changes,\n            onCompleteIds,\n            subscribedQueries: subscribedQueries.get(),\n        });\n    };\n    const evolu = {\n        subscribeError: errorStore.subscribe,\n        getError: errorStore.get,\n        createQuery,\n        loadQuery: (query) => {\n            const { promise, isNew } = loadingPromises.get(query);\n            if (isNew) {\n                loadQueryMicrotaskQueue.push(query);\n                if (loadQueryMicrotaskQueue.length === 1) {\n                    queueMicrotask(() => {\n                        const queries = dedupeArray(loadQueryMicrotaskQueue);\n                        loadQueryMicrotaskQueue.length = 0;\n                        assertNonEmptyReadonlyArray(queries);\n                        deps.console.log(\"[evolu]\", \"loadQuery\", { queries });\n                        dbWorker.postMessage({\n                            type: \"query\",\n                            tabId: getTabId(),\n                            queries,\n                        });\n                    });\n                }\n            }\n            return promise;\n        },\n        loadQueries: (queries) => queries.map(evolu.loadQuery),\n        subscribeQuery: (query) => (listener) => {\n            // Call the listener only if the result has been changed.\n            let previousRows = null;\n            const unsubscribe = subscribedQueries.subscribe(query)(() => {\n                const rows = evolu.getQueryRows(query);\n                if (previousRows === rows)\n                    return;\n                previousRows = rows;\n                listener();\n            });\n            return () => {\n                previousRows = null;\n                unsubscribe();\n            };\n        },\n        getQueryRows: (query) => (rowsStore.get().get(query) ?? emptyRows),\n        appOwner,\n        // TODO: Update it for the owner-api\n        // subscribeSyncState: syncStore.subscribe,\n        // getSyncState: syncStore.get,\n        insert: createMutation(\"insert\"),\n        update: createMutation(\"update\"),\n        upsert: createMutation(\"upsert\"),\n        resetAppOwner: (options) => {\n            const { promise, resolve } = Promise.withResolvers();\n            const onCompleteId = onCompleteCallbacks.register(resolve);\n            dbWorker.postMessage({\n                type: \"reset\",\n                onCompleteId,\n                reload: options?.reload ?? true,\n            });\n            return promise;\n        },\n        restoreAppOwner: (mnemonic, options) => {\n            const { promise, resolve } = Promise.withResolvers();\n            const onCompleteId = onCompleteCallbacks.register(resolve);\n            dbWorker.postMessage({\n                type: \"reset\",\n                onCompleteId,\n                reload: options?.reload ?? true,\n                restore: { mnemonic, dbSchema },\n            });\n            return promise;\n        },\n        reloadApp: () => {\n            deps.reloadApp(reloadUrl);\n        },\n        ensureSchema: (schema) => {\n            mutationTypesCache.clear();\n            const dbSchema = evoluSchemaToDbSchema(schema);\n            dbWorker.postMessage({ type: \"ensureDbSchema\", dbSchema });\n        },\n        exportDatabase: () => {\n            const { promise, resolve } = Promise.withResolvers();\n            const onCompleteId = exportCallbacks.register(resolve);\n            dbWorker.postMessage({ type: \"export\", onCompleteId });\n            return promise;\n        },\n        useOwner: (owner) => {\n            const scheduleOwnerQueueProcessing = () => {\n                if (useOwnerMicrotaskQueue.length !== 1)\n                    return;\n                queueMicrotask(() => {\n                    const queue = [...useOwnerMicrotaskQueue];\n                    useOwnerMicrotaskQueue.length = 0;\n                    const result = [];\n                    const skipIndices = new Set();\n                    for (let i = 0; i < queue.length; i++) {\n                        if (skipIndices.has(i))\n                            continue;\n                        const [currentOwner, currentUse, currentOwnerSerialized] = queue[i];\n                        // Look for opposite action with same owner\n                        for (let j = i + 1; j < queue.length; j++) {\n                            if (skipIndices.has(j))\n                                continue;\n                            const [, otherUse, otherOwnerSerialized] = queue[j];\n                            if (currentUse !== otherUse &&\n                                eqArrayNumber(currentOwnerSerialized, otherOwnerSerialized)) {\n                                // Found cancel-out pair, skip both\n                                skipIndices.add(i).add(j);\n                                break;\n                            }\n                        }\n                        if (!skipIndices.has(i)) {\n                            result.push([currentOwner, currentUse, currentOwnerSerialized]);\n                        }\n                    }\n                    for (const [owner, use] of result) {\n                        dbWorker.postMessage({ type: \"useOwner\", owner, use });\n                    }\n                });\n            };\n            useOwnerMicrotaskQueue.push([owner, true, pack(owner)]);\n            scheduleOwnerQueueProcessing();\n            const unuse = () => {\n                useOwnerMicrotaskQueue.push([owner, false, pack(owner)]);\n                scheduleOwnerQueueProcessing();\n            };\n            return unuse;\n        },\n        /** Disposal is not implemented yet. */\n        [Symbol.dispose]: () => {\n            throw new Error(\"Evolu instance disposal is not yet implemented\");\n        },\n    };\n    return evolu;\n};\nexport const createQuery = (queryCallback, options) => {\n    const compiledQuery = queryCallback(kysely).compile();\n    if (isSqlMutation(compiledQuery.sql))\n        throw new Error(\"SQL mutation (INSERT, UPDATE, DELETE, etc.) isn't allowed in the Evolu `createQuery` function. Kysely suggests it because there is no read-only Kysely yet, and removing such an API is not possible. For mutations, use Evolu Mutation API.\");\n    return serializeQuery({\n        sql: compiledQuery.sql,\n        parameters: compiledQuery.parameters,\n        ...(options && { options }),\n    });\n};\nconst createLoadingPromises = (subscribedQueries) => {\n    const loadingPromiseMap = new Map();\n    return {\n        get: (query) => {\n            let loadingPromise = loadingPromiseMap.get(query);\n            const isNew = !loadingPromise;\n            if (!loadingPromise) {\n                const { promise, resolve } = Promise.withResolvers();\n                loadingPromise = { resolve, promise, releaseOnResolve: false };\n                loadingPromiseMap.set(query, loadingPromise);\n            }\n            return {\n                promise: loadingPromise.promise,\n                isNew,\n            };\n        },\n        resolve: (query, rows) => {\n            const loadingPromise = loadingPromiseMap.get(query);\n            if (!loadingPromise)\n                return;\n            if (loadingPromise.promise.status !== \"fulfilled\") {\n                loadingPromise.resolve(rows);\n            }\n            else {\n                loadingPromise.promise = Promise.resolve(rows);\n            }\n            // Set status and value fields for React's `use` Hook to unwrap synchronously.\n            // While undocumented in React docs, React still uses these properties internally,\n            // and Evolu's own promise caching logic depends on checking `promise.status`.\n            // https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md\n            void Object.assign(loadingPromise.promise, {\n                status: \"fulfilled\",\n                value: rows,\n            });\n            if (loadingPromise.releaseOnResolve) {\n                loadingPromiseMap.delete(query);\n            }\n        },\n        releaseUnsubscribedOnMutation: () => {\n            [...loadingPromiseMap.entries()]\n                .filter(([query]) => !subscribedQueries.has(query))\n                .forEach(([query, loadingPromise]) => {\n                if (loadingPromise.promise.status === \"fulfilled\") {\n                    loadingPromiseMap.delete(query);\n                }\n                else {\n                    loadingPromise.releaseOnResolve = true;\n                }\n            });\n        },\n        getQueries: () => Array.from(loadingPromiseMap.keys()),\n    };\n};\n", "import { createAppOwner, createOwnerSecret, mnemonicToOwnerSecret, OwnerEncryptionKey, OwnerWriteKey, } from \"./Owner.js\";\n/**\n * Creates a local auth using the given secure storage implementation. This\n * factory function allows each platform to provide its own storage layer while\n * sharing the common auth logic.\n */\nexport const createLocalAuth = (deps) => {\n    const setLastOwnerId = async (id, options) => {\n        await deps.secureStorage.setItem(localAuthMetakeyLastOwner, id, {\n            ...buildAuthOptions(options),\n            accessControl: \"none\",\n        });\n    };\n    const getLastOwnerId = async (options) => {\n        const item = await deps.secureStorage.getItem(localAuthMetakeyLastOwner, {\n            ...buildAuthOptions(options),\n            accessControl: \"none\",\n        });\n        return item?.value;\n    };\n    const getOwnerNames = async (options) => {\n        const item = await deps.secureStorage.getItem(localAuthMetakeyOwnerNames, {\n            ...buildAuthOptions(options),\n            accessControl: \"none\",\n        });\n        let names = {};\n        if (item?.value) {\n            names = JSON.parse(item.value);\n        }\n        return names;\n    };\n    const setOwnerName = async (id, username, options) => {\n        const names = await getOwnerNames(options);\n        names[id] = username;\n        await deps.secureStorage.setItem(localAuthMetakeyOwnerNames, JSON.stringify(names), {\n            ...buildAuthOptions(options),\n            accessControl: \"none\",\n        });\n    };\n    const deleteOwnerName = async (id, options) => {\n        const { [id]: _, ...names } = await getOwnerNames(options);\n        await deps.secureStorage.setItem(localAuthMetakeyOwnerNames, JSON.stringify(names), {\n            ...buildAuthOptions(options),\n            accessControl: \"none\",\n        });\n    };\n    const getOwnerIds = async (options) => {\n        const items = await deps.secureStorage.getAllItems({\n            ...buildAuthOptions(options),\n            includeValues: false,\n        });\n        return items\n            .filter(Boolean)\n            .filter((i) => i.key !== localAuthMetakeyLastOwner &&\n            i.key !== localAuthMetakeyOwnerNames)\n            .map((i) => i.key);\n    };\n    const clearAuthStore = (options) => deps.secureStorage.clearService(buildAuthOptions(options));\n    const buildAuthOptions = (options, username) => {\n        const newOptions = {\n            ...localAuthDefaultOptions,\n            ...(username && { webAuthnUsername: username }),\n            ...options,\n        };\n        return {\n            ...newOptions,\n            authenticationPrompt: {\n                title: replaceMessageTokens(newOptions.authenticationPrompt?.title ?? \"\", username),\n                cancel: replaceMessageTokens(newOptions.authenticationPrompt?.cancel ?? \"\", username),\n                subtitle: replaceMessageTokens(newOptions.authenticationPrompt?.subtitle ?? \"\", username),\n                description: replaceMessageTokens(newOptions.authenticationPrompt?.description ?? \"\", username),\n            },\n        };\n    };\n    const replaceMessageTokens = (text, username) => {\n        if (!username)\n            return text;\n        return text.replace(\"|USERNAME|\", username);\n    };\n    return {\n        login: async (ownerId, options) => {\n            // Lookup the associated username\n            const names = await getOwnerNames(options);\n            const username = names[ownerId] ?? \"\";\n            // Currently a reload is needed. This avoids authentication\n            // it needs to be handled on next page load.\n            // We set the last owner so we know what the target is.\n            // It is the applications's responsibility to reload and trigger login.\n            await setLastOwnerId(ownerId, options);\n            return { owner: undefined, username };\n        },\n        register: async (username, options) => {\n            // Create an owner with a new secret or use specified mnemonic\n            const owner = createAppOwner(options?.mnemonic\n                ? mnemonicToOwnerSecret(options.mnemonic)\n                : createOwnerSecret(deps));\n            // Store owner, associated username, and update last owner\n            await Promise.all([\n                // setOwnerItem\n                deps.secureStorage.setItem(owner.id, JSON.stringify({ owner }), buildAuthOptions(options, username)),\n                setOwnerName(owner.id, username, options),\n                setLastOwnerId(owner.id, options),\n            ]);\n            // Return the owner and associated username\n            return { owner, username };\n        },\n        unregister: async (ownerId, options) => {\n            // Delete the owner and associated username\n            await Promise.all([\n                // deleteOwnerItem\n                deps.secureStorage.deleteItem(ownerId, buildAuthOptions(options)),\n                deleteOwnerName(ownerId, options),\n            ]);\n            // If the owner was the last owner then set to\n            // the next owner based on metadata timestamp\n            const lastOwnerId = await getLastOwnerId(options);\n            if (lastOwnerId === ownerId) {\n                const ids = await getOwnerIds(options);\n                if (ids.length > 0) {\n                    await setLastOwnerId(ids[0], options);\n                }\n            }\n        },\n        getOwner: async (options) => {\n            const ownerId = await getLastOwnerId(options);\n            if (!ownerId)\n                return null;\n            const names = await getOwnerNames(options);\n            const username = names[ownerId] ?? \"\";\n            // Retrieve and decrypt the owner (this will trigger device authentication)\n            const account = await deps.secureStorage.getItem(ownerId, buildAuthOptions(options, username));\n            if (!account?.value)\n                return null;\n            // Unserialize the values (TODO: save these as base64 instead of json serializing)\n            const result = JSON.parse(account.value);\n            const writeKey = OwnerWriteKey.orThrow(new Uint8Array(Object.values(result.owner.writeKey)));\n            const encryptionKey = OwnerEncryptionKey.orThrow(new Uint8Array(Object.values(result.owner.encryptionKey)));\n            const owner = { ...result.owner, writeKey, encryptionKey };\n            // Update the last owner for future login attempts\n            await setLastOwnerId(ownerId, options);\n            // Return the owner and associated username\n            return { owner, username };\n        },\n        getProfiles: async (options) => {\n            // Get all owner ids and associated usernames\n            const [ids, names] = await Promise.all([\n                getOwnerIds(options),\n                getOwnerNames(options),\n            ]);\n            // Return the list of profiles (usually used for login UX)\n            return ids.map((ownerId) => ({\n                ownerId,\n                username: names[ownerId] ?? \"\",\n            }));\n        },\n        clearAll: async (options) => {\n            // Delete all owners and associated metadata (scoped to the service)\n            await clearAuthStore(options);\n        },\n    };\n};\nexport const localAuth_Namespace = \"evolu\";\nexport const localAuthDefaultOptions = {\n    service: localAuth_Namespace,\n    keychainGroup: localAuth_Namespace,\n    androidBiometricsStrongOnly: true,\n    iosSynchronizable: true,\n    webAuthnUsername: \"Evolu User\",\n    authenticationPrompt: {\n        title: \"Authenticate as |USERNAME|\",\n    },\n};\nconst localAuthMetakeyLastOwner = \"_last_owner\";\nconst localAuthMetakeyOwnerNames = \"_owner_names\";\n", "import { AliasNode, ColumnNode, ExpressionWrapper, IdentifierNode, ReferenceNode, sql, TableNode, ValueNode, } from \"kysely\";\nimport { kyselyJsonIdentifier } from \"./Query.js\";\nexport { sql } from \"kysely\";\n/**\n * A SQLite helper for aggregating a subquery into a JSON array.\n *\n * ### Examples\n *\n * ```ts\n * import { kysely } from \"@evolu/common\";\n *\n * // TODO: Update for Evolu\n * const result = await db\n *   .selectFrom(\"person\")\n *   .select((eb) => [\n *     \"id\",\n *     kysely\n *       .jsonArrayFrom(\n *         eb\n *           .selectFrom(\"pet\")\n *           .select([\"pet.id as pet_id\", \"pet.name\"])\n *           .whereRef(\"pet.owner_id\", \"=\", \"person.id\")\n *           .orderBy(\"pet.name\"),\n *       )\n *       .as(\"pets\"),\n *   ])\n *   .execute();\n *\n * result[0]?.id;\n * result[0]?.pets[0].pet_id;\n * result[0]?.pets[0].name;\n * ```\n *\n * The generated SQL (SQLite):\n *\n * ```sql\n * select \"id\", (\n *   select coalesce(json_group_array(json_object(\n *     'pet_id', \"agg\".\"pet_id\",\n *     'name', \"agg\".\"name\"\n *   )), '[]') from (\n *     select \"pet\".\"id\" as \"pet_id\", \"pet\".\"name\"\n *     from \"pet\"\n *     where \"pet\".\"owner_id\" = \"person\".\"id\"\n *     order by \"pet\".\"name\"\n *   ) as \"agg\"\n * ) as \"pets\"\n * from \"person\"\n * ```\n */\n// Kysely expects strict AST.\n// prettier-ignore\nexport function jsonArrayFrom(expr) {\n    return sql `(select ${sql.lit(kyselyJsonIdentifier)} || coalesce(json_group_array(json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), 'agg'))})), '[]') from ${expr} as agg)`;\n}\n/**\n * A SQLite helper for turning a subquery into a JSON object.\n *\n * The subquery must only return one row.\n *\n * ### Examples\n *\n * ```ts\n * import { kysely } from \"@evolu/common\";\n *\n * // TODO: Update for Evolu\n * const result = await db\n *   .selectFrom(\"person\")\n *   .select((eb) => [\n *     \"id\",\n *     jsonObjectFrom(\n *       eb\n *         .selectFrom(\"pet\")\n *         .select([\"pet.id as pet_id\", \"pet.name\"])\n *         .whereRef(\"pet.owner_id\", \"=\", \"person.id\")\n *         .where(\"pet.is_favorite\", \"=\", true),\n *     ).as(\"favorite_pet\"),\n *   ])\n *   .execute();\n *\n * result[0]?.id;\n * result[0]?.favorite_pet?.pet_id;\n * result[0]?.favorite_pet?.name;\n * ```\n *\n * The generated SQL (SQLite):\n *\n * ```sql\n * select \"id\", (\n *   select json_object(\n *     'pet_id', \"obj\".\"pet_id\",\n *     'name', \"obj\".\"name\"\n *   ) from (\n *     select \"pet\".\"id\" as \"pet_id\", \"pet\".\"name\"\n *     from \"pet\"\n *     where \"pet\".\"owner_id\" = \"person\".\"id\"\n *     and \"pet\".\"is_favorite\" = ?\n *   ) as obj\n * ) as \"favorite_pet\"\n * from \"person\";\n * ```\n */\n// Kysely expects strict AST.\n// prettier-ignore\nexport function jsonObjectFrom(expr) {\n    return sql `(select ${sql.lit(kyselyJsonIdentifier)} || json_object(${sql.join(getSqliteJsonObjectArgs(expr.toOperationNode(), 'obj'))}) from ${expr} as obj)`;\n}\n/**\n * The SQLite `json_object` function.\n *\n * ### Examples\n *\n * ```ts\n * import { kysely } from \"@evolu/common\";\n *\n * // TODO: Update for Evolu\n * const result = await db\n *   .selectFrom(\"person\")\n *   .select((eb) => [\n *     \"id\",\n *     kysely\n *       .jsonBuildObject({\n *         first: eb.ref(\"first_name\"),\n *         last: eb.ref(\"last_name\"),\n *         full: kysely.sql<string>`first_name || ' ' || last_name`,\n *       })\n *       .as(\"name\"),\n *   ])\n *   .execute();\n *\n * result[0]?.id;\n * result[0]?.name.first;\n * result[0]?.name.last;\n * result[0]?.name.full;\n * ```\n *\n * The generated SQL (SQLite):\n *\n * ```sql\n * select \"id\", json_object(\n *   'first', first_name,\n *   'last', last_name,\n *   'full', \"first_name\" || ' ' || \"last_name\"\n * ) as \"name\"\n * from \"person\"\n * ```\n */\n// Kysely expects strict AST.\n// prettier-ignore\nexport function jsonBuildObject(obj) {\n    return sql `${sql.lit(kyselyJsonIdentifier)} || json_object(${sql.join(Object.keys(obj).flatMap((k) => [sql.lit(k), obj[k]]))})`;\n}\nfunction getSqliteJsonObjectArgs(node, table) {\n    try {\n        return getJsonObjectArgs(node, table);\n    }\n    catch {\n        throw new Error(\"SQLite jsonArrayFrom and jsonObjectFrom functions can only handle explicit selections due to limitations of the json_object function. selectAll() is not allowed in the subquery.\");\n    }\n}\nexport function getJsonObjectArgs(node, table) {\n    const args = [];\n    for (const { selection: s } of node.selections ?? []) {\n        if (ReferenceNode.is(s) && ColumnNode.is(s.column)) {\n            args.push(colName(s.column.column.name), colRef(table, s.column.column.name));\n        }\n        else if (ColumnNode.is(s)) {\n            args.push(colName(s.column.name), colRef(table, s.column.name));\n        }\n        else if (AliasNode.is(s) && IdentifierNode.is(s.alias)) {\n            args.push(colName(s.alias.name), colRef(table, s.alias.name));\n        }\n        else {\n            throw new Error(`can't extract column names from the select query node`);\n        }\n    }\n    return args;\n}\nfunction colName(col) {\n    return new ExpressionWrapper(ValueNode.createImmediate(col));\n}\nfunction colRef(table, col) {\n    return new ExpressionWrapper(ReferenceNode.create(ColumnNode.create(col), TableNode.create(table)));\n}\n", "export abstract class RNG {\n  abstract get name(): string\n\n  abstract next(): number\n\n  abstract clone(): RNG\n}\n", "import type { RNGFn } from '../types'\nimport { RNG } from '../rng'\n\nexport class FunctionRNG extends RNG {\n  _name: string\n  _rngFn: RNGFn\n\n  constructor(rngFn: RNGFn) {\n    super()\n\n    this._name = rngFn.name ?? 'function'\n    this._rngFn = rngFn\n  }\n\n  override get name() {\n    return this._name\n  }\n\n  override next() {\n    return this._rngFn()\n  }\n\n  override clone() {\n    return new FunctionRNG(this._rngFn)\n  }\n}\n", "import type { Seed, SeedOrRNG } from './types'\nimport { ARC4RNG } from './generators/arc4'\nimport { FunctionRNG } from './generators/function'\nimport { RNG } from './rng'\n\nexport function createRNG(seedOrRNG?: SeedOrRNG) {\n  switch (typeof seedOrRNG) {\n    case 'object':\n      if (seedOrRNG instanceof RNG) {\n        return seedOrRNG\n      }\n      break\n\n    case 'function':\n      return new FunctionRNG(seedOrRNG)\n\n    default:\n      return new ARC4RNG(seedOrRNG)\n  }\n\n  throw new Error(`invalid RNG seed or instance \"${seedOrRNG}\"`)\n}\n\n/**\n * Mixes a string seed into a key that is an array of integers, and returns a\n * shortened string seed that is equivalent to the result key.\n */\nexport function mixKey(seed: Seed, key: number[]): number[] {\n  const seedStr = `${seed}`\n  let smear = 0\n  let j = 0\n\n  while (j < seedStr.length) {\n    key[0xff & j] =\n      0xff & ((smear ^= (key[0xff & j] ?? 0) * 19) + seedStr.charCodeAt(j++))\n  }\n\n  if (!key.length) {\n    return [0]\n  }\n\n  return key\n}\n\nexport function shuffleInPlace<T>(gen: RNG, array: Array<T>) {\n  for (let i = array.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(gen.next() * (i + 1))\n    const tmp = array[i]\n    array[i] = array[j] as T\n    array[j] = tmp as T\n  }\n}\n\n/**\n * Fisher-Yates sampling without replacement\n * O(k) time and space, by using a hash table instead of a full copy of the array\n * see https://arxiv.org/pdf/2104.05091 Algorithm 2\n */\nexport function sparseFisherYates<T>(\n  gen: RNG,\n  array: Array<T>,\n  k: number\n): T[] {\n  const H = new Map<number, number>() // stores swapped indices\n  const lastIndex = array.length - 1\n  const result: T[] = Array.from({ length: k })\n\n  for (let i = 0; i < k; i++) {\n    const remaining = lastIndex - i + 1\n    const r = Math.floor(gen.next() * remaining)\n    result[i] = array[H.get(r) ?? r]!\n    // move the element at the end of the active range into slot r\n    H.set(r, H.get(lastIndex - i) ?? lastIndex - i)\n  }\n\n  return result\n}\n", "import type { Seed } from '../types'\nimport { RNG } from '../rng'\nimport { mixKey } from '../utils'\n\n//\n// ARC4\n//\n// An ARC4 implementation. The constructor takes a key in the form of an array\n// of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates the\n// next (count) outputs from ARC4. Its return value is a number x that is in\n// the range 0 <= x < (width ^ count).\n\n// The following constants are related to IEEE 754 limits.\n// const width = 256 // each RC4 output is 0 <= x < 256\n// const chunks = 6 // at least six RC4 outputs for each double\nconst _arc4_startdenom = 281_474_976_710_656 // 256 ** 6 == width ** chunks\nconst _arc4_significance = 4_503_599_627_370_496 // 2 ** 52 significant digits in a double\nconst _arc4_overflow = 9_007_199_254_740_992 // 2 ** 53 == significance * 2\n\nexport class ARC4RNG extends RNG {\n  protected readonly _seed: Seed\n\n  i: number\n  j: number\n  S: number[]\n\n  constructor(seed: Seed = crypto.randomUUID()) {\n    super()\n\n    this._seed = seed\n    const key = mixKey(seed, [])\n\n    const S: number[] = []\n    const keylen = key.length\n    this.i = 0\n    this.j = 0\n    this.S = S\n\n    // Set up S using the standard key scheduling algorithm.\n    let i = 0\n    while (i <= 0xff) {\n      S[i] = i++\n    }\n\n    for (let i = 0, j = 0; i <= 0xff; i++) {\n      const t = S[i]!\n      j = 0xff & (j + key[i % keylen]! + t)\n      S[i] = S[j]!\n      S[j] = t\n    }\n\n    // For more robust unpredictability, the function call below discards an\n    // initial batch of values. This is called RC4-drop.\n    this.g(256)\n  }\n\n  override get name() {\n    return 'arc4'\n  }\n\n  override next() {\n    // This function returns a random double in [0, 1) that contains\n    // randomness in every bit of the mantissa of the IEEE 754 value.\n\n    let n = this.g(6) // Start with a numerator n < 2 ^ 48\n    let d = _arc4_startdenom // and denominator d = 2 ^ 48.\n    let x = 0 // and no 'extra last byte'.\n\n    while (n < _arc4_significance) {\n      // Fill up all significant digits (2 ** 52)\n      n = (n + x) * 256 // by shifting numerator and\n      d *= 256 // denominator and generating a\n      x = this.g(1) // new least-significant-byte.\n    }\n\n    while (n >= _arc4_overflow) {\n      // To avoid rounding past overflow, before adding\n      n /= 2 // last byte, shift everything\n      d /= 2 // right using integer math until\n      x >>>= 1 // we have exactly the desired bits.\n    }\n\n    return (n + x) / d // Form the number within [0, 1).\n  }\n\n  g(count: number) {\n    const { S } = this\n    let { i, j } = this\n    let r = 0\n\n    while (count--) {\n      i = 0xff & (i + 1)\n      const t = S[i]!\n      S[j] = t\n      j = 0xff & (j + t)\n      S[i] = S[j]!\n      r = r * 256 + S[0xff & (S[i]! + t)]!\n    }\n\n    this.i = i\n    this.j = j\n\n    return r\n  }\n\n  override clone() {\n    return new ARC4RNG(this._seed)\n  }\n}\n", "import { RNG } from '../rng'\n\nexport class MathRandomRNG extends RNG {\n  override get name() {\n    return 'Math.random'\n  }\n\n  override next() {\n    return Math.random()\n  }\n\n  override clone() {\n    return new MathRandomRNG()\n  }\n}\n", "import type { Seed } from '../types'\nimport { RNG } from '../rng'\n\nexport class XOR128RNG extends RNG {\n  protected readonly _seed: Seed\n\n  x: number\n  y: number\n  z: number\n  w: number\n\n  constructor(seed: Seed = crypto.randomUUID()) {\n    super()\n\n    this._seed = seed\n    this.x = 0\n    this.y = 0\n    this.z = 0\n    this.w = 0\n\n    let strSeed: string = ''\n\n    if (typeof seed === 'number') {\n      this.x = seed\n    } else {\n      strSeed += `${seed}`\n    }\n\n    // Mix in string seed, then discard an initial batch of 64 values.\n    for (let i = 0; i < strSeed.length + 64; ++i) {\n      this.x ^= strSeed.charCodeAt(i) | 0\n      this.next()\n    }\n  }\n\n  override get name() {\n    return 'xor128'\n  }\n\n  override next() {\n    const t = this.x ^ (this.x << 11)\n    this.x = this.y\n    this.y = this.z\n    this.z = this.w\n    this.w = this.w ^ ((this.w >>> 19) ^ t ^ (t >>> 8))\n    return (this.w >>> 0) / 0x1_00_00_00_00\n  }\n\n  override clone() {\n    return new XOR128RNG(this._seed)\n  }\n}\n", "export function numberValidator(num: number) {\n  return new NumberValidator(num)\n}\n\nexport class NumberValidator {\n  private n: number\n  constructor(num: number) {\n    this.n = num\n  }\n\n  public isInt = (): this => {\n    if (Number.isInteger(this.n)) {\n      return this\n    }\n    throw new Error(`Expected number to be an integer, got ${this.n}`)\n  }\n\n  public isPositive = (): this => {\n    if (this.n > 0) {\n      return this\n    }\n    throw new Error(`Expected number to be positive, got ${this.n}`)\n  }\n\n  public lessThan = (v: number): this => {\n    if (this.n < v) {\n      return this\n    }\n    throw new Error(`Expected number to be less than ${v}, got ${this.n}`)\n  }\n\n  public lessThanOrEqual = (v: number): this => {\n    if (this.n <= v) {\n      return this\n    }\n    throw new Error(\n      `Expected number to be less than or equal to ${v}, got ${this.n}`\n    )\n  }\n\n  public greaterThanOrEqual = (v: number): this => {\n    if (this.n >= v) {\n      return this\n    }\n    throw new Error(\n      `Expected number to be greater than or equal to ${v}, got ${this.n}`\n    )\n  }\n\n  public greaterThan = (v: number): this => {\n    if (this.n > v) {\n      return this\n    }\n    throw new Error(`Expected number to be greater than ${v}, got ${this.n}`)\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function bates(random: Random, n = 1) {\n  numberValidator(n).isInt().isPositive()\n  const irwinHall = random.irwinHall(n)\n\n  return () => {\n    return irwinHall() / n\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function bernoulli(random: Random, p = 0.5) {\n  numberValidator(p).greaterThanOrEqual(0).lessThanOrEqual(1)\n\n  return () => {\n    return Math.min(1, Math.floor(random.next() + p))\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function binomial(random: Random, n = 1, p = 0.5) {\n  numberValidator(n).isInt().isPositive()\n  numberValidator(p).greaterThanOrEqual(0).lessThan(1)\n\n  return () => {\n    let i = 0\n    let x = 0\n\n    while (i++ < n) {\n      if (random.next() < p) {\n        x++\n      }\n    }\n    return x\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function exponential(random: Random, lambda = 1) {\n  numberValidator(lambda).isPositive()\n\n  return () => {\n    return -Math.log(1 - random.next()) / lambda\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function geometric(random: Random, p = 0.5) {\n  numberValidator(p).greaterThan(0).lessThan(1)\n  const invLogP = 1.0 / Math.log(1.0 - p)\n\n  return () => {\n    return Math.floor(1 + Math.log(random.next()) * invLogP)\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function irwinHall(random: Random, n = 1) {\n  numberValidator(n).isInt().greaterThanOrEqual(0)\n\n  return () => {\n    let sum = 0\n    for (let i = 0; i < n; ++i) {\n      sum += random.next()\n    }\n\n    return sum\n  }\n}\n", "import type { Random } from '../random'\n\nexport function logNormal(random: Random, mu = 0, sigma = 1) {\n  const normal = random.normal(mu, sigma)\n  return () => {\n    return Math.exp(normal())\n  }\n}\n", "import type { Random } from '../random'\n\nexport function normal(random: Random, mu = 0, sigma = 1) {\n  return () => {\n    let x: number, y: number, r: number\n\n    do {\n      x = random.next() * 2 - 1\n      y = random.next() * 2 - 1\n      r = x * x + y * y\n    } while (!r || r > 1)\n\n    return mu + sigma * y * Math.sqrt((-2 * Math.log(r)) / r)\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function pareto(random: Random, alpha = 1) {\n  numberValidator(alpha).greaterThanOrEqual(0)\n  const invAlpha = 1.0 / alpha\n\n  return () => {\n    return 1.0 / Math.pow(1.0 - random.next(), invAlpha)\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nconst logFactorialTable = [\n  0.0, 0.0, 0.693_147_180_559_945_29, 1.791_759_469_228_055,\n  3.178_053_830_347_945_8, 4.787_491_742_782_045_8, 6.579_251_212_010_101_2,\n  8.525_161_361_065_414_7, 10.604_602_902_745_251, 12.801_827_480_081_469\n]\n\nconst logFactorial = (k: number) => {\n  return logFactorialTable[k]\n}\n\nconst logSqrt2PI = 0.918_938_533_204_672_67\n\nexport function poisson(random: Random, lambda = 1) {\n  numberValidator(lambda).isPositive()\n\n  if (lambda < 10) {\n    // inversion method\n    const expMean = Math.exp(-lambda)\n\n    return () => {\n      let p = expMean\n      let x = 0\n      let u = random.next()\n\n      while (u > p) {\n        u = u - p\n        p = (lambda * p) / ++x\n      }\n\n      return x\n    }\n  } else {\n    // generative method\n    const smu = Math.sqrt(lambda)\n    const b = 0.931 + 2.53 * smu\n    const a = -0.059 + 0.024_83 * b\n    const invAlpha = 1.1239 + 1.1328 / (b - 3.4)\n    const vR = 0.9277 - 3.6224 / (b - 2)\n\n    return () => {\n      while (true) {\n        let u\n        let v = random.next()\n\n        if (v <= 0.86 * vR) {\n          u = v / vR - 0.43\n          return Math.floor(\n            ((2 * a) / (0.5 - Math.abs(u)) + b) * u + lambda + 0.445\n          )\n        }\n\n        if (v >= vR) {\n          u = random.next() - 0.5\n        } else {\n          u = v / vR - 0.93\n          u = (u < 0 ? -0.5 : 0.5) - u\n          v = random.next() * vR\n        }\n\n        const us = 0.5 - Math.abs(u)\n        if (us < 0.013 && v > us) {\n          continue\n        }\n\n        const k = Math.floor(((2 * a) / us + b) * u + lambda + 0.445)\n        v = (v * invAlpha) / (a / (us * us) + b)\n\n        if (k >= 10) {\n          const t =\n            (k + 0.5) * Math.log(lambda / k) -\n            lambda -\n            logSqrt2PI +\n            k -\n            (1 / 12.0 - (1 / 360.0 - 1 / (1260.0 * k * k)) / (k * k)) / k\n\n          if (Math.log(v * smu) <= t) {\n            return k\n          }\n        } else if (k >= 0) {\n          const f = logFactorial(k) ?? 0\n\n          if (Math.log(v) <= k * Math.log(lambda) - lambda - f) {\n            return k\n          }\n        }\n      }\n    }\n  }\n}\n", "import type { Random } from '../random'\n\nexport function uniform(random: Random, min = 0, max = 1) {\n  return () => {\n    return random.next() * (max - min) + min\n  }\n}\n", "import type { Random } from '../random'\n\nexport function uniformBoolean(random: Random) {\n  return () => {\n    return random.next() >= 0.5\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function uniformInt(random: Random, min = 0, max = 1) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min\n    min = 0\n  }\n\n  numberValidator(min).isInt()\n  numberValidator(max).isInt()\n\n  return () => {\n    return Math.floor(random.next() * (max - min + 1) + min)\n  }\n}\n", "import type { Random } from '../random'\nimport { numberValidator } from '../validation'\n\nexport function weibull(random: Random, lambda: number, k: number) {\n  numberValidator(lambda).greaterThan(0.0)\n  numberValidator(k).greaterThan(0.0)\n  return () => {\n    const u = 1.0 - random.next()\n    return lambda * Math.pow(-Math.log(u), 1.0 / k)\n  }\n}\n", "import type { RNG } from './rng'\nimport type { SeedOrRNG } from './types'\nimport { bates } from './distributions/bates'\nimport { bernoulli } from './distributions/bernoulli'\nimport { binomial } from './distributions/binomial'\nimport { exponential } from './distributions/exponential'\nimport { geometric } from './distributions/geometric'\nimport { irwinHall } from './distributions/irwin-hall'\nimport { logNormal } from './distributions/log-normal'\nimport { normal } from './distributions/normal'\nimport { pareto } from './distributions/pareto'\nimport { poisson } from './distributions/poisson'\nimport { uniform } from './distributions/uniform'\nimport { uniformBoolean } from './distributions/uniform-boolean'\nimport { uniformInt } from './distributions/uniform-int'\nimport { weibull } from './distributions/weibull'\nimport { MathRandomRNG } from './generators/math-random'\nimport { createRNG, shuffleInPlace, sparseFisherYates } from './utils'\n\n/**\n * Distribution function\n */\ntype IDistFn<R> = (random: Random, ...argv: any) => R\n\n/**\n * Distribution\n */\ntype IDist<R> = () => R\n\n/**\n * Keyed cache entry\n */\ninterface ICacheEntry<T> {\n  key: string\n  distribution: () => T\n}\n\n/**\n * Seedable random number generator supporting many common distributions.\n *\n * @name Random\n * @class\n *\n * @param {RNG|function|string|number} [rng=Math.random] - Underlying random number generator or a seed for the default PRNG. Defaults to `Math.random`.\n */\nexport class Random {\n  protected _rng!: RNG\n  protected _cache: {\n    [k: string]: ICacheEntry<any>\n  } = {}\n\n  constructor(seedOrRNG: SeedOrRNG = new MathRandomRNG()) {\n    this._rng = createRNG(seedOrRNG)\n  }\n\n  /**\n   * @member {RNG} rng - Underlying pseudo-random number generator.\n   */\n  get rng() {\n    return this._rng\n  }\n\n  /**\n   * Creates a new `Random` instance, optionally specifying parameters to\n   * set a new seed.\n   */\n  clone(seedOrRNG: SeedOrRNG = this.rng.clone()): Random {\n    return new Random(seedOrRNG)\n  }\n\n  /**\n   * Sets the underlying pseudorandom number generator.\n   *\n   * @example\n   * ```ts\n   * import random from 'random'\n   *\n   * random.use('example-seed')\n   * // or\n   * random.use(Math.random)\n   * ```\n   */\n  use(seedOrRNG: SeedOrRNG) {\n    this._rng = createRNG(seedOrRNG)\n    this._cache = {}\n  }\n\n  // --------------------------------------------------------------------------\n  // Uniform utility functions\n  // --------------------------------------------------------------------------\n\n  /**\n   * Convenience wrapper around `this.rng.next()`\n   *\n   * Returns a floating point number in [0, 1).\n   *\n   * @return {number}\n   */\n  next(): number {\n    return this._rng.next()\n  }\n\n  /**\n   * Samples a uniform random floating point number, optionally specifying\n   * lower and upper bounds.\n   *\n   * Convenience wrapper around `random.uniform()`\n   *\n   * @param {number} [min=0] - Lower bound (float, inclusive)\n   * @param {number} [max=1] - Upper bound (float, exclusive)\n   */\n  float(min?: number, max?: number): number {\n    return this.uniform(min, max)()\n  }\n\n  /**\n   * Samples a uniform random integer, optionally specifying lower and upper\n   * bounds.\n   *\n   * Convenience wrapper around `random.uniformInt()`\n   *\n   * @param {number} [min=0] - Lower bound (integer, inclusive)\n   * @param {number} [max=1] - Upper bound (integer, inclusive)\n   */\n  int(min?: number, max?: number): number {\n    return this.uniformInt(min, max)()\n  }\n\n  /**\n   * Samples a uniform random integer, optionally specifying lower and upper\n   * bounds.\n   *\n   * Convenience wrapper around `random.uniformInt()`\n   *\n   * @alias `random.int`\n   *\n   * @param {number} [min=0] - Lower bound (integer, inclusive)\n   * @param {number} [max=1] - Upper bound (integer, inclusive)\n   */\n  integer(min?: number, max?: number): number {\n    return this.uniformInt(min, max)()\n  }\n\n  /**\n   * Samples a uniform random boolean value.\n   *\n   * Convenience wrapper around `random.uniformBoolean()`\n   *\n   * @alias `random.boolean`\n   */\n  bool(): boolean {\n    return this.uniformBoolean()()\n  }\n\n  /**\n   * Samples a uniform random boolean value.\n   *\n   * Convenience wrapper around `random.uniformBoolean()`\n   */\n  boolean(): boolean {\n    return this.uniformBoolean()()\n  }\n\n  /**\n   * Returns an item chosen uniformly at random from the given array.\n   *\n   * Convenience wrapper around `random.uniformInt()`\n   *\n   * @param {Array<T>} [array] - Input array\n   */\n  choice<T>(array: Array<T>): T | undefined {\n    if (!Array.isArray(array)) {\n      throw new TypeError(\n        `Random.choice expected input to be an array, got ${typeof array}`\n      )\n    }\n\n    const length = array.length\n\n    if (length > 0) {\n      const index = this.uniformInt(0, length - 1)()\n      return array[index]\n    } else {\n      return undefined\n    }\n  }\n\n  /**\n   * Returns a random subset of k items from the given array (without replacement).\n   *\n   * @param {Array<T>} [array] - Input array\n   */\n  sample<T>(array: Array<T>, k: number): Array<T> {\n    if (!Array.isArray(array)) {\n      throw new TypeError(\n        `Random.sample expected input to be an array, got ${typeof array}`\n      )\n    }\n    if (k < 0 || k > array.length) {\n      throw new Error(\n        `Random.sample: k must be between 0 and array.length (${array.length}), got ${k}`\n      )\n    }\n    return sparseFisherYates(this.rng, array, k)\n  }\n\n  /**\n   * Generates a thunk which returns samples of size k from the given array.\n   *\n   * This is for convenience only; there is no gain in efficiency.\n   *\n   * @param {Array<T>} [array] - Input array\n   */\n  sampler<T>(array: Array<T>, k: number): () => Array<T> {\n    if (!Array.isArray(array)) {\n      throw new TypeError(\n        `Random.sampler expected input to be an array, got ${typeof array}`\n      )\n    }\n    if (k < 0 || k > array.length) {\n      throw new Error(\n        `Random.sampler: k must be between 0 and array.length (${array.length}), got ${k}`\n      )\n    }\n\n    const gen = this.rng\n\n    return () => {\n      return sparseFisherYates(gen, array, k)\n    }\n  }\n\n  /**\n   * Returns a shuffled copy of the given array.\n   *\n   * @param {Array<T>} [array] - Input array\n   */\n  shuffle<T>(array: Array<T>): Array<T> {\n    if (!Array.isArray(array)) {\n      throw new TypeError(\n        `Random.shuffle expected input to be an array, got ${typeof array}`\n      )\n    }\n\n    const copy = [...array]\n    shuffleInPlace(this.rng, copy)\n\n    return copy\n  }\n\n  /**\n   * Generates a thunk which returns shuffled copies of the given array.\n   *\n   * @param {Array<T>} [array] - Input array\n   */\n  shuffler<T>(array: Array<T>): () => Array<T> {\n    if (!Array.isArray(array)) {\n      throw new TypeError(\n        `Random.shuffler expected input to be an array, got ${typeof array}`\n      )\n    }\n\n    const gen = this.rng\n    const copy = [...array]\n\n    return () => {\n      shuffleInPlace(gen, copy)\n      return [...copy]\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // Uniform distributions\n  // --------------------------------------------------------------------------\n\n  /**\n   * Generates a [Continuous uniform distribution](https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)).\n   *\n   * @param {number} [min=0] - Lower bound (float, inclusive)\n   * @param {number} [max=1] - Upper bound (float, exclusive)\n   */\n  uniform(min?: number, max?: number): IDist<number> {\n    return this._memoize<number>('uniform', uniform, min, max)\n  }\n\n  /**\n   * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution).\n   *\n   * @param {number} [min=0] - Lower bound (integer, inclusive)\n   * @param {number} [max=1] - Upper bound (integer, inclusive)\n   */\n  uniformInt(min?: number, max?: number): IDist<number> {\n    return this._memoize<number>('uniformInt', uniformInt, min, max)\n  }\n\n  /**\n   * Generates a [Discrete uniform distribution](https://en.wikipedia.org/wiki/Discrete_uniform_distribution),\n   * with two possible outcomes, `true` or `false.\n   *\n   * This method is analogous to flipping a coin.\n   */\n  uniformBoolean(): IDist<boolean> {\n    return this._memoize<boolean>('uniformBoolean', uniformBoolean)\n  }\n\n  // --------------------------------------------------------------------------\n  // Normal distributions\n  // --------------------------------------------------------------------------\n\n  /**\n   * Generates a [Normal distribution](https://en.wikipedia.org/wiki/Normal_distribution).\n   *\n   * @param {number} [mu=0] - Mean\n   * @param {number} [sigma=1] - Standard deviation\n   */\n  normal(mu?: number, sigma?: number): IDist<number> {\n    return normal(this, mu, sigma)\n  }\n\n  /**\n   * Generates a [Log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution).\n   *\n   * @param {number} [mu=0] - Mean of underlying normal distribution\n   * @param {number} [sigma=1] - Standard deviation of underlying normal distribution\n   */\n  logNormal(mu?: number, sigma?: number): IDist<number> {\n    return logNormal(this, mu, sigma)\n  }\n\n  // --------------------------------------------------------------------------\n  // Bernoulli distributions\n  // --------------------------------------------------------------------------\n\n  /**\n   * Generates a [Bernoulli distribution](https://en.wikipedia.org/wiki/Bernoulli_distribution).\n   *\n   * @param {number} [p=0.5] - Success probability of each trial.\n   */\n  bernoulli(p?: number): IDist<number> {\n    return bernoulli(this, p)\n  }\n\n  /**\n   * Generates a [Binomial distribution](https://en.wikipedia.org/wiki/Binomial_distribution).\n   *\n   * @param {number} [n=1] - Number of trials.\n   * @param {number} [p=0.5] - Success probability of each trial.\n   */\n  binomial(n?: number, p?: number): IDist<number> {\n    return binomial(this, n, p)\n  }\n\n  /**\n   * Generates a [Geometric distribution](https://en.wikipedia.org/wiki/Geometric_distribution).\n   *\n   * @param {number} [p=0.5] - Success probability of each trial.\n   */\n  geometric(p?: number): IDist<number> {\n    return geometric(this, p)\n  }\n\n  // --------------------------------------------------------------------------\n  // Poisson distributions\n  // --------------------------------------------------------------------------\n\n  /**\n   * Generates a [Poisson distribution](https://en.wikipedia.org/wiki/Poisson_distribution).\n   *\n   * @param {number} [lambda=1] - Mean (lambda > 0)\n   */\n  poisson(lambda?: number): IDist<number> {\n    return poisson(this, lambda)\n  }\n\n  /**\n   * Generates an [Exponential distribution](https://en.wikipedia.org/wiki/Exponential_distribution).\n   *\n   * @param {number} [lambda=1] - Inverse mean (lambda > 0)\n   */\n  exponential(lambda?: number): IDist<number> {\n    return exponential(this, lambda)\n  }\n\n  // --------------------------------------------------------------------------\n  // Misc distributions\n  // --------------------------------------------------------------------------\n\n  /**\n   * Generates an [Irwin Hall distribution](https://en.wikipedia.org/wiki/Irwin%E2%80%93Hall_distribution).\n   *\n   * @param {number} [n=1] - Number of uniform samples to sum (n >= 0)\n   */\n  irwinHall(n?: number): IDist<number> {\n    return irwinHall(this, n)\n  }\n\n  /**\n   * Generates a [Bates distribution](https://en.wikipedia.org/wiki/Bates_distribution).\n   *\n   * @param {number} [n=1] - Number of uniform samples to average (n >= 1)\n   */\n  bates(n?: number): IDist<number> {\n    return bates(this, n)\n  }\n\n  /**\n   * Generates a [Pareto distribution](https://en.wikipedia.org/wiki/Pareto_distribution).\n   *\n   * @param {number} [alpha=1] - Alpha\n   */\n  pareto(alpha?: number): IDist<number> {\n    return pareto(this, alpha)\n  }\n\n  /**\n   * Generates a [Weibull distribution](https://en.wikipedia.org/wiki/Weibull_distribution).\n   *\n   * @param {number} [lambda] - Lambda, the scale parameter\n   * @param {number} [k] - k, the shape parameter\n   */\n  weibull(lambda: number, k: number) {\n    return weibull(this, lambda, k)\n  }\n\n  // --------------------------------------------------------------------------\n  // Internal\n  // --------------------------------------------------------------------------\n\n  /**\n   * Memoizes distributions to ensure they're only created when necessary.\n   *\n   * Returns a thunk which that returns independent, identically distributed\n   * samples from the specified distribution.\n   *\n   * @internal\n   *\n   * @param {string} label - Name of distribution\n   * @param {function} getter - Function which generates a new distribution\n   * @param {...*} args - Distribution-specific arguments\n   */\n  protected _memoize<T>(\n    label: string,\n    getter: IDistFn<any>,\n    ...args: any[]\n  ): IDist<T> {\n    // return getter(this, ...args)\n    const key = `${args.join(';')}`\n    let value = this._cache[label]\n\n    if (value === undefined || value.key !== key) {\n      value = {\n        key,\n        distribution: getter(this, ...args)\n      }\n      this._cache[label] = value\n    }\n\n    return value.distribution\n  }\n}\n\nexport default new Random()\n", "import { Random as RandomLib } from \"random\";\n/** Creates a {@link Random} using Math.random(). */\nexport const createRandom = () => ({\n    next: () => Math.random(),\n});\n/**\n * Creates {@link Random} using {@link RandomLibDep} with a seed which is useful\n * for tests.\n */\nexport const createRandomWithSeed = (seed) => {\n    const random = new RandomLib(seed);\n    return {\n        next: () => random.next(),\n    };\n};\n/** Creates a `RandomLib` using the NPM `random` package. */\nexport const createRandomLib = () => new RandomLib();\n/**\n * Creates {@link RandomLibDep} using the NPM `random` package with a seed which\n * is useful for tests.\n */\nexport const createRandomLibWithSeed = (seed) => ({\n    random: new RandomLib(seed),\n});\n", "import { assert } from \"./Assert.js\";\n/** Creates a {@link Redacted} wrapper for a sensitive value. */\nexport const createRedacted = (value) => {\n    const redacted = Object.create(proto);\n    registry.set(redacted, value);\n    return redacted;\n};\nconst proto = {\n    toString: () => redactedString,\n    toJSON: () => redactedString,\n    [Symbol.for(\"nodejs.util.inspect.custom\")]: () => redactedString,\n    [Symbol.dispose]() {\n        registry.delete(this);\n    },\n};\nconst redactedString = \"<redacted>\";\nconst registry = new WeakMap();\n/**\n * Reveals the original value from a {@link Redacted} wrapper.\n *\n * This is a separate function rather than a method on {@link Redacted} to make\n * access visually explicit and easy to grep in code reviews. Accessing\n * sensitive values should feel intentional, not convenient.\n */\nexport const revealRedacted = (redacted) => {\n    assert(registry.has(redacted), \"Redacted value was not in registry\");\n    return registry.get(redacted);\n};\n/** Checks if a value is a {@link Redacted} wrapper. */\nexport const isRedacted = (value) => typeof value === \"object\" &&\n    value !== null &&\n    Object.getPrototypeOf(value) === proto;\n/**\n * Creates an {@link Eq} for {@link Redacted} values based on an equality function\n * for the underlying type.\n *\n * ### Example\n *\n * ```ts\n * type ApiKey = string & Brand<\"ApiKey\">;\n * const eqRedactedApiKey = createEqRedacted<ApiKey>(eqString);\n *\n * const a = createRedacted(\"x\" as ApiKey);\n * const b = createRedacted(\"x\" as ApiKey);\n * eqRedactedApiKey(a, b); // true\n * ```\n */\nexport const createEqRedacted = (eq) => (x, y) => eq(revealRedacted(x), revealRedacted(y));\n", "/** Creates a {@link Ref} with the given initial state. */\nexport const createRef = (initialState) => {\n    let currentState = initialState;\n    return {\n        get: () => currentState,\n        set: (state) => {\n            currentState = state;\n        },\n        modify: (updater) => {\n            currentState = updater(currentState);\n        },\n    };\n};\n", "import { assert } from \"./Assert.js\";\n/** Creates a {@link Relation}. */\nexport const createRelation = () => {\n    const aToB = new Map();\n    const bToA = new Map();\n    let sizeInternal = 0;\n    const relation = {\n        add(a, b) {\n            let bSet = aToB.get(a);\n            if (bSet?.has(b))\n                return false;\n            if (!bSet) {\n                bSet = new Set();\n                aToB.set(a, bSet);\n            }\n            bSet.add(b);\n            let aSet = bToA.get(b);\n            if (!aSet) {\n                aSet = new Set();\n                bToA.set(b, aSet);\n            }\n            aSet.add(a);\n            sizeInternal++;\n            return true;\n        },\n        remove(a, b) {\n            const bSet = aToB.get(a);\n            if (!bSet?.has(b))\n                return false;\n            bSet.delete(b);\n            if (bSet.size === 0) {\n                aToB.delete(a);\n            }\n            const aSet = bToA.get(b);\n            assert(aSet, \"Relation mapping inconsistency\");\n            aSet.delete(a);\n            if (aSet.size === 0) {\n                bToA.delete(b);\n            }\n            sizeInternal--;\n            return true;\n        },\n        getB(a) {\n            return aToB.get(a);\n        },\n        getA(b) {\n            return bToA.get(b);\n        },\n        forEach(callback) {\n            for (const [a, bSet] of aToB) {\n                for (const b of bSet)\n                    callback(a, b);\n            }\n        },\n        [Symbol.iterator]() {\n            const iterator = function* () {\n                for (const [a, bSet] of aToB) {\n                    for (const b of bSet) {\n                        yield [a, b];\n                    }\n                }\n            };\n            return iterator();\n        },\n        has(a, b) {\n            const bSet = aToB.get(a);\n            return bSet?.has(b) ?? false;\n        },\n        hasA(a) {\n            return aToB.has(a);\n        },\n        hasB(b) {\n            return bToA.has(b);\n        },\n        deleteA(a) {\n            const bSet = aToB.get(a);\n            if (!bSet)\n                return false;\n            const removed = bSet.size;\n            for (const b of bSet) {\n                const aSet = bToA.get(b);\n                if (aSet) {\n                    aSet.delete(a);\n                    if (aSet.size === 0) {\n                        bToA.delete(b);\n                    }\n                }\n            }\n            aToB.delete(a);\n            sizeInternal -= removed;\n            return true;\n        },\n        deleteB(b) {\n            const aSet = bToA.get(b);\n            if (!aSet)\n                return false;\n            const removed = aSet.size;\n            for (const a of aSet) {\n                const bSet = aToB.get(a);\n                if (bSet) {\n                    bSet.delete(b);\n                    if (bSet.size === 0) {\n                        aToB.delete(a);\n                    }\n                }\n            }\n            bToA.delete(b);\n            sizeInternal -= removed;\n            return true;\n        },\n        clear() {\n            aToB.clear();\n            bToA.clear();\n            sizeInternal = 0;\n        },\n        aCount() {\n            return aToB.size;\n        },\n        bCount() {\n            return bToA.size;\n        },\n        size() {\n            return sizeInternal;\n        },\n    };\n    return relation;\n};\n", "import { err, ok } from \"./Result.js\";\nimport { retry } from \"./Task.js\";\nimport { maxPositiveInt } from \"./Type.js\";\n/**\n * Create a new {@link WebSocket}.\n *\n * The default behavior is that WebSocket tries to reconnect repeatedly in case\n * the application is offline, because online events (both web and native) are\n * not reliable. Once it connects and the connection is closed, it tries to\n * reconnect again. Retrying the connection can be controlled using the\n * retryOptions retryable predicate.\n *\n * ### How Binary Messages Work in WebSockets\n *\n * The Server Chooses the Message Type:\n *\n * - Text (0x1)  Sent as UTF-8 encoded text (always received as a string in the\n *   browser).\n * - Binary (0x2)  Sent as raw binary data (received as a Blob or ArrayBuffer,\n *   depending on binaryType).\n *\n * The Client's binaryType Controls How Binary Data is Processed:\n *\n * - If the server sends a text frame (0x1), the browser always delivers\n *   event.data as a string, regardless of binaryType.\n * - If the server sends a binary frame (0x2), the browser delivers event.data as:\n *\n *   - A Blob (default: \"blob\")\n *   - An ArrayBuffer (\"arraybuffer\")\n *\n * ### Example\n *\n * TODO:\n */\nexport const createWebSocket = (url, { protocols, binaryType, onOpen, onClose, onMessage, onError, retryOptions, WebSocketConstructor = globalThis.WebSocket, } = {}) => {\n    let isDisposed = false;\n    const reconnectController = new AbortController();\n    const defaultRetryOptions = {\n        retries: maxPositiveInt, // Practically infinite retries\n    };\n    let socket = null;\n    const disposeSocket = () => {\n        if (!socket)\n            return;\n        // Remove all listeners before closing\n        socket.onopen = null;\n        socket.onclose = null;\n        socket.onmessage = null;\n        socket.onerror = null;\n        if (socket.readyState !== socket.CLOSING &&\n            socket.readyState !== socket.CLOSED) {\n            socket.close();\n        }\n        socket = null;\n    };\n    // To prevent a memory leak from pending connection promise.\n    let disposePromise = null;\n    /**\n     * This promise represents continuous connection which:\n     *\n     * - Is rejected when a connection cannot be established.\n     * - Is rejected when a connection is closed.\n     * - Is resolved when WebSocket is disposed().\n     */\n    void retry({\n        ...defaultRetryOptions,\n        ...retryOptions,\n    }, () => new Promise((resolve) => {\n        disposePromise = () => {\n            resolve(ok());\n        };\n        if (isDisposed)\n            disposePromise();\n        disposeSocket();\n        socket = new WebSocketConstructor(url, protocols);\n        if (binaryType)\n            socket.binaryType = binaryType;\n        let isOpen = false;\n        socket.onopen = () => {\n            isOpen = true;\n            onOpen?.();\n        };\n        socket.onerror = (event) => {\n            const error = isOpen\n                ? { type: \"WebSocketConnectionError\", event }\n                : { type: \"WebSocketConnectError\", event };\n            onError?.(error);\n            // Trigger reconnect only on WebSocketConnectError.\n            if (error.type === \"WebSocketConnectError\") {\n                resolve(err(error));\n            }\n        };\n        socket.onclose = (event) => {\n            onClose?.(event);\n            resolve(err({ type: \"WebSocketConnectionCloseError\", event }));\n        };\n        socket.onmessage = (event) => {\n            onMessage?.(event.data);\n        };\n    }))(reconnectController).then((result) => {\n        if (result.ok || result.error.type === \"AbortError\")\n            return;\n        onError?.(result.error);\n    });\n    return {\n        send: (data) => {\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n            if (!socket || socket.readyState === socket.CONNECTING) {\n                return err({ type: \"WebSocketSendError\" });\n            }\n            socket.send(data);\n            return ok();\n        },\n        getReadyState: () => socket ? nativeToStringState[socket.readyState] : \"connecting\",\n        isOpen: () => (socket ? socket.readyState === socket.OPEN : false),\n        [Symbol.dispose]() {\n            if (isDisposed)\n                return;\n            isDisposed = true;\n            reconnectController.abort();\n            disposeSocket();\n            disposePromise?.();\n        },\n    };\n};\nconst nativeToStringState = {\n    [WebSocket.CONNECTING]: \"connecting\",\n    [WebSocket.OPEN]: \"open\",\n    [WebSocket.CLOSING]: \"closing\",\n    [WebSocket.CLOSED]: \"closed\",\n};\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["array", "min", "max", "length", "min", "hex", "array", "isLE", "isBytes", "anumber", "abytes", "length", "aexists", "aoutput", "min", "clean", "createView", "isLE", "hasHexBuiltin", "hexes", "utf8ToBytes", "randomBytes", "isLE", "createView", "aexists", "abytes", "dataView", "aoutput", "clean", "length", "clean", "abytes", "clean", "aexists", "abytes", "crypto", "sha256", "sha384", "sha512", "hmac", "isBytes", "abytes", "anumber", "id", "encode", "decode", "padding", "max", "alphabet", "encode", "isBytes", "decode", "hasHexBuiltin", "abytes", "wordlist", "normalize", "abytes", "wordlist", "normalize", "id", "id", "object", "array", "length", "readObject", "length", "length", "array", "object", "id", "decode", "target", "length", "position", "bundledStrings", "referenceMap", "packr", "pack", "maxBytes", "json", "array", "object", "key", "newPosition", "target", "targetView", "set", "regex", "encode", "id", "packr", "record", "hasNodeBuffer", "String", "Number", "BigInt", "Boolean", "Function", "Uint8Array", "Date", "min", "max", "hasNodeBuffer", "base64", "id", "record", "errors", "error", "err", "length", "id", "object", "console", "rotl", "isAligned32", "rotl", "Uint8Array", "randomBytes", "utf8ToBytes", "length", "err", "K", "clean", "id", "errors", "String", "Number", "Uint8Array", "strings", "sql", "message", "min", "max", "String", "String", "Uint8Array", "String", "Boolean", "String", "timeout", "id", "result", "id", "schema", "dbSchema", "owner", "id", "sql", "sql", "array", "i", "irwinHall", "normal", "min", "max", "array", "length"]
}
